-- Modified by: Holodilnik, DoctorX, av661194

-- Global var to store last available task id:
last_task_id = nil
last_task_npc = nil

-- A.R.E.A.: Number of current random description in tasks to prevent different stories in current session
local n = {}

-- A.R.E.A. task functions by Holodilnik
function is_package(a, b)
	local npc = dialogs.who_is_npc(a, b)
	local t = {"simulation_task_73", "simulation_task_74", "simulation_task_75", "simulation_task_76", "simulation_task_77", "simulation_task_78", "simulation_task_79", "simulation_task_80", "drx_sl_esc_m_trader_task_3", "drx_sl_dasc_trade_mlr_task_3", "drx_sl_dasc_tech_mlr_task_3"}
	local id = npc:id()
	if not (id) then 
		return false 
	end
	local tm = task_manager.get_task_manager()
	local task_info = tm.task_info
	local target_id
	local tsk
	for k,task_id in pairs(t) do
		target_id = alun_utils.load_var(db.actor, task_id, nil)
		tsk = task_info[task_id]
		if (tsk and tsk.stage == 0) and (target_id ~= nil) and (target_id == id) and (not db.actor:has_info(target_id .. "_on_package_complete")) then
			return true
		end
	end
	return false
end

function is_actor_have_package(a, b)

	local npc = dialogs.who_is_npc(a, b)
	local num = alun_utils.load_var(db.actor, npc:id() .. "_package_num", 0)
	local sec = alun_utils.load_var(db.actor, npc:id() .. "_package_sec", 0)
	local cnt = 0
	local function section_count(npc, item)
		if (item:section() == sec) and (item:condition() > 0.95) then
			cnt = cnt + 1
		end
	end
	db.actor:iterate_inventory(section_count, nil)
	
	if (cnt >= num) then
		return true
	end
	
	return false
	
end

function is_actor_havent_package(a, b)
	return not is_actor_have_package(a, b)
end

function is_debtor(a, b)
	local npc = dialogs.who_is_npc(a, b)
	local t = {"simulation_task_47", "simulation_task_48", "simulation_task_49", "simulation_task_50", "simulation_task_51", "drx_sl_dasc_tech_mlr_task_4", "drx_sl_dasc_trade_mlr_task_4", "drx_sl_esc_m_trader_task_4"}
	local id = npc:id()
	if not (id) then 
		return false 
	end
	local tm = task_manager.get_task_manager()
	local task_info = tm.task_info
	local target_id
	local tsk
	for k,task_id in pairs(t) do
		target_id = alun_utils.load_var(db.actor, task_id, nil)
		tsk = task_info[task_id]
		if (tsk and tsk.stage == 0) and (target_id ~= nil) and (target_id == id) and (not db.actor:has_info(target_id .. "_on_debt_complete")) and (not db.actor:has_info(target_id .. "_dd_processed")) then
			return true
		end
	end
	return false
end

function debt_chance()
	local t = {"simulation_task_47", "simulation_task_48", "simulation_task_49", "simulation_task_50", "simulation_task_51", "drx_sl_dasc_tech_mlr_task_4", "drx_sl_dasc_trade_mlr_task_4", "drx_sl_esc_m_trader_task_4"}
	local tm = task_manager.get_task_manager()
	local task_info = tm.task_info
	local target_id
	local tsk
	for k,task_id in pairs(t) do
		target_id = alun_utils.load_var(db.actor, task_id, nil)
		if not target_id then return end
		tsk = task_info[task_id]
		if (tsk and tsk.stage == 0) and (target_id ~= nil) and (not db.actor:has_info(target_id .. "_on_debt_complete")) then
			local npc = alife_object(target_id)
			ranks.read_all_ranks()
			if npc and ((ranks.get_se_obj_rank_name(npc) == "trainee") or (ranks.get_se_obj_rank_name(npc) == "novice")) then
				local number = math.random(2,3)
				if (number == 2) then
					number = 1
				end
				alun_utils.save_var(db.actor, "chance_debt_dialog", number)
				return
			end
		end
	end
	alun_utils.save_var(db.actor, "chance_debt_dialog", math.random(1,3))
end

function panick_to_actor(a, b)
	local npc = who_is_npc(a, b)
	db.storage[npc:id()].panicked_to_actor = true
end

function is_first_debt_dialog(a, b)
	local d = alun_utils.load_var(db.actor, "chance_debt_dialog", nil)
	if (d == 1) and (d ~= nil) then
		return true
	end
	return false
end

function is_second_debt_dialog(a, b)
	local d = alun_utils.load_var(db.actor, "chance_debt_dialog", nil)
	if (d == 2) and (d ~= nil) then
		return true
	end
	return false
end

function is_third_debt_dialog(a, b)
	local d = alun_utils.load_var(db.actor, "chance_debt_dialog", nil)
	if (d == 3) and (d ~= nil) then
		return true
	end
	return false
end


function set_dd_chance_nil(a, b)
	local npc = who_is_npc(a, b)
	alun_utils.save_var(db.actor, "chance_debt_dialog", nil)
	db.actor:give_info_portion(npc:id() .. "_dd_processed")
end

function give_debt(a, b)
	local npc = who_is_npc(a, b)
	local amount = alun_utils.load_var(db.actor, npc:id() .. "_debt_amount", nil)
	dialogs.relocate_money(db.actor, amount, "in")
	db.actor:give_info_portion(npc:id() .. "_on_debt_complete")
end

function st_debt_task_dialog_good(a, b)
	return string.format(game.translate_string("st_debt_task_dialog_good_" .. math.random(1,5))) or ""
end

function st_debt_task_dialog_bad(a, b)
	return string.format(game.translate_string("st_debt_task_dialog_bad_" .. math.random(1,5))) or ""
end

function st_debt_task_dialog_fight(a, b)
	return string.format(game.translate_string("st_debt_task_dialog_fight_" .. math.random(1,5))) or ""
end

function st_debt_task_dialog_retreat(a, b)
	return string.format(game.translate_string("st_debt_task_dialog_retreat_" .. math.random(1,5))) or ""
end

function st_universal_agree(a, b)
	return string.format(game.translate_string("st_universal_agree_" .. math.random(1,5))) or ""
end

function st_package_task_dialog_good(a, b)
	return string.format(game.translate_string("st_package_task_dialog_good_" .. math.random(1,5))) or ""
end

function st_package_task_dialog_bad(a, b)
	return string.format(game.translate_string("st_package_task_dialog_bad_" .. math.random(1,5))) or ""
end

function take_package(a, b)
	local npc = who_is_npc(a, b)
	local sec = alun_utils.load_var(db.actor, npc:id() .. "_package_sec", nil)
	local amount = alun_utils.load_var(db.actor, npc:id() .. "_package_num", nil)
	dialogs.relocate_item_section_from_actor(db.actor,npc,sec,amount)
	db.actor:give_info_portion(npc:id() .. "_on_package_complete")
end

--A.R.E.A. Completed task dialog functions by Holodilnik
function sim_dynamic_task_completed_chance()
	local npc = area_utils.last_used_npc
	alun_utils.save_var(db.actor, "chance_debt_dialog", math.random(1,3))
end

function collect_reward_cost(task_id)
	--local rtask = task_manager.get_task_manager().task_info[task_id]
	--local condlist = rtask.on_complete
	local condlist = task_manager.task_ini:r_string_to_condlist(task_id,"on_complete")
	local is_item = false
	local is_stash = false
	local is_money = false
	local is_only_item = false
	local is_only_stash = false
	local is_only_money = false
	local reward_cost = 0
	for i=1, #condlist[1][3] do
		local rew_func_table_name = condlist[1][3][i][1]
		if (rew_func_table_name == "drx_sl_fetch_reward_money") then
			reward_cost = (reward_cost + (xr_effects.drx_sl_fetch_reward_money(nil, nil, {condlist[1][3][i][3][1], condlist[1][3][i][3][2], true})))
			is_money = true
		elseif (rew_func_table_name == "reward_stash") then
			reward_cost = (reward_cost + math.random(2000,3000))
			is_stash = true
		elseif (rew_func_table_name == "reward_random_item") then
			local item_list = {}
			for d=1, #condlist[1][3][i][3] do
				table.insert(item_list, condlist[1][3][i][3][d])
			end
			item_list[10] = true
			--reward_cost = (reward_cost + (xr_effects.reward_random_item(nil, nil, item_list)))
			is_item = true
		elseif (rew_func_table_name == "reward_random_money") then
			reward_cost = (reward_cost + math.random(condlist[1][3][i][3][1], condlist[1][3][i][3][2]))
			is_money = true
		elseif (rew_func_table_name == "drx_sl_reward_random_money") then
			reward_cost = (reward_cost + math.random(condlist[1][3][i][3][1], condlist[1][3][i][3][2]))
			is_money = true
		elseif (rew_func_table_name == "reward_debt_money") then
			--reward_cost = (reward_cost + (xr_effects.reward_debt_money(nil, nil, {condlist[1][3][i][3][1], true})))
			is_money = true
		elseif (rew_func_table_name == "drx_sl_reward") then
			local item_list = {}
			table.insert(item_list, condlist[1][3][i][3][1])
			for d=2, #condlist[1][3][i][3] do
				table.insert(item_list, condlist[1][3][i][3][d])
			end
			item_list[10] = true
			reward_cost = reward_cost + xr_effects.drx_sl_reward(nil, nil, item_list)
			is_item = true
		elseif (rew_func_table_name == "reward_money") then
			reward_cost = reward_cost + condlist[1][3][i][3][1]
			is_money = true
		elseif (rew_func_table_name == "take_package_money") then
			reward_cost = (reward_cost + (xr_effects.take_package_money(nil, nil, {condlist[1][3][i][3][1], true})))
			is_money = true
		end
	end
	if (not is_stash) and (not is_item) then
		is_only_money = true
	end
	if (not is_stash) and (not is_money) then
		is_only_item = true
	end
	if (not is_money) and (not is_item) then
		is_only_stash = true
	end
	local reward_info = {reward_cost, is_money, is_item, is_stash, is_only_money, is_only_item, is_only_stash}
	return reward_info
end

function on_complete_without_reward(a, b)
	local npc = who_is_npc(a, b)
	local tsk = axr_task_manager and axr_task_manager.get_first_finished_task(npc)
	local rtask = task_manager.get_task_manager().task_info[tsk]
	local condlist = rtask.on_complete
	axr_task_manager.set_finished_task_complete(npc)
	local rew_f = {
	["drx_sl_fetch_reward_money"] = true,
	["reward_stash"] = true,
	["reward_random_item"] = true,
	["reward_random_money"] = true,
	["reward_debt_money"] = true,
	["drx_sl_reward"] = true,
	["reward_money"] = true
	}
	for i=1, #condlist[1][3] do
		local rew_func_table_name = condlist[1][3][i][1]
		local str = tostring(rew_func_table_name)
		local par_table = condlist[1][3][i][3]
		if (not rew_f[rew_func_table_name]) and (par_table ~= nil) then
			xr_effects[rew_func_table_name](db.actor, npc, par_table)
			printf("on_complete_without_reward func %s", rew_func_table_name)
		elseif (not rew_f[rew_func_table_name]) and (par_table == nil) and xr_effects[rew_func_table_name] then
			xr_effects[rew_func_table_name](db.actor, npc, par_table)
			printf("on_complete_without_reward func with no pars %s", rew_func_table_name)
		elseif (not rew_f[rew_func_table_name]) and (par_table == nil) then
			db.actor:give_info_portion(rew_func_table_name)
			printf("on_complete_without_reward info portion %s", rew_func_table_name)
		elseif rew_f[rew_func_table_name] then
			printf("on_complete_without_reward skipped func %s", rew_func_table_name)
		else
			printf("on_complete_without_reward there is no condition for %s", rew_func_table_name)
		end
	end
end

function on_complete_without_reward_sim(a, b)
	local npc = who_is_npc(a, b)
	local tsk = axr_task_manager and axr_task_manager.get_first_finished_task(npc, true)
	local rtask = task_manager.get_task_manager().task_info[tsk]
	local condlist = rtask.on_complete
	axr_task_manager.set_finished_task_complete(npc, true)
	local rew_f = {
		["drx_sl_fetch_reward_money"] = true,
		["reward_stash"] = true,
		["reward_random_item"] = true,
		["reward_random_money"] = true,
		["reward_debt_money"] = true,
		["drx_sl_reward"] = true,
		["reward_money"] = true
	}
	for i=1, #condlist[1][3] do
		local rew_func_table_name = condlist[1][3][i][1]
		local str = tostring(rew_func_table_name)
		local par_table = condlist[1][3][i][3]
		if (not rew_f[rew_func_table_name]) and (par_table ~= nil) then
			xr_effects[rew_func_table_name](db.actor, npc, par_table)
			printf("on_complete_without_reward func %s", rew_func_table_name)
		elseif (not rew_f[rew_func_table_name]) and (par_table == nil) and xr_effects[rew_func_table_name] then
			xr_effects[rew_func_table_name](db.actor, npc, par_table)
			printf("on_complete_without_reward func with no pars %s", rew_func_table_name)
		elseif (not rew_f[rew_func_table_name]) and (par_table == nil) then
			db.actor:give_info_portion(rew_func_table_name)
			printf("on_complete_without_reward info portion %s", rew_func_table_name)
		else
			printf("on_complete_without_reward there is no condition for %s", rew_func_table_name)
		end
	end
end

function npc_on_another_reward(a, b)
	local npc = who_is_npc(a, b)
	local tsk = axr_task_manager and axr_task_manager.get_first_finished_task(npc)
	local reward_info = dialogs.collect_reward_cost(tsk)
	local reward = reward_info[1]
	local valid_item_list,valid_item_list_array = coc_treasure_manager.get_valid_item_sections()
	utils.shuffle(valid_item_list_array)
	for i,section in ipairs(valid_item_list_array) do
		local cost = valid_item_list[section] * 1.5
		if (cost > 0) and (((cost + 500) > reward) and ((cost - 500) < reward)) and not (string.find( section, "_radiated" )) then
			dialogs.relocate_item_section(db.actor,section,"in",1)
			return
		end
	end
end

function npc_on_another_reward_sim(a, b)
	local npc = who_is_npc(a, b)
	local tsk = axr_task_manager and axr_task_manager.get_first_finished_task(npc, true)
	local reward_info = dialogs.collect_reward_cost(tsk)
	local reward = reward_info[1]
	local valid_item_list,valid_item_list_array = coc_treasure_manager.get_valid_item_sections()
	utils.shuffle(valid_item_list_array)
	for i,section in ipairs(valid_item_list_array) do
		local cost = valid_item_list[section] * 1.5
		if (cost > 0) and (((cost + 500) > reward) and ((cost - 500) < reward)) and not (string.find( section, "_radiated" )) then
			dialogs.relocate_item_section(db.actor,section,"in",1)
			return
		end
	end
end

function another_on_complete()
	task_manager.is_on_complete = false
end

function text_npc_giving_reward(a, b)
	return string.format(game.translate_string("st_text_npc_giving_reward_" .. math.random(1,5))) or ""
end

function text_task_another_reward(a, b)
	return string.format(game.translate_string("st_text_task_no_money_" .. math.random(1,5))) or ""
end

-- Determine if actor has npc task:
function drx_sl_dont_has_npc_task( a, b )

	local npc = who_is_npc(a, b)
	local st = db.storage[npc:id()]
	if st then
		if st.ini and st.section_logic and (st.ini:r_string_ex(st.section_logic,"level_spot") == "mechanic") then
			npc:enable_trade()
		end
	end
	
	local se_obj = npc and alife( ):object( npc:id( ) )
	local giver_id = se_obj and (se_obj.group_id ~= 65535 and se_obj.group_id or se_obj.id)
	if not ( giver_id ) then
		return false
	end
	if ( alun_utils.load_var( db.actor, ("drx_sl_task_giver_" .. giver_id), 0 ) > 0 ) then
		return false
	end

	return true

end

-- Determine if actor is same faction as npc:
function drx_sl_actor_not_same_faction( a, b )

	-- Get npc faction:
	local npc = who_is_npc( a, b )
	local npc_faction = character_community( npc )
	local start, finish = string.find( npc_faction, "actor_" )
	if ( finish ) then
		npc_faction = string.sub( npc_faction, (finish + 1) )
	end

	-- Special check for Sidorovich:
	if ( npc_faction == "monster" ) then
		npc_faction = "stalker"
	end

	-- Get player faction:
	local actor_faction = character_community( db.actor )
	local start, finish = string.find( actor_faction, "actor_" )
	if ( finish ) then
		actor_faction = string.sub( actor_faction, (finish + 1) )
	end

	-- Check if factions are same:
	if ( actor_faction == npc_faction ) then
		return false
	else
		return true
	end

end

-- Determine if actor has completed current storyline task:
function drx_sl_actor_has_finished_task( a, b )

	local npc = who_is_npc( a, b )

	local task = axr_task_manager and axr_task_manager.drx_sl_get_finished_task( npc )
	if ( task == nil ) then
		return false
	end

	return true

end

-- Determine if actor has completed change factions task:
function drx_sl_actor_has_finished_cf_task( a, b )

	local npc = who_is_npc( a, b )

	local task = axr_task_manager and axr_task_manager.drx_sl_get_finished_cf_task( npc )
	if ( task == nil ) then
		return false
	end

	return true

end

-- Determine if end game task has been reached or should be given:
function drx_sl_is_endgame(a, b)

	if ( (alun_utils.load_var( db.actor, "drx_sl_current_task_number", 1 ) >= alun_utils.load_var( db.actor, "drx_sl_total_task_number", 1 )) and (has_alife_info( "bar_deactivate_radar_done" )) ) then
		return true
	end

	return false

end

-- Determine if end game task has been reached or should be given:
function drx_sl_is_not_endgame(a, b)
	return not drx_sl_is_endgame()
end

-- Initiate storyline task:
function drx_sl_text_honcho_has_storyline_task_to_give(a, b)

	local npc = who_is_npc( a, b )
	local task_section = axr_task_manager and axr_task_manager.drx_sl_generate_random_sl_task( npc )
	last_task_id = task_section
	dialogs.text_common_task(a, b)
	return game.translate_string( (task_section and axr_task_manager.get_task_job_description( task_section )) or ("st_no_available_task_" .. math.random(1,5)))
end

-- Initiate mechanic task:
function drx_sl_text_mechanic_has_ordered_task_to_give(a, b)

	local npc = who_is_npc( a, b )
	local task_section = axr_task_manager and axr_task_manager.drx_sl_get_mechanic_task(npc)
	last_task_id = task_section
	return game.translate_string( task_section and axr_task_manager.get_task_job_description(task_section) or ("st_no_available_task_" .. math.random(1,5)))
end

-- Initiate a change factions task:
function drx_sl_text_npc_has_change_factions_task_to_give( a, b )

	local npc = who_is_npc( a, b )
	local task_section = axr_task_manager and axr_task_manager.drx_sl_generate_change_factions_task( npc )
	last_task_id = task_section
	return game.translate_string( task_section and axr_task_manager.get_task_job_description( task_section ) or ("st_no_available_task_" .. math.random(1,5)))
end

-- Fetch storyline task text:
function drx_sl_text_fetch_task(a, b)
	local npc = who_is_npc(a, b)
	local id = npc:id()
	
	if not n[id] then
		n[id] = math.random(1,3)
	end
	
	axr_task_manager.trigger_fetch_func(last_task_id)
	local text = game.translate_string(dialogs.last_task_id .. "_fetch_about_" .. n[id])
	if (text == (dialogs.last_task_id .. "_fetch_about_" .. n[id])) then
		text = game.translate_string(dialogs.last_task_id .. "_fetch_about")
	end
	text =  text:gsub("{item_count}", _FETCH_AMOUNT or "")
				:gsub("{item_name}", _FETCH_TEXT or "")
	return text
end

function text_st_accepted_task_task(a, b)
	return string.format(game.translate_string("st_accepted_task_" .. math.random(1,5))) or ""
end

function text_common_task(a, b)
	local npc = who_is_npc( a, b )
	last_task_npc = npc
	
	local func = task_manager.task_ini:r_string_to_condlist(last_task_id,"on_init")
	local type = tostring(task_manager.task_ini:r_string_ex(last_task_id,"type"))
	local text = game.translate_string("st_task_placement_nothing_" .. math.random(1,5))
	if type == "bounty" then
		xr_logic.pick_section_from_condlist(db.actor,db.actor,func)
		local id = axr_task_manager.bounties_by_id[last_task_id]
		if not id then
			printf("Invalid id for bounty dialog")
			return
		end
		local obj = alife():object(id)
		if not obj then
			printf("Invalid obj for bounty dialog")
			return
		end
		local loc = tostring(alife():level_name(game_graph():vertex(obj.m_game_vertex_id):level_id()))
		local location = game.translate_string(loc)
		local reward_info = dialogs.collect_reward_cost(last_task_id)
		local reward = reward_info[1]
		reward = math.ceil(reward/1000)*1000
		text = game.translate_string("st_task_placement_" .. math.random(1,5)) .. location .. ". " 
			.. game.translate_string("st_task_reward_" .. math.random(1,5)) .. reward .. " UAH. " 
			.. game.translate_string("st_task_placement_no_more_" .. math.random(1,5))
	elseif type == "smart_hostage" then
		local par_table = {}
		table.insert(par_table, func[1][3][1][3][3])
		for i=6, #func[1][3][1][3] do
			table.insert(par_table, func[1][3][1][3][i])
		end
		xr_effects.find_smart_under_faction_control_ex(db.actor, npc, par_table)
		local id = alun_utils.load_var(db.actor,last_task_id .. "_id")
		if not id then
			printf("Invalid id for hostage dialog")
			return
		end
		local obj = alife():object(id)
		local loc = tostring(alife():level_name(game_graph():vertex(obj.m_game_vertex_id):level_id()))
		local location = game.translate_string(loc)
		local reward_info = dialogs.collect_reward_cost(last_task_id)
		local reward = reward_info[1]
		reward = math.ceil(reward/1000)*1000
		text = game.translate_string("st_task_placement_" .. math.random(1,5)) .. location .. ". " 
			.. game.translate_string("st_task_reward_" .. math.random(1,5)) .. reward .. " UAH. " 
			.. game.translate_string("st_task_placement_no_more_" .. math.random(1,5))
	elseif type == "assault" then
		xr_logic.pick_section_from_condlist(db.actor,db.actor,func)
		local id = alun_utils.load_var(db.actor,last_task_id .. "_id")
		if not id then 
			printf("Invalid id [%s] for assault dialog", id) 
			return
		end
		local obj = alife():object(id)
		local loc = tostring(alife():level_name(game_graph():vertex(obj.m_game_vertex_id):level_id()))
		local location = game.translate_string(loc)
		local reward_info = dialogs.collect_reward_cost(last_task_id)
		local reward = reward_info[1]
		reward = math.ceil(reward/1000)*1000
		text = game.translate_string("st_task_placement_" .. math.random(1,5)) .. location .. ". " 
			.. game.translate_string("st_task_reward_" .. math.random(1,5)) .. reward .. " UAH. " 
			.. game.translate_string("st_task_placement_no_more_" .. math.random(1,5))
	elseif type == "debt" then
		xr_logic.pick_section_from_condlist(db.actor,npc,func)
		local id = alun_utils.load_var(db.actor, last_task_id)
		if not id then return "No id in dialogs.text_common_task" end
		local obj = alife():object(id)
		if not obj then return "No obj in dialogs.text_common_task" end
		local loc = tostring(alife():level_name(game_graph():vertex(obj.m_game_vertex_id):level_id()))
		local location = game.translate_string(loc)
		local rank = obj:rank()
		local amount = (math.ceil((rank*1.5)/100))*100
		if (rank <= 1000) then
			amount = (math.ceil(math.random(700,1000)/100))*100*1.5
		end
		alun_utils.save_var(db.actor, id .. "_debt_amount", amount)
		local reward_info = dialogs.collect_reward_cost(last_task_id)
		local reward = reward_info[1]
		reward = math.ceil(reward/1000)*1000
		text = game.translate_string("st_task_placement_" .. math.random(1,5)) .. location .. ". " 
			.. game.translate_string("st_task_money_" .. math.random(1,5)) .. amount .. ". " 
			.. game.translate_string("st_task_reward_" .. math.random(1,5)) .. reward .. " " 
			.. game.translate_string("st_task_money_no_more_" .. math.random(1,5))
	elseif type == "package" then
		--xr_logic.pick_section_from_condlist(db.actor,npc,func)
		local par_table = {}
		table.insert(par_table, func[1][3][1][3][1])
		xr_effects.setup_debt_task(db.actor, npc, par_table)
		local id = alun_utils.load_var(db.actor, last_task_id)
		printf("text common task %s", id)
		if not id then return "No id in dialogs.text_common_task" end
		local obj = alife():object(id)
		if not obj then return "No obj in dialogs.text_common_task" end
		local loc = tostring(alife():level_name(game_graph():vertex(obj.m_game_vertex_id):level_id()))
		local location = game.translate_string(loc)
		local sec_num = xr_effects.set_package_item(id)
		local reward_info = dialogs.collect_reward_cost(last_task_id)
		local reward = reward_info[1]
		reward = math.ceil((reward + 1)/1000)*1000
		local str
		if sec_num[2] > 4 then
			str = game.translate_string("st_five_pieces")
		elseif sec_num[2] > 1 then
			str = game.translate_string("st_two_four_pieces")
		elseif sec_num[2] == 1 then
			str = game.translate_string("st_one_piece")
		end
		text = game.translate_string(sec_num[1]) 
			.. game.translate_string("st_task_item_" .. math.random(1,5)) .. tostring(sec_num[2]) .. str 
			.. game.translate_string("st_task_weight_" .. math.random(1,5)) .. sec_num[3] .. game.translate_string("st_kg")
			.. game.translate_string("st_task_volume_" .. math.random(1,5)) .. sec_num[4] .. game.translate_string("st_litre") .. ". " 
			.. game.translate_string("st_task_placement_" .. math.random(1,5)) .. location .. ". " 
			.. game.translate_string("st_task_reward_" .. math.random(1,5)) .. reward .. " " 
			.. game.translate_string("st_task_money_no_more_" .. math.random(1,5))
	end
	return string.format(text) or "Here is your text!"
end

-- End of storyline task text:
function drx_sl_text_task_finish( a, b )

	local npc = who_is_npc( a, b )

	local task_section = axr_task_manager and axr_task_manager.drx_sl_get_finished_task( npc )
	return game.translate_string( task_section and axr_task_manager.get_task_complete_text( task_section ) or ("st_default_task_finished_" .. math.random( 1, 3 )) )

end

-- End of change factions task text:
function drx_sl_text_cf_task_finish( a, b )

	local npc = who_is_npc( a, b )

	local task_section = axr_task_manager and axr_task_manager.drx_sl_get_finished_cf_task( npc )
	return game.translate_string( task_section and axr_task_manager.get_task_complete_text( task_section ) or ("st_default_task_finished_" .. math.random( 1, 3 )) )

end

-- End of game text:
function drx_sl_text_end_game(a, b)

	local npc = who_is_npc(a, b)

	local text_list = {}
	local i = 1
	while (true) do
		local text_id = (alun_utils.load_var(db.actor, "drx_sl_start_task", "") .. "_endgame_" .. i)
		local end_game_text = game.translate_string( text_id )
		if (end_game_text and end_game_text ~= "" and end_game_text ~= ("_endgame_" .. i) and end_game_text ~= text_id) then
			table.insert(text_list, end_game_text)
		else
			break
		end
		i = (i + 1)
	end

	if (#text_list < 1) then
		return game.translate_string("drx_sl_default_endgame")
	end

	return text_list[math.random(1, #text_list)]

end

-- Set current storyline task to complete:
function drx_sl_set_finished_task_complete(a, b)

	-- Set current task to complete:
	local npc = who_is_npc( a, b )
	axr_task_manager.drx_sl_set_finished_task_complete(npc)

	-- Give actor meet next honcho task:
	xr_effects.drx_sl_meet_random_honcho()

end

-- Set current storyline task to complete:
function drx_sl_set_finished_task_complete_endgame(a, b)

	-- Set current task to complete:
	local npc = who_is_npc( a, b )
	axr_task_manager.drx_sl_set_finished_task_complete(npc)

	-- Give actor end game task:
	xr_effects.drx_sl_find_wish_granter()

end

-- Set current change faction task to complete:
function drx_sl_set_finished_cf_task_complete(a, b)

	-- Set current task to complete:
	local npc = who_is_npc(a, b)
	axr_task_manager.drx_sl_set_finished_cf_task_complete(npc)

end

-- Determine whether or not a npc has an available task:
function npc_has_ordered_task_to_give(a, b)

	return last_task_id ~= nil or false

end

-- Text to display when a npc has a task to give:
function text_npc_has_ordered_task_to_give(a, b)
	local npc = who_is_npc(a, b)
	local id = npc:id()
	local task_section = axr_task_manager.available_tasks[id] and axr_task_manager.available_tasks[id][math.random(1,#axr_task_manager.available_tasks[id])]
	last_task_id = task_section
	
	if not n[id] then
		n[id] = math.random(1,3)
	end
	
	if alun_utils.load_var(db.actor,("area_tasks_skipped_" .. id),false) then
		return game.translate_string("st_skipped_tasks_" .. math.random(1,5))
	end
	
	if (task_section == nil) then
		return game.translate_string("st_no_available_task_" .. math.random(1,5))
	else
		local text = game.translate_string(task_section .. "_about_" .. n[id])
		if (text == (task_section .. "_about_" .. n[id])) then
			return game.translate_string(task_section .. "_about")
		else
			return game.translate_string(task_section .. "_about_" .. n[id])
		end
	end
end

-- Text to display when a npc has a simulation task to give:
function text_sim_npc_has_ordered_task_to_give( a, b )
	local npc = who_is_npc( a, b )
	local id = npc:id()
	local task_section = axr_task_manager.available_tasks[id] and axr_task_manager.available_tasks[id][math.random(1,#axr_task_manager.available_tasks[id])]
	last_task_id = task_section
	
	if not n[id] then
		n[id] = math.random(1,3)
	end
	
	if alun_utils.load_var(db.actor,("area_tasks_skipped_" .. id),false) then
		return game.translate_string("st_skipped_tasks_" .. math.random(1,5))
	end
	
	if (task_section == nil) then
		return game.translate_string("st_no_available_task_" .. math.random(1,5))
	else
		local text = game.translate_string(task_section .. "_about_" .. n[id])
		if (text == (task_section .. "_about_" .. n[id])) then
			return game.translate_string(task_section .. "_about")
		else
			return game.translate_string(task_section .. "_about_" .. n[id])
		end
	end
end

-- Text to display when a task is finished:
function text_task_finish(a, b)

	local npc = who_is_npc(a, b)
	local task_section = axr_task_manager and axr_task_manager.get_first_finished_task(npc)
	return game.translate_string( task_section and axr_task_manager.get_task_complete_text(task_section) or "st_default_task_finished_" .. math.random(1, 3))

end

-- Text to display when a simulation task is finished:
function text_sim_task_finish(a, b)

	local npc = who_is_npc(a, b)
	local task_section = axr_task_manager and axr_task_manager.get_first_finished_task(npc, true)
	return game.translate_string( task_section and axr_task_manager.get_task_complete_text(task_section) or "st_default_task_finished_" .. math.random(1, 3))

end

-- Determine whether or not the task is a fetch task:
function task_is_fetch_task(a, b)

	local npc = who_is_npc(a, b)
	local task_id = last_task_id  --axr_task_manager.get_first_available_task(npc)
	if not (task_id) then
		return false
	end
	return axr_task_manager.get_fetch_task_description(task_id) ~= nil

end

-- Determine whether or not the task is a fetch task:
function not_task_is_fetch_task(a, b)
	return not task_is_fetch_task(a, b)
end

-- Clear skipped tasks:
function npc_clear_skipped_tasks(a, b)
	if (axr_task_manager) then
		axr_task_manager.clear_skipped_tasks()
	end
end

-- Check if actor has finished task:
function actor_has_finished_ordered_task(a, b)
	local npc = who_is_npc(a, b)
	local tsk = axr_task_manager and axr_task_manager.get_first_finished_task(npc)
	if (tsk == nil) then
		return false
	end
	return true
end

-- Check if actor has finished task:
function actor_has_not_finished_ordered_task(a, b)
	return not actor_has_finished_ordered_task(a, b)
end

-- Check if actor has finished task:
function actor_sim_has_finished_ordered_task(a, b)
	local npc = who_is_npc(a, b)
	return axr_task_manager and axr_task_manager.get_first_finished_task( npc, true ) ~= nil or false
end

-- Check if actor has finished task:
function actor_sim_has_not_finished_ordered_task(a, b)
	return not actor_sim_has_finished_ordered_task(a, b)
end

-- Set current simulation task to complete:
function npc_sim_set_finished_task_complete(a, b)
	local npc = who_is_npc( a, b )
	axr_task_manager.set_finished_task_complete(npc, true)
end

-- Give player storyline task:
function drx_sl_give_sl_task(a, b)

	disable_info( ("drx_sl_meet_honcho_" .. alun_utils.load_var( db.actor, "drx_sl_current_honcho", "" )) )
	local npc = who_is_npc( a, b )
	local task_section = axr_task_manager and axr_task_manager.drx_sl_generate_random_sl_task( npc, nil, true )
	while last_task_id and task_section ~= nil and task_section ~= last_task_id do
		task_section = axr_task_manager.drx_sl_generate_random_sl_task( npc, true, true )
	end

	if ( last_task_id ) then
		printf( ("DRX SL storyline task started: " .. last_task_id) )
		local se_obj = npc and alife( ):object( npc:id( ) )
		local giver_id = se_obj and (se_obj.group_id ~= 65535 and se_obj.group_id or se_obj.id)
		alun_utils.save_var( db.actor, "drx_sl_current_task", last_task_id )
		task_manager.get_task_manager( ):give_task( last_task_id, giver_id )

		-- Register current task giver:
		if ( (not string.find( "meet_task", last_task_id )) and (not string.find( "find_wish_granter", last_task_id )) ) then
			local giver_task_count = (alun_utils.load_var( db.actor, ("drx_sl_task_giver_" .. giver_id), 0 ) + 1)
			alun_utils.save_var( db.actor, ("drx_sl_task_giver_" .. giver_id), giver_task_count )
			printf( ("DRX SL: drx_sl_task_giver_" .. giver_id .. " registered (" .. giver_task_count .. " outstanding)") )
		end

		last_task_id = nil

	end

end

-- Give player change factions task:
function drx_sl_give_cf_task( a, b )

	local npc = who_is_npc( a, b )
	local task_section = axr_task_manager and axr_task_manager.drx_sl_generate_change_factions_task( npc, nil, true )
	while last_task_id and task_section ~= nil and task_section ~= last_task_id do
		task_section = axr_task_manager.drx_sl_generate_change_factions_task( npc, true, true )
	end

	if ( last_task_id ) then
		printf( ("DRX SL change factions task started: " .. last_task_id) )
		local se_obj = npc and alife( ):object( npc:id( ) )
		local giver_id = se_obj and (se_obj.group_id ~= 65535 and se_obj.group_id or se_obj.id)
		task_manager.get_task_manager( ):give_task( last_task_id, giver_id )

		-- Register current task giver:
		local giver_task_count = (alun_utils.load_var( db.actor, ("drx_sl_task_giver_" .. giver_id), 0 ) + 1)
		alun_utils.save_var( db.actor, ("drx_sl_task_giver_" .. giver_id), giver_task_count )
		printf( ("DRX SL: drx_sl_task_giver_" .. giver_id .. " registered (" .. giver_task_count .. " outstanding)") )

		last_task_id = nil

	end

end

-- Give the player the current dynamic task:
function drx_sl_give_mechanic_task( a, b )

	local npc = who_is_npc( a, b )
	local task_section = axr_task_manager and axr_task_manager.drx_sl_get_mechanic_task( npc, nil, true )
	while last_task_id and task_section ~= nil and task_section ~= last_task_id do
		task_section = axr_task_manager.drx_sl_get_mechanic_task( npc, true, true )
	end

	if ( last_task_id ) then
		printf( ("DRX SL mechanic task started: " .. last_task_id) )
		local se_obj = npc and alife( ):object( npc:id( ) )
		local giver_id = se_obj and (se_obj.group_id ~= 65535 and se_obj.group_id or se_obj.id)
		task_manager.get_task_manager( ):give_task( last_task_id, giver_id )
		local giver_task_count = (alun_utils.load_var( db.actor, ("drx_sl_task_giver_" .. giver_id), 0 ) + 1)
		alun_utils.save_var( db.actor, ("drx_sl_task_giver_" .. giver_id), giver_task_count )
		printf( ("DRX SL: drx_sl_task_giver_" .. giver_id .. " registered (" .. giver_task_count .. " outstanding)") )
		last_task_id = nil
	end

end

-- Give the player the current dynamic task:
function npc_give_last_task_id(a, b)

	local npc = who_is_npc(a, b)
	--local task_section = axr_task_manager and axr_task_manager.get_first_available_task( npc, nil, true )
	--while last_task_id and task_section ~= nil and task_section ~= last_task_id do
	--	task_section = axr_task_manager.get_first_available_task( npc, true, true )
	--end

	if (last_task_id) then
		printf(("DRX SL dynamic task started: " .. last_task_id))
		local se_obj = npc and alife():object( npc:id())
		local giver_id = se_obj and (se_obj.group_id ~= 65535 and se_obj.group_id or se_obj.id)
		task_manager.get_task_manager():give_task(last_task_id, giver_id)
		local giver_task_count = (alun_utils.load_var( db.actor, ("drx_sl_task_giver_" .. giver_id), 0 ) + 1)
		alun_utils.save_var(db.actor, ("drx_sl_task_giver_" .. giver_id), giver_task_count)
		printf(("DRX SL: drx_sl_task_giver_" .. giver_id .. " registered (" .. giver_task_count .. " outstanding)"))
		last_task_id = nil
	end

end

-- Give the player the current simulation task:
function npc_sim_give_last_task_id(a, b)

	local npc = who_is_npc(a, b)
	--local task_section = axr_task_manager and axr_task_manager.get_first_available_task( npc, nil, true )
	--while last_task_id and task_section ~= nil and task_section ~= last_task_id do
	--	task_section = axr_task_manager.get_first_available_task( npc, true, true )
	--end

	if ( last_task_id ) then

		-- Give player task:
		printf(("DRX SL simulation task started: " .. last_task_id))
		local se_obj = npc and alife():object(npc:id())
		local giver_id = se_obj and (se_obj.group_id ~= 65535 and se_obj.group_id or se_obj.id)
		task_manager.get_task_manager():give_task(last_task_id, giver_id)
		last_task_id = nil

		-- Register task giver:
		local giver_task_count = (alun_utils.load_var( db.actor, ("drx_sl_task_giver_" .. giver_id), 0 ) + 1)
		alun_utils.save_var(db.actor, ("drx_sl_task_giver_" .. giver_id), giver_task_count)
		printf( ("DRX SL: drx_sl_task_giver_" .. giver_id .. " registered (" .. giver_task_count .. " outstanding)"))

		-- Register hostage task giver:
		if (alun_utils.load_var(db.actor, "drx_sl_hostage_giver_needed", false)) then
			alun_utils.save_var(db.actor, ("drx_sl_hostage_giver_" .. giver_id), true)
			alun_utils.save_var(db.actor, "drx_sl_hostage_giver_needed", false)
			printf(("DRX SL: drx_sl_hostage_giver_" .. giver_id .. " registered"))
		end

	end

end

-- Give the player the first available dynamic task:
function npc_give_first_available_task(a, b)

	if (axr_task_manager) then
		local npc = who_is_npc(a, b)
		local task_id = axr_task_manager.npc_give_first_available_ordered_task( npc )
		if ( not task_id ) then
			return
		end
		printf(("DRX SL dynamic task started: " .. task_id))
		local se_obj = npc and alife( ):object( npc:id())
		local giver_id = se_obj and (se_obj.group_id ~= 65535 and se_obj.group_id or se_obj.id)
		local giver_task_count = (alun_utils.load_var( db.actor, ("drx_sl_task_giver_" .. giver_id), 0 ) + 1)
		alun_utils.save_var( db.actor, ("drx_sl_task_giver_" .. giver_id), giver_task_count)
		printf(("DRX SL: drx_sl_task_giver_" .. giver_id .. " registered (" .. giver_task_count .. " outstanding)"))
	end

end

-- Give the player the first available simulation task:
function npc_sim_give_first_available_task( a, b )

	if ( axr_task_manager ) then
		local npc = who_is_npc( a, b )
		local task_id = axr_task_manager.npc_give_first_available_ordered_task( npc, true )
		if ( not task_id ) then
			return
		end
		printf( ("DRX SL simulation task started: " .. task_id))
		local se_obj = npc and alife():object(npc:id())
		local giver_id = se_obj and (se_obj.group_id ~= 65535 and se_obj.group_id or se_obj.id)
		local giver_task_count = (alun_utils.load_var( db.actor, ("drx_sl_task_giver_" .. giver_id), 0 ) + 1)
		alun_utils.save_var( db.actor, ("drx_sl_task_giver_" .. giver_id), giver_task_count )
		printf( ("DRX SL: drx_sl_task_giver_" .. giver_id .. " registered (" .. giver_task_count .. " outstanding)"))
	end

end

-- npcs and trade and repair
function npc_is_trader(a,b)
    local npc = who_is_npc(a, b)
	local hud = get_hud()
	if (hud) then
		hud:HideActorMenu()
		npc:start_trade(db.actor)
	end
end

function npc_is_tech(a,b)
    local npc = who_is_npc(a,b)
	local hud = get_hud()
	if (hud) then
		hud:HideActorMenu()
		npc:start_upgrade(db.actor)
	end
end

function rescue_hostage(a,b)
	a:stop_talk()
	b:stop_talk()
	local npc = who_is_npc(a,b)
	local squad = get_object_squad(npc)
	if (squad) then 
		for k in squad:squad_members() do
			utils.se_obj_save_var(k.id,k.object:name(),"companion_cannot_teleport",nil)
			axr_task_manager.hostages_by_id[k.id] = nil
		end
	else 
		local se_npc = alife_object(npc:id())
		if (se_npc) then
			utils.se_obj_save_var(se_npc.id,se_npc:name(),"companion_cannot_teleport",nil)
			axr_task_manager.hostages_by_id[se_npc.id] = nil
		end
	end
end

-- Dynamic Ordered Task dialog
-- AVAILABLE TASKS
function generate_available_tasks(a,b)
	local npc = who_is_npc(a, b)
	axr_task_manager.generate_available_tasks(npc,nil)
	--printf("generate_available_tasks %s",axr_task_manager.available_tasks[npc:id()] and #axr_task_manager.available_tasks[npc:id()])
end

function sim_generate_available_tasks(a,b)
	local npc = who_is_npc(a, b)
	axr_task_manager.generate_available_tasks(npc,true)
	--printf("sim_generate_available_tasks %s",axr_task_manager.available_tasks[npc:id()] and #axr_task_manager.available_tasks[npc:id()])
end

function npc_has_task(a,b)
	local npc = who_is_npc(a, b)
	--printf("npc_has_task %s",axr_task_manager.available_tasks[npc:id()] and axr_task_manager.available_tasks[npc:id()][1] ~= nil)
	return (axr_task_manager.available_tasks[npc:id()] and #axr_task_manager.available_tasks[npc:id()] > 0)
end

function npc_give_task(a,b)
	local npc = who_is_npc(a, b)
	local task_id = axr_task_manager.available_tasks[npc:id()] and axr_task_manager.available_tasks[npc:id()][1]
	if (task_id) then
        task_manager.get_task_manager():give_task(task_id,npc:id())
	end
	--printf("npc_give_task %s",task_id)
end

function npc_skip_task(a,b)
	local npc = who_is_npc(a, b)
	if (axr_task_manager.available_tasks[npc:id()]) then
		local number = 1
		for i=1, #axr_task_manager.available_tasks[npc:id()] do
			if axr_task_manager.available_tasks[npc:id()][i] == last_task_id then
				number = i
			end
		end
		table.remove(axr_task_manager.available_tasks[npc:id()], number)
	end
	if (axr_task_manager.available_tasks[npc:id()] and #axr_task_manager.available_tasks[npc:id()] < 1) then
		alun_utils.save_var(db.actor,("area_tasks_skipped_" .. npc:id()),true)
	end
	--printf("npc_skip_task %s",axr_task_manager.available_tasks[npc:id()] and #axr_task_manager.available_tasks[npc:id()])
end

-- FINISHED TASK TURN-IN DIALOG
function actor_has_finished_task(a,b)
	local npc = who_is_npc(a, b)

	axr_task_manager.generate_finished_tasks(npc,nil)

	--printf("actor_has_finished_task %s",axr_task_manager.finished_tasks[npc:id()] and axr_task_manager.finished_tasks[npc:id()][1] ~= nil)
	return axr_task_manager.finished_tasks[npc:id()] and axr_task_manager.finished_tasks[npc:id()][1] ~= nil
end

function sim_actor_has_finished_task(a,b)
	local npc = who_is_npc(a, b)

	axr_task_manager.generate_finished_tasks(npc,true)

	--printf("sim_actor_has_finished_task %s",axr_task_manager.finished_tasks[npc:id()] and axr_task_manager.finished_tasks[npc:id()][1] ~= nil)
	return axr_task_manager.finished_tasks[npc:id()] and axr_task_manager.finished_tasks[npc:id()][1] ~= nil
end

function text_npc_task_finish(a,b)
	local npc = who_is_npc(a, b)
	local task_id = axr_task_manager.finished_tasks[npc:id()] and axr_task_manager.finished_tasks[npc:id()][1]
	--printf("text_npc_task_finish %s",task_id)
	return game.translate_string(task_id and task_manager.task_ini:r_string_ex(task_id,"task_complete_descr") or "st_default_task_finished_"..math.random(1,3))
end

-- Set current dynamic task to complete:
function npc_set_finished_task_complete(a,b)
	local npc = who_is_npc(a, b)
	axr_task_manager.set_finished_task_complete(npc)
	-- local task_id = axr_task_manager.finished_tasks[npc:id()] and axr_task_manager.finished_tasks[npc:id()][1]
	-- if (task_id) then 
		-- task_manager.get_task_manager():set_task_completed(task_id)
	-- end
end

-- CANCEL TASKS

function actor_has_ongoing_task(a,b)
	local npc = who_is_npc(a, b)
	axr_task_manager.generate_ongoing_tasks(npc,nil)
	return axr_task_manager.ongoing_tasks[npc:id()] and axr_task_manager.ongoing_tasks[npc:id()][1] ~= nil
end

function sim_actor_has_ongoing_task(a,b)
	local npc = who_is_npc(a, b)
	axr_task_manager.generate_ongoing_tasks(npc,true)
	return axr_task_manager.ongoing_tasks[npc:id()] and axr_task_manager.ongoing_tasks[npc:id()][1] ~= nil
end

function text_npc_has_cancel_task(a,b)
	local npc = who_is_npc(a, b)
	local task_id = axr_task_manager.ongoing_tasks[npc:id()] and axr_task_manager.ongoing_tasks[npc:id()][1]
	--printf("text_npc_has_cancel_task %s",task_id)

	local text = task_id and game.translate_string(task_manager.task_ini:r_string_ex(task_id, "title"))
	if not (text) then
		return game.translate_string("st_task_none_active")
	end

	local fetch = task_id and task_manager.task_ini:r_string_ex(task_id,"fetch_descr")
	if (fetch) then
        local sec = utils.load_var(db.actor,task_id.."_fetch")
        if not (sec) then
            return text or game.translate_string("st_task_none_active")
        end
		local name = game.translate_string(INI:r_string_ex(sec,"inv_name") or "")
		return strformat(text,name or "")
	end

	return text
end

function npc_has_cancel_task(a,b)
	local npc = who_is_npc(a, b)
	--printf("npc_has_cancel_task %s",axr_task_manager.ongoing_tasks[npc:id()] and axr_task_manager.ongoing_tasks[npc:id()][1] ~= nil)
	return axr_task_manager.ongoing_tasks[npc:id()] and axr_task_manager.ongoing_tasks[npc:id()][1] ~= nil
end

function npc_cancel_task(a,b)
	local npc = who_is_npc(a, b)
	local task_id = axr_task_manager.ongoing_tasks[npc:id()] and axr_task_manager.ongoing_tasks[npc:id()][1]
	if (task_id) then
        task_manager.get_task_manager():set_task_cancelled(task_id)
	end
	--printf("npc_cancel_task %s",task_id)
end

function npc_skip_cancel_task(a,b)
	local npc = who_is_npc(a, b)
	if (axr_task_manager.ongoing_tasks[npc:id()]) then
		table.remove(axr_task_manager.ongoing_tasks[npc:id()],1)
	end
	--printf("npc_skip_cancel_task %s",axr_task_manager.ongoing_tasks[npc:id()] and #axr_task_manager.ongoing_tasks[npc:id()])
end

function text_actor_cancel_task(a,b)
    local npc = who_is_npc(a, b)
	local task_id = axr_task_manager.ongoing_tasks[npc:id()] and axr_task_manager.ongoing_tasks[npc:id()][1]
    return game.translate_string(task_id and task_manager.task_ini:r_string_ex(task_id, "abandoned_reason") or "st_task_default_excuse_cancel_job")
end

function text_task_cancel(a,b)
    local npc = who_is_npc(a, b)
    local task_id = axr_task_manager.ongoing_tasks[npc:id()] and axr_task_manager.ongoing_tasks[npc:id()][1]
    return game.translate_string(task_id and task_manager.task_ini:r_string_ex(task_id, "abandoned_reply") or "st_default_task_cancel_"..math.random(1,3))
end

-- This function allows Player to see NPC inventory as if it was a corpse
function free_trade_with_npc(a,b)
	local npc = who_is_npc(a, b)
	local se_obj = npc and alife_object(npc:id())
	if (se_obj) then
		get_hud():HideActorMenu()
		if not (utils.se_obj_load_var(se_obj.id,se_obj:name(),"companion_cannot_dismiss")) then
			if (db.actor:position():distance_to_sqr(se_obj.position) <= 625) then
				npc:use(db.actor)
			else 
				SetHudMsg(game.translate_string("st_pda_cant_trade_dist"),3)
			end
		else 
			SetHudMsg(game.translate_string("st_pda_cant_trade"),3)
		end
	end
end

-- Determine if actor has valuable item:
function condition_actor_has_valuable_item(a,b)

	local story_done = has_alife_info( "warlab_deactivate_generators_done" )

	local items = {
		["device_pda_common"] = true,
		["device_pda_uncommon"] = true,
		["device_pda_rare"] = true,
		["main_story_1_quest_case"] = story_done,
		["main_story_2_lab_x18_documents"] = story_done,
		["main_story_3_lab_x16_documents"] = story_done,
		["main_story_4_lab_x10_documents"] = story_done,
		["main_story_5_lab_x8_documents"] = story_done,
		["main_story_6_jup_ug_documents"] = story_done,
		["main_story_7_mon_con_documents"] = story_done
	}

	for k,v in pairs(items) do
		if (v == true and db.actor:object(k)) then
			return true
		end
	end

	return false

end

-- Text for if the player has an item that can be brokered:
function text_actor_has_valuable_item(a,b)
	local npc = who_is_npc(a, b)

	local story_done = has_alife_info( "warlab_deactivate_generators_done" )

	local valuable = {
		["main_story_1_quest_case"] = story_done,
		["main_story_2_lab_x18_documents"] = story_done,
		["main_story_3_lab_x16_documents"] = story_done,
		["main_story_4_lab_x10_documents"] = story_done,
		["main_story_5_lab_x8_documents"] = story_done,
		["main_story_6_jup_ug_documents"] = story_done,
		["main_story_7_mon_con_documents"] = story_done
	}

	for k,v in pairs(valuable) do 
		if (v == true and db.actor:object(k)) then 
			return game.translate_string("st_broker_query_valuable")
		end
	end

	local count = 0
	local function itr(actor,itm)
		local sec = itm:section()
		local con = itm:condition()
		local ai = db.actor:active_item()
		if ((sec and not ai) and sec == "device_pda_common" or sec == "device_pda_uncommon" or sec == "device_pda_rare" and con > 0.1) then
			count = count + 1
		end
	end

	db.actor:iterate_inventory(itr,db.actor)

	if (count == 1) then
		return game.translate_string("st_broker_query_pda")
	end
	return strformat(game.translate_string("st_broker_query_pdas"),count) or game.translate_string("st_broker_query_pda")
end

-- Text for trading PDA:
function text_trade_npc_pda(a,b)
    local npc = who_is_npc(a, b)

	local story_done = has_alife_info("warlab_deactivate_generators_done") or false
	--local story_done = has_alife_info( "warlab_deactivate_generators_done" )

	local valuable = {
		["main_story_1_quest_case"] = story_done,
		["main_story_2_lab_x18_documents"] = story_done,
		["main_story_3_lab_x16_documents"] = story_done,
		["main_story_4_lab_x10_documents"] = story_done,
		["main_story_5_lab_x8_documents"] = story_done,
		["main_story_6_jup_ug_documents"] = story_done,
		["main_story_7_mon_con_documents"] = story_done
	}

	for k,v in pairs(valuable) do
		local item = v == true and db.actor:object(k)
		if (item) then
			db.actor:transfer_item(item,npc)
			news_manager.relocate_item(db.actor, "out", item:section())
			xr_effects.reward_random_money(actor, npc, {10000, 15000})
			local name = game.translate_string(INI:r_string_ex(item:section(),"inv_name") or "")
			return strformat(game.translate_string("st_broker_trade_valuable"),name)
		end
	end

    local tbl = { common = 0, uncommon = 0, rare = 0}
    local function itr(actor,itm)
        if itm:condition() <= 0.1 then return end
		local chk, pda_t = itm:section():match("(device_pda_)([%l]+)")
        if chk and tbl[pda_t] then
			tbl[pda_t] = tbl[pda_t] + 1
            actor:transfer_item(itm,npc)
            dxr_statistics.increment_statistic("pdas_delivered")
        end
    end
    db.actor:iterate_inventory(itr,db.actor)

    local npc_text = ""

    local total_value = 0
    local pda_bonus_coords = 0

    local first_line
    for j,count in pairs(tbl) do
        if (count > 0) then
		    local mul = j == "common" and 1.3 or j == "uncommon" and 1.5 or j == "rare" and 1.8
			local mul2 = j == "common" and 0.5 or j == "uncommon" and 5 or j == "rare" and 10

            news_manager.relocate_item(db.actor, "out", "device_pda_"..j, count)

            for i=1, count do
                total_value = total_value + (mul * math.random(2000,2200))

                if (math.random(1,100) <= mul2) then
                    pda_bonus_coords = pda_bonus_coords + 1
                end
            end

            if (count == 1) then
                npc_text = game.translate_string("st_broker_npc_about_pda_"..j.."_"..math.random(1,20))
                first_line = true
            elseif (count > 1) then
                for i=1,math.random(count) do
                    if not (first_line) then
                        first_line = true
                        npc_text = game.translate_string("st_broker_npc_about_pda_"..j.."_"..math.random(1,20))
                    else
                        npc_text = (npc_text .. " " .. game.translate_string("st_drx_questlines_and_this_one") .. " " .. game.translate_string( ("st_broker_npc_about_pda_" .. j .. "_" .. math.random( 1, 20 )) ))
                    end
                end
            end
        end
    end

    if (dxr_achievements.has_achievement("infopreneur")) then
        total_value = total_value + math.floor(total_value / 20)
    end

	-- Round off value:
	total_value = math.ceil((total_value / 50))
	total_value = (total_value * 50)

	xr_effects.reward_random_money(actor, npc, {total_value, total_value})

	-- Add ending text:
	npc_text = (npc_text .. " " .. game.translate_string( "st_drx_broker_finish_" .. math.random( 1, 3 )))

    if (pda_bonus_coords > 0 and coc_treasure_manager) then
        npc_text = npc_text .. "\n\n " .. game.translate_string("st_broker_npc_about_pda_bonus_coords")

        for i=1,pda_bonus_coords do
            coc_treasure_manager.reveal_random_stash("treasure","st_broker_reward")
        end
    end

    return npc_text
end

-- Dynamic Surrender dialog
function victim_is_bounty(a,b)
	local npc = who_is_npc(a, b)
	local id = npc:id()
	for task_id,npc_id in pairs(axr_task_manager.bounties_by_id) do
		if (id == npc_id) then
			return true
		end
	end
	return false
end

function npc_is_surrendered(a,b)
	local npc = who_is_npc(a, b)
	local st = db.storage[npc:id()]
	local po = st and st.victim_surrender and st.victim_surrender < 65534 and level.object_by_id(st.victim_surrender)
	--printf("npc_is_surrendered: surrendered to %s",st.victim_surrender)
	if (po) then
		return true
	end
	return false
end

function npc_is_not_surrendered(a,b)
	local npc = who_is_npc(a, b)
	local st = db.storage[npc:id()]
	local po = st and st.victim_surrender and st.victim_surrender < 65534 and level.object_by_id(st.victim_surrender)
	if not (po) then
		return false
	end
	return true
end

function victim_surrender(a,b)
	local npc = dialogs.who_is_npc(a,b)
	return utils.load_var(npc,"victim_surrender",false) == true
end

function victim_no_surrender(a,b)
	local npc = dialogs.who_is_npc(a,b)
	return utils.load_var(npc,"victim_surrender",false) == false
end

function set_victim_surrendered(a,b)
	local npc = dialogs.who_is_npc(a,b)
	utils.save_var(npc,"victim_surrender",true)
end

function surrender_victim_answers_bounty(a,b)
	local npc = dialogs.who_is_npc(a,b)
	local id = npc:id()

	local prefix = "default"
	for task_id,npc_id in pairs(axr_task_manager.bounties_by_id) do
		if (npc_id == id) then
			if (task_id == "esc_m_trader_task_2") then
				prefix = "esc_m_trader"
			elseif (task_id == "zat_b7_bandit_boss_sultan_task_1") then
				prefix = "zat_b7_bandit_boss_sultan"
			end
		end
	end

	local r = math.random(1,10)
	local sur -- check if surrendered
	if (r >= 1) and (r <= 9) then -- surrender here (1 to 9 will just returned dialog)
		set_victim_surrendered(a,b) 
		sur = true
	end
	if (r == 1 or r == 2) then
		r = (math.random(1,100)/100)
		local sec = "device_pda_common"
		if (r <= 0.10) then
			sec = "device_pda_rare"
		elseif (r <= 0.5) then
			sec = "device_pda_uncommon"
		end
		relocate_item_section_to_actor(a, b, sec, 1)
		relocate_money_to_actor(a,b,math.random(500,6000))
		return game.translate_string("st_surrender_victim_answer_"..prefix.."_bounty_1")
	elseif (r == 3 or r == 4) then
		return game.translate_string("st_surrender_victim_answer_"..prefix.."_bounty_2")
	elseif (r == 5) then
		return game.translate_string("st_surrender_victim_answer_"..prefix.."_bounty_3")
	elseif (r == 6 or r == 7) then
		return game.translate_string("st_surrender_victim_answer_"..prefix.."_bounty_4")
	elseif (r == 8 or r == 9) then
		return game.translate_string("st_surrender_victim_answer_"..prefix.."_bounty_5")
	end

	if ((math.random(1,100)/100) < 0.5) then -- you can't force npc to surrender here, this is for healing.
		alife():create("medkit_script",npc:position(),0,0,npc:id())
		xr_wounded.unlock_medkit(npc)
	else
		if (not sur) then
			set_victim_surrendered(a,b) 
		end
	end

	return game.translate_string("st_surrender_victim_answer_5")
end

function surrender_victim_answers_1(a,b)
	local npc = dialogs.who_is_npc(a,b)

	local r = math.random(1,5)
	
	if (db.storage[npc:id()].items_to_actor) then
		set_victim_surrendered(a,b)
		return game.translate_string("st_surrender_victim_answer_5")
	end

	if (coc_treasure_manager) and (r <= 2) then

		local function itr(npc,itm)
			if (IsWeapon(itm)) then
				local condition = ((math.random(30) + 20) / 100)
				itm:set_condition(condition)
				npc:transfer_item(itm,db.actor)
			end
		end

		npc:iterate_inventory(itr,npc)
		db.storage[npc:id()].items_to_actor = true

		if (coc_treasure_manager) then
			coc_treasure_manager.reveal_random_stash("treasure", strformat(game.translate_string("st_itm_stash_of_character"),npc:character_name()) )
			if (dxr_achievements.has_achievement("silver_or_lead") and ((math.random(1,100)/100) <= 0.33)) then
				coc_treasure_manager.reveal_random_stash("treasure",strformat(game.translate_string("st_itm_stash_of_character"),npc:character_name()))
			end
		end
		
		set_victim_surrendered(a,b)
		if (coc_treasure_manager and coc_treasure_manager.last_secret) then
			return game.translate_string("st_surrender_victim_answer_"..math.random(3))
		else
			return game.translate_string("st_surrender_victim_answer_5")
		end
	elseif (r == 3) then
		r = (math.random(1,100)/100)
		local sec = "device_pda_common"
		if (r <= 0.10) then
			sec = "device_pda_rare"
		elseif (r <= 0.5) then
			sec = "device_pda_uncommon"
		end
		relocate_item_section_to_actor(a, b, sec, 1)
		set_victim_surrendered(a,b)
		return game.translate_string("st_surrender_victim_answer_4")
	elseif (r == 5) then -- you can't force npc to surrender here, this is for healing then attacking the player
		alife():create("medkit_script",npc:position(),0,0,npc:id())
		xr_wounded.unlock_medkit(npc)
		return game.translate_string("st_surrender_victim_answer_5")
	end
	set_victim_surrendered(a,b)
	return game.translate_string("st_surrender_victim_answer_5")
end

function surrender_victim_answers_2(a,b)
	local npc = dialogs.who_is_npc(a,b)
	alife():create("medkit_script",npc:position(),0,0,npc:id())
	xr_wounded.unlock_medkit(npc)
	--npc:set_relation(game_object.enemy,db.actor)
	local function itr(npc,itm)
		if (IsWeapon(itm)) then
			local condition = ((math.random(30) + 25) / 100)
			itm:set_condition(condition)
			npc:transfer_item(itm,db.actor)
		end
	end

	npc:iterate_inventory(itr,npc)

	--if (math.random() <= 0.8) then
		--npc:set_relation(game_object.neutral,db.actor)
	--end

	db.storage[npc:id()].panicked_to_actor = true

	set_victim_surrendered(a,b)
	return game.translate_string("st_surrender_victim_answer_6")
end

function set_enemy(a,b)
	local npc = dialogs.who_is_npc(a,b)
	npc:set_relation(game_object.enemy,db.actor)
end
--End Alundaio
function is_npc_in_current_smart(first_speaker, second_speaker, smart_name)
	local npc = who_is_npc(first_speaker, second_speaker)
	local smart = xr_gulag.get_npc_smart(npc)
	if not smart then return false end
	return smart:name() == smart_name
end

function break_dialog(first_speaker, second_speaker, id)
	first_speaker:stop_talk()
	second_speaker:stop_talk()
end

function update_npc_dialog(first_speaker, second_speaker)
	local npc = who_is_npc(first_speaker, second_speaker)
	local st = db.storage[npc:id()]
	st.meet.meet_manager:update()
	xr_meet.process_npc_usability(npc)
	--xr_motivator.update_logic(npc)
	xr_logic.try_switch_to_another_section(npc, st[st.active_scheme], db.actor)
end

function disable_talk_self(first_speaker, second_speaker)
	first_speaker:disable_talk()
end
function disable_talk_victim(first_speaker, second_speaker)
	second_speaker:disable_talk()
end

function punch(first_speaker, second_speaker)
	--printf("KICK ASS !!!!")
	--xr_punch.punch[first_speaker:id()] = second_speaker
	db.storage[second_speaker:id()].punch.enabled = true
end

function get_money_then_leave(first_speaker, second_speaker)
	db.storage[first_speaker:id()].meet.enabled = false
	db.storage[first_speaker:id()].robber.enabled = true
end

function is_wounded(first_speaker, second_speaker)
--	if db.storage[first_speaker:id()].wounded ~= nil and
--		 db.storage[first_speaker:id()].wounded.wound_manager.can_use_medkit == true
--	then
--		return false
--	end
	local npc = who_is_npc(first_speaker, second_speaker)
	return xr_wounded.is_wounded(npc)
end
--[[
function is_opp_wounded(first_speaker, second_speaker, dialog_id)
		if db.storage[second_speaker:id()].wounded ~= nil and
			 db.storage[second_speaker:id()].wounded.wound_manager.can_use_medkit == true
		then
				return false
		end
	return	xr_wounded.is_wounded(second_speaker)
end
]]--
function is_not_wounded(first_speaker, second_speaker, dn)
	return not is_wounded(first_speaker, second_speaker)
end

function is_psy_wounded(first_speaker, second_speaker)
	local npc = who_is_npc(first_speaker, second_speaker)
	return xr_wounded.is_psy_wounded(npc)
end

function not_is_psy_wounded(first_speaker, second_speaker)
	local npc = who_is_npc(first_speaker, second_speaker)
	return not xr_wounded.is_psy_wounded(npc)
end

function actor_have_medkit(first_speaker, second_speaker)
	local med = {"medkit","medkit_army","medkit_scientic","medkit_elite","medkit_radiated","medkit_army_radiated","medkit_scientic_radiated","medkit_elite_radiated"}
	for k,v in pairs(med) do
		if (first_speaker:object(v)) then
			return true
		end
	end
	return false
end
function actor_hasnt_medkit(first_speaker, second_speaker)
	return actor_have_medkit(first_speaker, second_speaker) == false
end
function actor_have_bandage(first_speaker, second_speaker)
	return first_speaker:object("bandage") ~= nil
end
function transfer_medkit(first_speaker, second_speaker)
	local npc = who_is_npc(first_speaker, second_speaker)

	xr_wounded.unlock_medkit(npc)

	if not (npc:object("medkit_script")) then
		alife():create("medkit_script", npc:position(), npc:level_vertex_id(), npc:game_vertex_id(), npc:id())
	end

	local t = {"medkit","medkit_army","medkit_scientic","medkit_elite","medkit_radiated","medkit_army_radiated","medkit_scientic_radiated","medkit_elite_radiated"}
	for i=1,#t do
		if (db.actor:object(t[i])) then
			dialogs.relocate_item_section(npc,t[i],"out")
			break
		end
	end

	if (npc:relation(db.actor) >= game_object.enemy) then
		npc:set_relation(game_object.neutral,db.actor)
	else
		npc:set_relation(game_object.friend,db.actor)
	end

	dxr_statistics.increment_statistic("wounded_helped")
end

function give_medkit_no_transfer(a,b)
	local npc = who_is_npc(a, b)

	xr_wounded.unlock_medkit(npc)

	if not (npc:object("medkit_script")) then
		alife():create("medkit_script", npc:position(), npc:level_vertex_id(), npc:game_vertex_id(), npc:id())
	end
	
	if (npc:relation(db.actor) >= game_object.enemy) then
		npc:set_relation(game_object.neutral,db.actor)
	else
		npc:set_relation(game_object.friend,db.actor)
	end

	dxr_statistics.increment_statistic("wounded_helped")
end 

function transfer_bandage(first_speaker, second_speaker)
	dialogs.relocate_item_section(second_speaker, "bandage", "out")
	second_speaker:set_relation(game_object.friend, first_speaker)
end
function kill_yourself(first_speaker, second_speaker)
	local npc = who_is_npc(first_speaker, second_speaker)
	npc:kill(actor)
end

--' Use this function instead.
function relocate_item_section(victim, section, type, amount)
	if db.actor then
		if not amount then
			amount = 1
		end
		for i = 1, amount do
			if type == "in" then
			--     .
				--if quest_section[section] == true and victim ~= nil and victim:object(section) ~= nil then
				--	victim:transfer_item(victim:object(section), db.actor)
				--else
					alife():create(section,db.actor:position(),db.actor:level_vertex_id(),db.actor:game_vertex_id(),db.actor:id())
				--end
			elseif type == "out" then
				if victim == nil then
					printf("Couldn't relocate item to NULL")
				end
				db.actor:transfer_item(db.actor:object(section), victim)
			end
		end
		if (utils.is_ammo(section)) then
			local box_size = INI:r_s32(section, "box_size")
			amount = amount * box_size
		end
		news_manager.relocate_item(db.actor, type, section, amount)
	end
end

function relocate_money(victim, num, type)
	if db.actor then
		if type == "in" then
			num = math.round(num)
			db.actor:give_money(num)
			-- game_stats.money_quest_update (num)

		elseif type == "out" then
			if victim == nil then
				printf("Couldn't relocate money to NULL")
			end
			db.actor:transfer_money(num, victim)
			-- game_stats.money_quest_update(-num)
		end
		news_manager.relocate_money(db.actor, type, num)
	end
end

--'---------------------------------------------------------------------------------
--' DIALOG ALLOWED
--'---------------------------------------------------------------------------------
--function dialog_allowed(object, victim, id)
--	if id ~= nil then
----		printf("*DIALOGS*: dialog_allowed: %s", id)
--	else
----		printf("*DIALOGS*: dialog_allowed: nil")
--	end
--	if db.storage[victim:id()].actor_dialogs ~= nil then
--		for k,v in pairs(db.storage[victim:id()].actor_dialogs) do
--			if v == id then return true end
--		end
--	end
--	return false
--end
--function dialog_not_disable(object, victim, id)
--	if id ~= nil then
----		printf("*DIALOGS*: dialog_disable:%s", id)
--	else
----		printf("*DIALOGS*: dialog_disable:nil")
--	end
--	if db.storage[victim:id()].actor_disable ~= nil then
--		for k,v in pairs(db.storage[victim:id()].actor_disable) do
--			if v == id then return false end
--		end
--	end
--	return true
--end

function allow_wounded_dialog(object, victim, id)
	if db.storage[victim:id()].wounded == nil then
		return false
	end
	if db.storage[victim:id()].wounded.help_dialog == id then
		return true
	end
	return false
end

--function allow_guide_dialog(object, victim, id)
--	local section = db.storage[victim:id()].active_section
--	printf("active_section %s", tostring(section))
--	if section == nil then
--		return false
--	end
--	if string.find(section, "conductor", 1) ~= nil then
--		return true
--	end
--	return false
--end

-----------------------------------------------------------------------------------
-- LEVELS
-----------------------------------------------------------------------------------
--function level_escape(first_speaker, second_speaker)
--	return level.name() == "l01_escape"
--end
--
--function level_garbage(first_speaker, second_speaker)
--	return level.name() == "l02_garbage"
--end
--
--function level_agroprom(first_speaker, second_speaker)
--	return level.name() == "l03_agroprom_ai2" or level.name() == "l03_agroprom"
--end


function level_zaton(first_speaker, second_speaker)
	return level.name() == "zaton"
end

function level_jupiter(first_speaker, second_speaker)
	return level.name() == "jupiter"
end

function level_pripyat(first_speaker, second_speaker)
	return level.name() == "pripyat"
end

function not_level_zaton(first_speaker, second_speaker)
	return level.name() ~= "zaton"
end

function not_level_jupiter(first_speaker, second_speaker)
	return level.name() ~= "jupiter"
end

function not_level_pripyat(first_speaker, second_speaker)
	return level.name() ~= "pripyat"
end

-----------------------------------------------------------------------------------
-- Relation functions
-----------------------------------------------------------------------------------
function is_friend(first_speaker, second_speaker)
	return first_speaker:relation(second_speaker) == game_object.friend
end

function is_not_friend(first_speaker, second_speaker)
	return not is_friend(first_speaker, second_speaker)
end

function become_friend(first_speaker, second_speaker)
	first_speaker:set_relation(game_object.friend, second_speaker)
end

-----------------------------------------------------------------------------------
-- Community
-----------------------------------------------------------------------------------
function npc_stalker(first_speaker, second_speaker)
	local npc = who_is_npc(first_speaker, second_speaker)
	return character_community(npc) == "stalker"
end

function npc_bandit(first_speaker, second_speaker)
	local npc = who_is_npc(first_speaker, second_speaker)
	return character_community(npc) == "bandit"
end

function npc_renegade(first_speaker, second_speaker)
	local npc = who_is_npc(first_speaker, second_speaker)
	return character_community(npc) == "renegade"
end

function npc_freedom(first_speaker, second_speaker)
	local npc = who_is_npc(first_speaker, second_speaker)
	return character_community(npc) == "freedom"
end

function npc_dolg(first_speaker, second_speaker)
	local npc = who_is_npc(first_speaker, second_speaker)
	return character_community(npc) == "dolg"
end

function npc_killer(first_speaker, second_speaker)
	local npc = who_is_npc(first_speaker, second_speaker)
	return character_community(npc) == "killer"
end

function npc_army(first_speaker, second_speaker)
	local npc = who_is_npc(first_speaker, second_speaker)
	return character_community(npc) == "army"
end

function npc_ecolog(first_speaker, second_speaker)
	local npc = who_is_npc(first_speaker, second_speaker)
	return character_community(npc) == "ecolog"
end

function npc_csky(first_speaker, second_speaker)
	local npc = who_is_npc(first_speaker, second_speaker)
	return character_community(npc) == "csky"
end

function npc_monolith(first_speaker, second_speaker)
	local npc = who_is_npc(first_speaker, second_speaker)
	return character_community(npc) == "monolith"
end

-- Actor community
function actor_in_stalker(a, b)
	local npc = who_is_actor(a, b)
	return character_community(npc) == "actor_stalker"
end

function not_actor_in_stalker(a, b)
	return not actor_in_stalker(a,b)
end

function actor_set_stalker(a, b)
	db.actor:set_character_community("actor_stalker", 0, 0)
	game_relations.set_community_goodwill_for_faction("actor_stalker")
end

function actor_in_bandit(a, b)
	local npc = who_is_actor(a, b)
	return character_community(npc) == "actor_bandit"
end

function not_actor_in_bandit(a, b)
	return not actor_in_bandit(a, b)
end

function actor_set_bandit(a, b)
	db.actor:set_character_community("actor_bandit", 0, 0)
	game_relations.set_community_goodwill_for_faction("actor_bandit")
end

function actor_in_renegade(a, b)
	local npc = who_is_actor(a, b)
	return character_community(npc) == "actor_renegade"
end

function not_actor_in_renegade(a, b)
	return not actor_in_renegade(a, b)
end

function actor_set_renegade(a, b)
	db.actor:set_character_community("actor_renegade", 0, 0)
	game_relations.set_community_goodwill_for_faction("actor_renegade")
end

function actor_in_freedom(a, b)
	local npc = who_is_actor(a, b)
	return character_community(npc) == "actor_freedom"
end

function not_actor_in_freedom(a, b)
	return not actor_in_freedom(a, b)
end

function actor_set_freedom(a, b)
	db.actor:set_character_community("actor_freedom", 0, 0)
	game_relations.set_community_goodwill_for_faction("actor_freedom")
end

function actor_in_dolg(a, b)
	local npc = who_is_actor(a, b)
	return character_community(npc) == "actor_dolg"
end

function not_actor_in_dolg(a, b)
	return not actor_in_dolg(a, b)
end

function actor_set_dolg(a, b)
	db.actor:set_character_community("actor_dolg", 0, 0)
	game_relations.set_community_goodwill_for_faction("actor_dolg")
end

function actor_in_killer(a, b)
	local npc = who_is_actor(a, b)
	return character_community(npc) == "actor_killer"
end

function not_actor_in_killer(a, b)
	return not actor_in_killer(a, b)
end

function actor_set_killer(a, b)
	db.actor:set_character_community("actor_killer", 0, 0)
	game_relations.set_community_goodwill_for_faction("actor_killer")
end

function actor_in_army(a, b)
	local npc = who_is_actor(a, b)
	return character_community(npc) == "actor_army"
end

function not_actor_in_army(a, b)
	return not actor_in_army(a, b)
end

function actor_set_army(a, b)
	db.actor:set_character_community("actor_army", 0, 0)
	game_relations.set_community_goodwill_for_faction("actor_army")
end

function actor_in_ecolog(a, b)
	local npc = who_is_actor(a, b)
	return character_community(npc) == "actor_ecolog"
end

function not_actor_in_ecolog(a, b)
	return not actor_in_ecolog(a, b)
end

function actor_set_ecolog(a, b)
	db.actor:set_character_community("actor_ecolog", 0, 0)
	game_relations.set_community_goodwill_for_faction("actor_ecolog")
end

function actor_in_csky(a, b)
	local npc = who_is_actor(a, b)
	return character_community(npc) == "actor_csky"
end

function not_actor_in_csky(a, b)
	return not actor_in_csky(a, b)
end

function actor_set_csky(a, b)
	db.actor:set_character_community("actor_csky", 0, 0)
	game_relations.set_community_goodwill_for_faction("actor_csky")
end

function actor_in_monolith(a, b)
	local npc = who_is_actor(a, b)
	return character_community(npc) == "actor_monolith"
end

function not_actor_in_monolith(a, b)
	return not actor_in_monolith(a, b)
end

function actor_set_monolith(a, b)
	db.actor:set_character_community("actor_monolith", 0, 0)
	game_relations.set_community_goodwill_for_faction("actor_monolith")
end

function actor_clear_community(a, b)
	db.actor:set_character_community("actor", 0, 0)
	game_relations.set_community_goodwill_for_faction("actor")
end
-----------------------------------------------------------------------------------
-- Money functions
-----------------------------------------------------------------------------------
function has_2000_money(first_speaker, second_speaker)
	return first_speaker:money() >= 2000
end

-----------------------------------------------------------------------------------
-- TRADE
-----------------------------------------------------------------------------------
--  
function trade_init(seller, buyer)
	db.storage[seller:id()].meet.begin_wait_to_see.begin = time_global()/1000
	xr_position.setPosition(db.storage[seller:id()].meet.Seller,
							db.storage[seller:id()].meet.Seller:level_vertex_id())
	db.storage[seller:id()].meet.Buyer = buyer
end

function want_trade(seller, buyer)
	if seller:relation(buyer) == game_object.friend or
		seller:relation(buyer) == game_object.neutral
	then
		return true
	else
		return false
	end
end

function dont_want_trade(seller, buyer)
	return not want_trade(seller,buyer)
end

----------------------------------------------------------------------------------
--      !!!
----------------------------------------------------------------------------------
function relocate_item_section_to_actor(first_speaker, second_speaker, section, amount)
	--      
	dont_drop = true
	local npc = who_is_npc(first_speaker, second_speaker)
	local v = 0
	--'     .
	if not amount then
		amount = 1
	end

	local function transfer_object_item(temp, item)
		--printf("item:section(): [%s]", item:section())
		if (item:section() == section and v ~= 0) then
			npc:transfer_item(item, db.actor)
			v = v - 1
		end
	end

	if amount > 1 then
		v = amount
		npc:iterate_inventory(transfer_object_item, nil)
	else
		if npc:object(section) ~= nil then
			npc:transfer_item(npc:object(section), db.actor)
		else
			alife():create(section,db.actor:position(),db.actor:level_vertex_id(),db.actor:game_vertex_id(),db.actor:id())
		end
	end

	if v ~= 0 then
		for i = 1, v do
			alife():create(section,db.actor:position(),db.actor:level_vertex_id(),db.actor:game_vertex_id(),db.actor:id())
		end
	end
	if (utils.is_ammo(section)) then
		local box_size = INI:r_s32(section, "box_size")
		amount = amount * box_size
	end
	news_manager.relocate_item(db.actor, "in", section, amount)
	CreateTimeEvent(0,"dont_drop",0.2,function()dialogs.dont_drop = false return true end)
end

function relocate_money_to_actor(first_speaker, second_speaker, num)
	db.actor:give_money(num)
	-- game_stats.money_quest_update (num)
	news_manager.relocate_money(db.actor, "in", num)
end

function relocate_money_from_actor(first_speaker, second_speaker, num)
	local victim = who_is_npc(first_speaker, second_speaker)
	if victim == nil then
		printf("Couldn't relocate money to NULL")
	end
	db.actor:transfer_money(num, victim)
	-- game_stats.money_quest_update(-num)
	news_manager.relocate_money(db.actor, "out", num)
end

--[[ Old one
function relocate_item_section_from_actor(first_speaker, second_speaker, section)
	local npc = who_is_npc(first_speaker, second_speaker)
	db.actor:transfer_item(db.actor:object(section), npc)
	news_manager.relocate_item(db.actor, "out", section)
end
]]--

function who_is_actor(first_speaker, second_speaker)
	local npc = second_speaker
	if db.actor:id() ~= npc:id() then
		npc	= first_speaker
	end
	return npc
end

--section -    ; amount - ,    "all"
function relocate_item_section_from_actor(first_speaker, second_speaker, section, amount)
	local npc = who_is_npc(first_speaker, second_speaker)
	local i = 0
	--printf("Amount [%s]", tostring(amount))
	if not amount then
		amount = 1
	end

	local function transfer_object_item(temp, item)
		--printf("item:section(): [%s]", item:section())
		if (item:section() == section and i ~= 0) then
			db.actor:transfer_item(item, npc)
			i = i - 1
		end
	end

	if amount == "all" then
		i = -1
		db.actor:iterate_inventory(transfer_object_item, nil)
		amount = (i+1)*(-1)
		i = 0
	elseif amount > 1 then
		i = amount
		db.actor:iterate_inventory(transfer_object_item, nil)
	elseif amount < 1 then
		printf("Wrong parameters in function 'relocate_item_section_from_actor'!")
	else
		db.actor:transfer_item(db.actor:object(section), npc)
	end

	if i~=0 then
		printf("Actor hasn't enough items! Transferred [%s], needed [%s]", tostring(amount - i), tostring(amount))
	end

	if (utils.is_ammo(section)) then
		local box_size = INI:r_s32(section, "box_size")
		amount = amount * box_size
	end
	news_manager.relocate_item(db.actor, "out", section, amount - i)
end

function actor_has_item(first_speaker, second_speaker, section)
	return db.actor:object(section) ~= nil
end

function npc_has_item(first_speaker, second_speaker, section)
	local npc = who_is_npc(first_speaker, second_speaker)
	return npc:object(section) ~= nil
end

function who_is_npc(first_speaker, second_speaker)
	return first_speaker:id() == 0 and second_speaker or first_speaker
end

--------------------------------------------------------------------------------
function transfer_any_pistol_from_actor(first_speaker, second_speaker)
	local npc = who_is_npc(first_speaker, second_speaker)
		db.actor:iterate_inventory(is_pistol, npc)
	if(db.actor.pistol~=nil) then
			db.actor:transfer_item(db.actor:object(db.actor.pistol), npc)
		news_manager.relocate_item(db.actor, "out", db.actor.pistol)
		db.actor.pistol = nil
	end
end

function is_pistol(npc, item)
	local section = item:section()
	if(section=="wpn_beretta")
	or(section=="wpn_colt1911")
	or(section=="wpn_desert_eagle")
	or(section=="wpn_fort")
	or(section=="wpn_hpsa")
	or(section=="wpn_pb")
	or(section=="wpn_pm")
	or(section=="wpn_usp")
	or(section=="wpn_walther") then
		db.actor.pistol = section
	end
end

function have_actor_any_pistol(first_speaker, second_speaker)
	local npc = who_is_npc(first_speaker, second_speaker)
		db.actor:iterate_inventory(is_pistol, npc)
	if(db.actor.pistol~=nil) then
		return true
	else
		return false
	end
end

--------------------------------------------------------------------------------
function transfer_any_gun_from_actor(first_speaker, second_speaker)
	local npc = who_is_npc(first_speaker, second_speaker)
		db.actor:iterate_inventory(is_gun, npc)
	if(db.actor.gun~=nil) then
			db.actor:transfer_item(db.actor:object(db.actor.gun), npc)
		news_manager.relocate_item(db.actor, "out", db.actor.gun)
		db.actor.gun = nil
	end
end

function is_gun(npc, item)
	local section = item:section()
	if(section=="wpn_abakan")
	or(section=="wpn_ak74")
	or(section=="wpn_ak74u")
	or(section=="wpn_groza")
	or(section=="wpn_sig550")
	or(section=="wpn_vintorez") then
		db.actor.gun = section
	end
end

function have_actor_any_gun(first_speaker, second_speaker)
	local npc = who_is_npc(first_speaker, second_speaker)
		db.actor:iterate_inventory(is_gun, npc)
	if(db.actor.gun~=nil) then
		return true
	else
		return false
	end
end

--------------------------------------------------------------------------------
function transfer_any_shootgun_from_actor(first_speaker, second_speaker)
	local npc = who_is_npc(first_speaker, second_speaker)
		db.actor:iterate_inventory(is_shootgun, npc)
	if(db.actor.shootgun~=nil) then
			db.actor:transfer_item(db.actor:object(db.actor.shootgun), npc)
		news_manager.relocate_item(db.actor, "out", db.actor.shootgun)
		db.actor.shootgun = nil
	end
end

function is_shootgun(npc, item)
	local section = item:section()
	if(section=="wpn_bm16")
	or(section=="wpn_toz34")
	or(section=="wpn_wincheaster1300")
	or(section=="wpn_spas12") then
		db.actor.shootgun = section
	end
end

function have_actor_any_shootgun(first_speaker, second_speaker)
	local npc = who_is_npc(first_speaker, second_speaker)
		db.actor:iterate_inventory(is_shootgun, npc)
	if(db.actor.shootgun~=nil) then
		return true
	else
		return false
	end
end
--------------------------------------------------------------------------------
--			ALIFE SUPPORT
--------------------------------------------------------------------------------

function disable_ui(first_speaker, second_speaker)
	xr_effects.disable_ui(first_speaker, second_speaker)
end

function disable_ui_only(first_speaker, second_speaker)
	xr_effects.disable_ui_only(first_speaker, second_speaker)
end

function is_surge_running(first_speaker, second_speaker)
	return xr_conditions.surge_started()
end

function is_surge_not_running(first_speaker, second_speaker)
	return not xr_conditions.surge_started()
end

---------------------
function quest_dialog_heli_precond(first_speaker, second_speaker)
	if (has_alife_info("jup_b9_heli_1_searched") and
				has_alife_info("zat_b100_heli_2_searched") and
				has_alife_info("zat_b28_heli_3_searched") and
				has_alife_info("jup_b8_heli_4_searched") and
				has_alife_info("zat_b101_heli_5_searched")) or
				has_alife_info("pri_b305_actor_wondered_done") then
			return false
	end

	return true
end

function quest_dialog_military_precond(first_speaker, second_speaker)
	if has_alife_info("zat_b28_heli_3_searched") or has_alife_info("jup_b9_blackbox_decrypted") then
		if not (has_alife_info("zat_b28_heli_3_searched") and has_alife_info("jup_b9_blackbox_decrypted")) then
			return true
		end
	end
	return false
end

function quest_dialog_squad_precond(first_speaker, second_speaker)
	return not (has_alife_info("jup_b218_monolith_hired") and has_alife_info("jup_b218_soldier_hired") and has_alife_info("jup_a10_vano_agree_go_und"))
end

function quest_dialog_toolkits_precond(first_speaker, second_speaker)
	if has_alife_info("zat_a2_mechanic_toolkit_search") and not has_alife_info("zat_b3_task_end") then
		return true
	elseif has_alife_info("jup_b217_tech_instruments_start") and not has_alife_info("jup_b217_task_end") then
		return true
	end
	return false
end


function squad_not_in_smart_b101(first_speaker, second_speaker)
	local smart = "zat_b101"
	return not is_npc_in_current_smart(first_speaker, second_speaker, smart)
end

function squad_not_in_smart_b103(first_speaker, second_speaker)
	local smart = "zat_b103"
	return not is_npc_in_current_smart(first_speaker, second_speaker, smart)
end

function squad_not_in_smart_b104(first_speaker, second_speaker)
	local smart = "zat_b104"
	return not is_npc_in_current_smart(first_speaker, second_speaker, smart)
end

function squad_not_in_smart_b213(first_speaker, second_speaker)
	local smart = "jup_b213"
	return not is_npc_in_current_smart(first_speaker, second_speaker, smart)
end

function squad_not_in_smart_b214(first_speaker, second_speaker)
	local smart = "jup_b214"
	return not is_npc_in_current_smart(first_speaker, second_speaker, smart)
end

function squad_not_in_smart_b304(first_speaker, second_speaker)
	local smart = "pri_b304_monsters_smart_terrain"
	return not is_npc_in_current_smart(first_speaker, second_speaker, smart)
end

function squad_not_in_smart_b303(first_speaker, second_speaker)
	local smart = "pri_b303"
	return not is_npc_in_current_smart(first_speaker, second_speaker, smart)
end

function squad_not_in_smart_b40(first_speaker, second_speaker)
	local smart = "zat_b40_smart_terrain"
	return not is_npc_in_current_smart(first_speaker, second_speaker, smart)
end

function squad_not_in_smart_b18(first_speaker, second_speaker)
	local smart = "zat_b18"
	return not is_npc_in_current_smart(first_speaker, second_speaker, smart)
end

function squad_not_in_smart_b6(first_speaker, second_speaker)
	local smart = "jup_b41"
	return not is_npc_in_current_smart(first_speaker, second_speaker, smart)
end

function squad_not_in_smart_b205(first_speaker, second_speaker)
	local smart = "jup_b205_smart_terrain"
	return not is_npc_in_current_smart(first_speaker, second_speaker, smart)
end

function squad_not_in_smart_b47(first_speaker, second_speaker)
	local smart = "jup_b47"
	return not is_npc_in_current_smart(first_speaker, second_speaker, smart)
end

function squad_in_smart_zat_base(first_speaker, second_speaker)
	local smart = "zat_stalker_base_smart"
	return is_npc_in_current_smart(first_speaker, second_speaker, smart)
end

function squad_in_smart_jup_b25(first_speaker, second_speaker)
	local smart = "jup_a6"
	return is_npc_in_current_smart(first_speaker, second_speaker, smart)
end

function spartak_is_alive(first_speaker, second_speaker)
	return xr_conditions.is_alive(nil,nil,{"zat_b7_stalker_victim_1"})
end

function tesak_is_alive(first_speaker, second_speaker)
	return xr_conditions.is_alive(nil,nil,{"zat_b103_lost_merc_leader"})
end

function gonta_is_alive(first_speaker, second_speaker)
	return xr_conditions.is_alive(nil,nil,{"zat_b103_lost_merc_leader"})
end

function mityay_is_alive(first_speaker, second_speaker)
	return xr_conditions.is_alive(nil,nil,{"jup_a12_stalker_assaulter"})
end

function dolg_can_work_for_sci(first_speaker, second_speaker)
	return not (has_alife_info("jup_a6_freedom_leader_bunker_guards_work") or has_alife_info("jup_a6_freedom_leader_bunker_scan_work"))
end

function dolg_can_not_work_for_sci(first_speaker, second_speaker)
	return has_alife_info("jup_a6_freedom_leader_bunker_guards_work") or has_alife_info("jup_a6_freedom_leader_bunker_scan_work")
end

function freedom_can_work_for_sci(first_speaker, second_speaker)
	return not (has_alife_info("jup_a6_duty_leader_bunker_guards_work") or has_alife_info("jup_a6_duty_leader_bunker_scan_work"))
end

function freedom_can_not_work_for_sci(first_speaker, second_speaker)
	return has_alife_info("jup_a6_duty_leader_bunker_guards_work") or has_alife_info("jup_a6_duty_leader_bunker_scan_work")
end

function monolith_leader_is_alive(first_speaker, second_speaker)
	if not (has_alife_info("jup_b4_monolith_squad_in_freedom") or has_alife_info("jup_b4_monolith_squad_in_duty")) then
		return xr_conditions.is_alive(nil,nil,{"jup_b4_monolith_squad_leader_monolith_skin"})
	end

	if has_alife_info("jup_b4_monolith_squad_in_freedom") then
		return xr_conditions.is_alive(nil,nil,{"jup_b4_monolith_squad_leader_freedom_skin"})
	elseif has_alife_info("jup_b4_monolith_squad_in_duty") then
		return xr_conditions.is_alive(nil,nil,{"jup_b4_monolith_squad_leader_duty_skin"})
	end

	return false
end

function monolith_leader_dead_or_hired(first_speaker, second_speaker)
	if has_alife_info("jup_b218_soldier_hired") then
		return true
	end

	if not (has_alife_info("jup_b4_monolith_squad_in_freedom") or has_alife_info("jup_b4_monolith_squad_in_duty")) then
		return not xr_conditions.is_alive(nil,nil,{"jup_b4_monolith_squad_leader_monolith_skin"})
	end

	if has_alife_info("jup_b4_monolith_squad_in_freedom") then
		return not xr_conditions.is_alive(nil,nil,{"jup_b4_monolith_squad_leader_freedom_skin"})
	elseif has_alife_info("jup_b4_monolith_squad_in_duty") then
		return not xr_conditions.is_alive(nil,nil,{"jup_b4_monolith_squad_leader_duty_skin"})
	end

	return true
end

function monolith_leader_dead_or_dolg(first_speaker, second_speaker)
	if has_alife_info("jup_b218_soldier_hired") then
		return true
	end

	if not (has_alife_info("jup_b4_monolith_squad_in_freedom") or has_alife_info("jup_b4_monolith_squad_in_duty")) then
		return not xr_conditions.is_alive(nil,nil,{"jup_b4_monolith_squad_leader_monolith_skin"})
	end

	if has_alife_info("jup_b4_monolith_squad_in_freedom") then
		return true
	elseif has_alife_info("jup_b4_monolith_squad_in_duty") then
		return not xr_conditions.is_alive(nil,nil,{"jup_b4_monolith_squad_leader_duty_skin"})
	end

	return true
end

function monolith_leader_dead_or_freedom(first_speaker, second_speaker)
	if has_alife_info("jup_b218_soldier_hired") then
		return true
	end

	if not (has_alife_info("jup_b4_monolith_squad_in_freedom") or has_alife_info("jup_b4_monolith_squad_in_duty")) then
		return not xr_conditions.is_alive(nil,nil,{"jup_b4_monolith_squad_leader_monolith_skin"})
	end

	if has_alife_info("jup_b4_monolith_squad_in_freedom") then
		return not xr_conditions.is_alive(nil,nil,{"jup_b4_monolith_squad_leader_freedom_skin"})
	elseif has_alife_info("jup_b4_monolith_squad_in_duty") then
		return true
	end

	return true
end

-- Medic support
function medic_magic_potion(first_speaker, second_speaker)
	local secind_max = 12--       
	local cactor = db.actor:cast_Actor():conditions()
	local secind = math.ceil((math.random(5,30)/60) + (1 - cactor:GetHealth())*secind_max) --           + (   " 5  30").
	local function health_set()
		db.actor:set_health_ex(1)
		for i=1, 6 do
			cactor:SetHealth(1,i)
			cactor:ChangeBleeding(100,i)
			cactor:ChangeFracture(100,i)
		end
		--cactor:ClearWounds()
		--cactor:ClearFractures()
		cactor:ChangePsyHealth(1)
		cactor:SetPain(0)
		cactor:SetToxicity(0)
		db.actor.bleeding = 1
		db.actor.power = 1
	end

	health_set()
	CreateTimeEvent(1,"medic_magic_potion_anim",2,function()
		ui_sleep_dialog.sleep_forced(secind)
		health_set()
		return true
	end)
end

function medic_rad_potion(first_speaker, second_speaker)
	local cactor = db.actor:cast_Actor():conditions()
	cactor:ChangeRadiation(-1)
	dialogs_area.heal_rad_01()
end

function health_care_actor_has_money(first_speaker, second_speaker)
	return db.actor:money() >= 2500
end

function health_care_actor_has_rad_money(first_speaker, second_speaker)
	return db.actor:money() >= 3000
end

function health_care_actor_hasnt_money(first_speaker, second_speaker)
	return not health_care_actor_has_money(first_speaker, second_speaker)
end

function health_care_actor_hasnt_rad_money(first_speaker, second_speaker)
	return not health_care_actor_has_rad_money(first_speaker, second_speaker)
end

function health_care_actor_transfer_money(first_speaker, second_speaker)
	dialogs.relocate_money_from_actor(first_speaker, second_speaker, 2500)
end

function health_care_actor_transfer_rad_money(first_speaker, second_speaker)
	dialogs.relocate_money_from_actor(first_speaker, second_speaker, 3000)
end

function health_care_actor_transfer_fract_money(first_speaker, second_speaker)
	dialogs.relocate_money_from_actor(first_speaker, second_speaker, 3200)
end

function actor_needs_bless(first_speaker, second_speaker)
	if db.actor.health < 1 or db.actor.radiation > 0 or db.actor.bleeding > 0 then
		return true
	end

	return false
end

function actor_needs_health(first_speaker, second_speaker)
	if (db.actor.health < 1) and (db.actor:money() >= 2500) then
		return true
	end
	return false
end

function actor_needs_rad_health(first_speaker, second_speaker)
	if (db.actor.radiation > 0) and (db.actor:money() >= 3000) then
		return true
	end
	return false
end

function actor_is_damn_healthy(first_speaker, second_speaker)
	return not actor_needs_bless(first_speaker, second_speaker)
end

function actor_needs_rad_bless(first_speaker, second_speaker)
	if db.actor.radiation > 0 or db.actor.bleeding >= 0 then
		return true
	end

	return false
end

function actor_wants_rad_bless(first_speaker, second_speaker)
	if db.actor.radiation > 0 and db.actor:money() >= 3500 then
		return true
	end

	return false
end

function actor_must_rad_bless(first_speaker, second_speaker)
	if db.actor.radiation > 0 and db.actor:money() >= 500 and db.actor:money() < 3500 then
		return true
	end

	return false
end

function actor_is_damn_healthy(first_speaker, second_speaker)
	return not actor_needs_bless(first_speaker, second_speaker)
end

function leave_zone_save(first_speaker, second_speaker)
	xr_effects.scenario_autosave(db.actor,nil,{"st_save_uni_zone_to_reality"})
end

function save_uni_travel_zat_to_jup(first_speaker, second_speaker)
	xr_effects.scenario_autosave(db.actor,nil,{"st_save_uni_travel_zat_to_jup"})
end

function save_uni_travel_zat_to_pri(first_speaker, second_speaker)
	xr_effects.scenario_autosave(db.actor,nil,{"st_save_uni_travel_zat_to_pri"})
end

function save_uni_travel_jup_to_zat(first_speaker, second_speaker)
	xr_effects.scenario_autosave(db.actor,nil,{"st_save_uni_travel_jup_to_zat"})
end

function save_uni_travel_jup_to_pri(first_speaker, second_speaker)
	xr_effects.scenario_autosave(db.actor,nil,{"st_save_uni_travel_jup_to_pri"})
end

function save_uni_travel_pri_to_zat(first_speaker, second_speaker)
	xr_effects.scenario_autosave(db.actor,nil,{"st_save_uni_travel_pri_to_zat"})
end

function save_uni_travel_pri_to_jup(first_speaker, second_speaker)
	xr_effects.scenario_autosave(db.actor,nil,{"st_save_uni_travel_pri_to_jup"})
end

function save_jup_b218_travel_jup_to_pas(first_speaker, second_speaker)
	xr_effects.scenario_autosave(db.actor,nil,{"st_save_jup_b218_travel_jup_to_pas"})
end

function save_pri_a17_hospital_start(first_speaker, second_speaker)
	xr_effects.scenario_autosave(db.actor,nil,{"st_save_pri_a17_hospital_start"})
end

function save_jup_a10_gonna_return_debt(first_speaker, second_speaker)
	if has_alife_info("jup_a10_vano_give_task") and not has_alife_info("jup_a10_avtosave") and not has_alife_info("jup_b218_gather_squad_complete") then
		xr_effects.scenario_autosave(db.actor,nil,{"st_save_jup_a10_gonna_return_debt"})
		db.actor:give_info_portion("jup_a10_avtosave")
	end
end

function save_jup_b6_arrived_to_fen(first_speaker, second_speaker)
	xr_effects.scenario_autosave(db.actor,nil,{"st_save_jup_b6_arrived_to_fen"})
end

function save_jup_b6_arrived_to_ash_heap(first_speaker, second_speaker)
	xr_effects.scenario_autosave(db.actor,nil,{"st_save_jup_b6_arrived_to_ash_heap"})
end

function save_jup_b19_arrived_to_kopachy(first_speaker, second_speaker)
	xr_effects.scenario_autosave(db.actor,nil,{"st_save_jup_b19_arrived_to_kopachy"})
end

function save_zat_b106_arrived_to_chimera_lair(first_speaker, second_speaker)
	xr_effects.scenario_autosave(db.actor,nil,{"st_save_zat_b106_arrived_to_chimera_lair"})
end

function save_zat_b5_met_with_others(first_speaker, second_speaker)
	xr_effects.scenario_autosave(db.actor,nil,{"st_save_zat_b5_met_with_others"})
end

function can_do_alun_riddle_quest(first_speaker, second_speaker)
	return has_alife_info("alun_riddle_begin") ~= true
end
