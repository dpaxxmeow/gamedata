--------------------------------------------------------------------------------
-- Dialog manager --------------------------------------------------------------
-- Made by Peacemaker ----------------------------------------------------------
-- 11.01.08 --------------------------------------------------------------------
--------------------------------------------------------------------------------
-- modified by Alundaio, Holodilnik, DoctorX

RandomVal = 0
disabled_phrases = {} -- temporary table of phrases which have been disabled during a conversation
local quest_disabled_phrases = {} -- temporary table of phrases which have been disabled during a conversation
local id_counter = 6 -- start from 5 because of adding root phrases

phrase_table = {
					hello = {},
					job = {},
					anomalies = {},
					place = {},
					information = {},
					tips = {}
				}
priority_table = {
					hello = {},
					job = {},
					anomalies = {},
					place = {},
					information = {},
					tips = {}
				 }


----------------------- Alundaio easy scripted_dialog
local saved_dialog
--local cond_list = {}
function add_dialog(p_id,id,phrase_id,cond,act)
	if not ( saved_dialog ) then
		return
	end

	local phrase = saved_dialog:AddPhrase(phrase_id,tostring(id),tostring(p_id),-10000)
	if not ( phrase ) then
		return
	end

	--printf("phrase_id = %s",phrase_id)

	local phrase_script = phrase:GetPhraseScript()
	if (cond) then
		if (type(cond) == "table") then
			for key, value in pairs(cond) do
				if (alun_utils.findfunction(value,_G)) then
					phrase_script:AddPrecondition(value)
					--table.insert(cond_list,value)
				else
					printf("dialog_manager:Error: No such function exists '%s'",value)
				end
			end
		else
			if (alun_utils.findfunction(cond,_G)) then
				phrase_script:AddPrecondition(cond)
				--table.insert(cond_list,value)
			else
				printf("dialog_manager:Error: No such function exists '%s'",cond)
			end
		end
	end

	if (act) then
		if (type(act) == "table") then
			for key, value in pairs(act) do
				if (alun_utils.findfunction(value,_G)) then
					phrase_script:AddAction(value)
				else
					printf("dialog_manager:Error: No such function exists '%s'",value)
				end
			end
		else
			if (alun_utils.findfunction(act,_G)) then
				phrase_script:AddAction(act)
			else
				printf("dialog_manager:Error: No such function exists '%s'",act)
			end
		end
	end
	return phrase_script
end

function add_script_dialog(p_id,id,phrase_id,cond,act)
	local d = add_dialog(p_id,id,phrase_id,cond,act)
	if (d) then
		d:SetScriptText(phrase_id)
	end
end

-- Dialog structure for Meet Honcho and random storyline quest:
function drx_sl_init_honcho_meet_dialog( dialog )
	saved_dialog = dialog
	local base_id = 0

	-- Actor greets honcho:
	add_dialog( "", (base_id + 0), ("st_drx_sl_meet_honcho_" .. math.random( 1,5 )))  -- Actor
		-- Honcho explains current storyline task:
		add_script_dialog((base_id + 0), (base_id + 1), "dialogs.drx_sl_text_honcho_has_storyline_task_to_give")  -- NPC
			-- Actor accepts non-fetch storyline task:
			add_dialog((base_id + 1), (base_id + 2), ("dm_universal_actor_take_task_" .. math.random( 1,5 )), {"dialogs.not_task_is_fetch_task", "dialogs.npc_has_ordered_task_to_give"}, "dialogs.drx_sl_give_sl_task")  -- Actor
				-- Honcho affirms acceptance:
				add_script_dialog((base_id + 2), (base_id + 3), "dialogs.text_st_accepted_task_task")  -- NPC
					-- Actor leaves honcho:
					add_dialog((base_id + 3), (base_id + 4), ("dm_universal_actor_exit_thanks_" .. math.random( 1,5 )), nil, "dialogs.npc_clear_skipped_tasks")  -- Actor
			-- Actor accepts fetch storyline task:
			add_dialog((base_id + 1), (base_id + 5), ("dm_universal_actor_take_task_" .. math.random( 1,5 )), {"dialogs.task_is_fetch_task", "dialogs.npc_has_ordered_task_to_give"} )  -- Actor
				-- Honcho explains fetch task
				add_script_dialog((base_id + 5), (base_id + 6), "dialogs.drx_sl_text_fetch_task", nil, "dialogs.drx_sl_give_sl_task")  -- NPC
					-- Actor leaves honcho:
					add_dialog((base_id + 6), (base_id + 7), ("dm_universal_actor_exit_thanks_" .. math.random( 1,5 )), nil, "dialogs.npc_clear_skipped_tasks")  -- Actor

end

-- Trade and repair dialogs instead of buttons
function dm_trade_add(dialog)

	saved_dialog = dialog
	local base_id = 0
	
	add_dialog( "", (base_id + 0), ("dm_dialog_add_trade_" .. math.random(1,5)))  -- Actor
	
		add_script_dialog((base_id + 0), (base_id + 1), "dialogs.st_universal_agree", nil, {"dialogs.npc_is_trader", "dialogs.break_dialog"})  -- NPC

end

function dm_repair_add(dialog)

	saved_dialog = dialog
	local base_id = 0
	
	add_dialog( "", (base_id + 0), ("dm_dialog_add_repair_" .. math.random(1,5)))  -- Actor
	
		add_script_dialog((base_id + 0), (base_id + 1), "dialogs.st_universal_agree", nil, {"dialogs.npc_is_tech", "dialogs.break_dialog"})  -- NPC

end

function debt_task_dialog(dialog)

	saved_dialog = dialog

	dialogs.debt_chance()
	
	add_dialog( "", 0, ("st_debt_task_dialog_start_" .. math.random( 1,5 )))  -- Actor

		add_script_dialog( 0, 1, "dialogs.st_debt_task_dialog_good", "dialogs.is_first_debt_dialog")  -- NPC

			add_dialog( 1, 2, ("dm_universal_actor_exit_thanks_" .. math.random( 1,5 )), nil, {"dialogs.give_debt", "dialogs.set_dd_chance_nil"})  -- Actor
			
		add_script_dialog( 0, 3, "dialogs.st_debt_task_dialog_bad", "dialogs.is_second_debt_dialog")  -- NPC

			add_dialog( 3, 4, ("st_debt_task_dialog_actor_bad_" .. math.random( 1,5 )), nil)  -- Actor
				
				add_script_dialog( 4, 5, "dialogs.st_debt_task_dialog_fight", nil, {"dialogs.set_enemy", "dialogs.set_dd_chance_nil"})  -- NPC
				
		add_script_dialog( 0, 6, "dialogs.st_debt_task_dialog_bad", "dialogs.is_third_debt_dialog")  -- NPC

			add_dialog( 6, 7, ("st_debt_task_dialog_actor_bad_" .. math.random( 1,5 )), nil)  -- Actor
				
				add_script_dialog( 7, 8, "dialogs.st_debt_task_dialog_retreat", nil, {"dialogs.give_debt", "dialogs.set_dd_chance_nil"})  -- NPC
					
					add_dialog( 8, 9, ("dm_universal_actor_exit_thanks_" .. math.random( 1,5 )))  -- Actor
					
					add_dialog( 8, 10, ("st_debt_task_dialog_kill_" .. math.random( 1,5 )), nil, "dialogs.panick_to_actor")  -- Actor

end

function package_task_dialog(dialog)

	saved_dialog = dialog
	
	add_dialog( "", 0, ("st_package_task_dialog_start_" .. math.random( 1,5 )))  -- Actor

		add_script_dialog( 0, 1, "dialogs.st_package_task_dialog_good", "dialogs.is_actor_have_package")  -- NPC

			add_dialog( 1, 2, ("dm_universal_actor_exit_thanks_" .. math.random( 1,5 )), nil, "dialogs.take_package")  -- Actor
			
		add_script_dialog( 0, 3, "dialogs.st_package_task_dialog_bad", "dialogs.is_actor_havent_package")  -- NPC

			add_dialog( 3, 4, ("dm_universal_actor_take_task_" .. math.random( 1,5 )))  -- Actor

end

-- Dialog structure for changing factions:
function drx_sl_init_change_faction_dialog( dialog )
	saved_dialog = dialog
	local base_id = 0
	-- Actor requests to change factions:
	add_dialog( "", (base_id + 0), "st_drx_sl_change_factions_request")  -- Actor
		-- NPC explains change factions task:
		add_script_dialog((base_id + 0), (base_id + 1), "dialogs.drx_sl_text_npc_has_change_factions_task_to_give")  -- NPC
			-- Actor accepts non-fetch change factions task:
			add_dialog((base_id + 1), (base_id + 2), "st_drx_sl_accept_change_factions_task", {"dialogs.not_task_is_fetch_task", "dialogs.npc_has_ordered_task_to_give"}, "dialogs.drx_sl_give_cf_task")  -- Actor
				-- NPC affirms acceptance:
				add_dialog((base_id + 2), (base_id + 3), "st_drx_sl_change_factions_task_accepted")  -- NPC
					-- Actor leaves NPC:
					add_dialog((base_id + 3), (base_id + 4), "st_drx_sl_change_factions_actor_exit", nil, "dialogs.npc_clear_skipped_tasks")  -- Actor
			-- Actor accepts fetch change factions task:
			add_dialog((base_id + 1), (base_id + 5), "st_drx_sl_accept_change_factions_task", {"dialogs.task_is_fetch_task", "dialogs.npc_has_ordered_task_to_give"} )  -- Actor
				-- NPC explains fetch task
				add_script_dialog((base_id + 5), (base_id + 6), "dialogs.drx_sl_text_fetch_task", nil, "dialogs.drx_sl_give_cf_task")  -- NPC
					-- Actor leaves honcho:
					add_dialog((base_id + 6), (base_id + 7), "st_drx_sl_change_factions_actor_exit", nil, "dialogs.npc_clear_skipped_tasks")  -- Actor
			-- Actor refuses task and leaves NPC:
			add_dialog((base_id + 1), (base_id + 8), ("dm_universal_actor_exit_" .. math.random( 1,5 )), nil, "dialogs.npc_clear_skipped_tasks")  -- Actor
end

-- Dialog structure for requesting mechanic task:
function drx_sl_init_mechanic_task_dialog( dialog )
	saved_dialog = dialog
	local base_id = 0
	-- Loop is necessary to allow skipping of unwanted tasks:
	--for i = 1,10 do
		-- Actor requests task:
		add_dialog( "", (base_id + 0), ("st_ordered_task_query_" .. math.random( 1,5 )))
			-- NPC offers task:
			add_script_dialog((base_id + 0), (base_id + 1), "dialogs.drx_sl_text_mechanic_has_ordered_task_to_give")
				-- Actor accepts non-fetch task:
				add_dialog((base_id + 1), (base_id + 2), ("st_task_more_info_" .. math.random( 1,5 )), {"dialogs.not_task_is_fetch_task", "dialogs.npc_has_ordered_task_to_give"})
					-- NPC affirms acceptance:
					add_script_dialog((base_id + 2), (base_id + 3), "dialogs.text_common_task")
						-- Actor accepts task:
						add_dialog((base_id + 3), (base_id + 4), ("dm_universal_actor_take_task_" .. math.random( 1,5 )), nil, {"dialogs.npc_clear_skipped_tasks", "dialogs.drx_sl_give_mechanic_task"})
						-- Actor refuses task:
						add_dialog((base_id + 3), (base_id + 5), ("dm_universal_actor_refuse_" .. math.random( 1,5 )))
				-- Actor accepts fetch task:
				add_dialog((base_id + 1), (base_id + 6), ("st_task_more_info_" .. math.random( 1,5 )), {"dialogs.task_is_fetch_task", "dialogs.npc_has_ordered_task_to_give"} )
					-- NPC explains fetch task:
					add_script_dialog((base_id + 6), (base_id + 7), "dialogs.drx_sl_text_fetch_task")
						-- Actor accepts task:
						add_dialog((base_id + 7), (base_id + 8), ("dm_universal_actor_take_task_" .. math.random( 1,5 )), nil, {"dialogs.drx_sl_give_mechanic_task", "dialogs.npc_clear_skipped_tasks"})
						-- Actor refuses task:
						add_dialog((base_id + 7), (base_id + 9), ("dm_universal_actor_refuse_" .. math.random( 1,5 )))
 				-- Actor refuses offered task and requests another:
-- 				add_dialog((base_id + 1), (base_id + 10), "st_ordered_task_next", "dialogs.npc_has_ordered_task_to_give", "dialogs.npc_skip_first_ordered_task")
				-- Actor leaves NPC:
				add_dialog((base_id + 1), (base_id + 11), ("dm_universal_actor_exit_" .. math.random( 1,5 )), nil, "dialogs.npc_clear_skipped_tasks")
-- 		base_id = (base_id + 11)
-- 	end
end

-- Dialog structure for storyline task completed dialog:
function drx_sl_task_completed_dialog(dialog)
	saved_dialog = dialog
	-- Actor returns to honcho and states job is done:
	add_dialog( "", 0, ("st_ordered_task_query_finished_" .. math.random( 1,5 )))  -- Actor
		-- Honcho replies and sends to next honcho:
		add_script_dialog( 0, 1, "dialogs.drx_sl_text_task_finish", {"dialogs.drx_sl_actor_has_finished_task","dialogs.drx_sl_is_not_endgame"}, "dialogs.drx_sl_set_finished_task_complete")  -- NPC
		-- Honcho replies and sends on End Game task:
		add_script_dialog( 0, 2, "dialogs.drx_sl_text_end_game", {"dialogs.drx_sl_actor_has_finished_task","dialogs.drx_sl_is_endgame"}, "dialogs.drx_sl_set_finished_task_complete_endgame")  -- NPC
			-- Actor thanks honcho and leaves:
			add_dialog( 1, 3, ("dm_universal_actor_exit_thanks_" .. math.random( 1,5 )))  -- Actor
end

-- Dialog structure for storyline task completed dialog:
function drx_sl_cf_task_completed_dialog( dialog )
	saved_dialog = dialog
	-- Actor returns to npc and states job is done:
	add_dialog( "", 0, ("st_ordered_task_query_finished_" .. math.random( 1,5 )))  -- Actor
		-- NPC replies:
		add_script_dialog( 0, 1, "dialogs.drx_sl_text_cf_task_finish", {"dialogs.drx_sl_actor_has_finished_cf_task"}, "dialogs.drx_sl_set_finished_cf_task_complete")  -- NPC
			-- Actor thanks npc and leaves:
			add_dialog( 1, 3, ("dm_universal_actor_exit_thanks_" .. math.random( 1,5 )))  -- Actor
end

-----------------------------------------------------
--	Caravans
-----------------------------------------------------
function dm_active_caravans_dialog(dialog)
	saved_dialog = dialog
	add_script_dialog("",0,"area_caravans.text_dm_caravan_active","area_caravans.dm_caravan_active")									-- NPC
		add_dialog(0,1,"st_caravan_active_yes",nil,"dialogs.break_dialog")																-- ACTOR
end
function dm_reward_caravans_dialog(dialog)
	saved_dialog = dialog
	add_dialog("",0,"st_caravan_reward","area_caravans.dm_caravan_done","area_caravans.dm_caravan_reward")								-- NPC
		add_dialog(0,1,"st_caravan_reward_done",nil,"dialogs.break_dialog")																-- ACTOR
end
-----------------------------------------------------
-- Dynamic special ammo Dialog
-----------------------------------------------------
function dm_init_dynamic_spec_loads_order_dialog(dialog)
    saved_dialog = dialog
	local as = dialogs_spec_loads.ammo_size
	local base_id = 1
	add_dialog("",0,"st_dm_spec_ammo_query")																												-- Actor start
		add_dialog(0,1,"st_dm_spec_ammo_start")																												-- NPC Ammo offer dialog
		for i=1,as do
			add_script_dialog(1,base_id+1,"dialogs_spec_loads.text_wpn_list_"..i,"dialogs_spec_loads.has_wpn_check_"..i,"dialogs_spec_loads.set_wpn_"..i)	-- ACTOR show weapons list
				add_script_dialog(base_id+1,base_id+2,"dialogs_spec_loads.text_ammo_offer")																	-- NPC
					add_dialog(base_id+2,base_id+3,"st_dm_spec_ammo_price_accept","dialogs_spec_loads.has_ammo_cost","dialogs_spec_loads.buy_ammo")			-- ACTOR
						add_script_dialog(base_id+3,base_id+4,"dialogs_spec_loads.text_ammo_processing")													-- NPC
							add_dialog(base_id+4,base_id+5,"st_dm_spec_ammo_goodbye",nil,"dialogs.break_dialog")											-- ACTOR
					add_dialog(base_id+2,base_id+6,"st_dm_no_money","dialogs_spec_loads.hasnt_ammo_cost")													-- ACTOR
					add_dialog(base_id+2,base_id+7,"st_dm_spec_ammo_no")																					-- ACTOR
			base_id = base_id+10	
		end	
			add_dialog(1,999,"st_dm_spec_ammo_none",nil,"dialogs.break_dialog")																				-- ACTOR
end
--	
function dm_init_dynamic_spec_loads_processing_dialog(dialog)	
	saved_dialog = dialog
	add_dialog("",0,"st_dm_spec_ammo_in_process")																											-- ACTOR
		add_script_dialog(0,1,"dialogs_spec_loads.text_in_process","dialogs_spec_loads.has_ammo_processing")												-- NPC
			add_dialog(1,2,"st_dm_spec_ammo_cancel")																										-- ACTOR
				add_dialog(2,3,"st_dm_spec_ammo_cancel_reply")																								-- NPC
					add_dialog(3,4,"st_dm_spec_ammo_cancel_reply_yes")																						-- ACTOR
						add_dialog(4,5,"st_dm_spec_ammo_cancel_reply_yes_done",nil,"dialogs_spec_loads.purchase_cancel")									-- NPC
							add_dialog(5,6,"st_dm_spec_ammo_goodbye")																						-- ACTOR
					add_dialog(3,7,"st_dm_spec_ammo_cancel_reply_no")																						-- ACTOR
						add_dialog(7,8,"st_dm_spec_ammo_cancel_reply_no_done")																				-- NPC
							add_dialog(8,9,"st_dm_spec_ammo_cancel_back",nil,"dialogs.break_dialog")														-- ACTOR
		add_script_dialog(0,10,"dialogs_spec_loads.text_ammo_pickup","dialogs_spec_loads.has_ammo_ready")													-- NPC
			add_dialog(10,11,"st_dm_spec_ammo_pickup_done",nil,"dialogs_spec_loads.pickup_ammo")															-- ACTOR
				add_dialog(11,12,"st_dm_spec_ammo_more")																									-- NPC
					add_dialog(12,13,"st_dm_spec_ammo_goodbye")																								-- ACTOR
end
--
-----------------------------------------------------
-- Dynamic order Dialog random
-----------------------------------------------------
function dm_init_dynamic_orders_random_dialog(dialog)
    saved_dialog = dialog
    local base_id = 1
   
    add_dialog("",0,"st_dm_orders_query")																																			-- ACTOR start order dialog
		-- place order
		add_script_dialog(0,1,"dialogs_orders_random.text_orders_query")                                            																-- NPC	introduce list
		for i=1,10 do
            add_script_dialog(1,base_id+1,"dialogs_orders_random.text_category_title_"..i,"dialogs_orders_random.has_category_"..i,"dialogs_orders_random.set_category_"..i)		-- ACTOR show list
				add_script_dialog(base_id+1,base_id+2,"dialogs_orders_random.text_offer_item")																						-- NPC
					add_script_dialog(base_id+2,base_id+3,"dialogs_orders_random.text_accept_offer_item", "dialogs_orders_random.has_prepay", "dialogs_orders_random.give_prepay")	-- ACTOR
						add_script_dialog(base_id+3,base_id+4,"dialogs_orders_random.text_confirm_offer_item")																		-- NPC
							add_dialog(base_id+4,base_id+5,"st_dm_orders_place_finish",nil,"dialogs.break_dialog")                              									-- ACTOR
                    add_dialog(base_id+2,base_id+6,"st_dm_orders_no_money", "dialogs_orders_random.hasnt_prepay", "dialogs.break_dialog")            								-- ACTOR
                    add_dialog(base_id+2,base_id+7,"st_dm_orders_none",nil,"dialogs.break_dialog")                                            										-- ACTOR
            base_id = base_id + 10
        end
			add_dialog(1,9999,"st_dm_orders_none",nil,"dialogs.break_dialog")																										-- ACTOR
end
function dm_init_dynamic_orders_processing_random_dialog(dialog)
    saved_dialog = dialog
    local base_id = 1

	add_dialog("",0,"st_dm_orders_query_pickup")																											-- ACTOR start processing order dialog
		-- complete purchase existing	
		add_script_dialog(0,3000,"dialogs_orders_random.orders_item_pickup_existing","dialogs_orders_random.has_done_item")									-- NPC existing Order Pickup
			add_dialog(3000,3001,"st_dm_orders_pickup_existing_yes","dialogs_orders_random.has_item_cost")													-- ACTOR
				add_dialog(3001,3002,"st_dm_orders_pickup_finish",nil,"dialogs_orders_random.buy_item")														-- NPC
					add_dialog(3002,3003,"st_dm_orders_goodbye",nil,"dialogs.break_dialog")																	-- ACTOR
			add_dialog(3000,3010,"st_dm_orders_pickup_existing_no")																							-- ACTOR
				add_dialog(3010,3011,"st_dm_orders_pickup_refuse_warning")																					-- NPC
					add_dialog(3011,3012,"st_dm_orders_pickup_refuse_penalty")																				-- ACTOR
						add_dialog(3012,3013,"st_dm_orders_pickup_refuse_penalty_reply",nil,"dialogs_orders_random.purchase_cancel")						-- NPC
							add_dialog(3013,3014,"st_dm_orders_goodbye",nil,"dialogs.break_dialog")															-- ACTOR
					add_dialog(3011,3015,"st_dm_orders_pickup_refuse_wait")																					-- ACTOR
						add_dialog(3015,3016,"st_dm_orders_pickup_refuse_wait_rely")																		-- NPC
							add_dialog(3016,3017,"st_dm_orders_goodbye",nil,"dialogs.break_dialog")															-- ACTOR
			add_dialog(3000,3020,"st_dm_orders_no_money","dialogs_orders_random.hasnt_item_cost")															-- ACTOR
				add_dialog(3020,3021,"st_dm_orders_pickup_hold")																							-- NPC
					add_dialog(3021,3022,"st_dm_orders_goodbye",nil,"dialogs.break_dialog")																	-- ACTOR
		-- complete purchase
		add_script_dialog(0,2000,"dialogs_orders_random.orders_item_pickup","dialogs_orders_random.has_pickup_cond","dialogs_orders_random.randomize_item")	-- NPC Order Pickup
			add_dialog(2000,2001,"st_dm_orders_pickup_price_accept","dialogs_orders_random.has_item_cost")													-- ACTOR
				add_dialog(2001,2003,"st_dm_orders_pickup_finish",nil,"dialogs_orders_random.buy_item")														-- NPC
					add_dialog(2003,2004,"st_dm_orders_goodbye",nil,"dialogs.break_dialog")																	-- ACTOR
			add_dialog(2000,2020,"st_dm_orders_no_money","dialogs_orders_random.hasnt_item_cost")															-- ACTOR
				add_dialog(2020,2021,"st_dm_orders_pickup_hold")																							-- NPC
					add_dialog(2021,2022,"st_dm_orders_goodbye",nil,"dialogs.break_dialog")																	-- ACTOR
			add_dialog(2000,2030,"st_dm_orders_pickup_ponder","dialogs_orders_random.has_item_cost")														-- ACTOR
				add_dialog(2030,2031,"st_dm_orders_pickup_ponder_reply")																					-- NPC
					add_dialog(2031,2032,"st_dm_orders_time_query_goodbye",nil,"dialogs.break_dialog")														-- ACTOR
        -- check and cancel ongoing order--	
		add_script_dialog(0,1000,"dialogs_orders_random.processing_item","dialogs_orders_random.has_processing_cond")										-- NPC Order processing
			add_dialog(1000,1001,"st_dm_orders_time_query")																									-- ACTOR
				add_dialog(1001,1002,"st_dm_orders_time_query_reply")																						-- NPC
					add_dialog(1002,1003,"st_dm_orders_time_query_goodbye")																					-- ACTOR
			add_dialog(1000,1010,"st_dm_orders_cancel")																										-- ACTOR
				add_dialog(1010,1011,"st_dm_orders_cancel_reply")																							-- NPC
					add_dialog(1011,1012,"st_dm_orders_cancel_reply_yes")																					-- ACTOR
						add_dialog(1012,1013,"st_dm_orders_cancel_reply_yes_done",nil,"dialogs_orders_random.purchase_cancel")								-- NPC
							add_dialog(1013,1014,"st_dm_orders_goodbye",nil,"dialogs.break_dialog")															-- ACTOR
					add_dialog(1011,1015,"st_dm_orders_cancel_reply_no")																					-- ACTOR
						add_dialog(1015,1016,"st_dm_orders_cancel_reply_no_done")																			-- NPC
							add_dialog(1016,1017,"st_dm_orders_goodbye",nil,"dialogs.break_dialog")															-- ACTOR
end
-----------------------------------------------------
-- Dynamic order Dialog
-----------------------------------------------------
function dm_init_dynamic_orders_dialog(dialog)
    saved_dialog = dialog
    local base_id,base_id2 = 1,0
    add_dialog("",0,"st_dm_orders_query")																																-- ACTOR start order dialog
	local cs,ls = dialogs_orders.cat_size, dialogs_orders.list_size
	--printf("dm cat_size = %s list_size = %s", cs,ls)
		-- place order
		add_script_dialog(0,1,"dialogs_orders.text_orders_query")                                            															-- NPC	introduce categories
		for i=1,cs do
            add_script_dialog(1,base_id+1,"dialogs_orders.text_category_title_"..i,"dialogs_orders.has_category_"..i,"dialogs_orders.set_category_"..i)					-- ACTOR show categories
				base_id2 = base_id*1000
				add_script_dialog(base_id+1,base_id2,"dialogs_orders.text_item_offer_"..i)																				-- NPC introduce list
				for j=1,ls do
					add_script_dialog(base_id*1000,base_id2+1,"dialogs_orders.text_item_title_"..i..j,"dialogs_orders.has_item_"..i..j,"dialogs_orders.set_item_"..i..j)-- ACTOR show list
						add_script_dialog(base_id2+1,base_id2+2,"dialogs_orders.text_offer_item")																		-- NPC
							add_script_dialog(base_id2+2,base_id2+3,"dialogs_orders.text_accept_offer_item","dialogs_orders.has_prepay","dialogs_orders.give_prepay")	-- ACTOR
								add_script_dialog(base_id2+3,base_id2+4,"dialogs_orders.text_confirm_offer_item")														-- NPC
									add_dialog(base_id2+4,base_id2+5,"st_dm_orders_place_finish",nil,"dialogs.break_dialog")                              				-- ACTOR
							add_dialog(base_id2+2,base_id2+6,"st_dm_orders_no_money","dialogs_orders.hasnt_prepay")														-- ACTOR
							add_dialog(base_id2+2,base_id2+7,"st_dm_orders_none")                                            											-- ACTOR
					base_id2 = base_id2 + 10
				end
					add_dialog(base_id*1000,base_id*1000 + 99999,"st_dm_orders_none")																					-- ACTOR
            base_id = base_id + 2
		end
			add_dialog(1,99999,"st_dm_orders_none",nil,"dialogs.break_dialog")																							-- ACTOR
end

function dm_init_dynamic_orders_processing_dialog(dialog)
    saved_dialog = dialog

	add_dialog("",0,"st_dm_orders_query_pickup")																										-- ACTOR start processing order dialog
		-- complete purchase existing
		add_script_dialog(0,2000,"dialogs_orders.text_orders_item_pickup","dialogs_orders.has_ready_item")												-- NPC existing Order Pickup
			add_dialog(2000,2001,"st_dm_orders_pickup_existing_yes","dialogs_orders.has_item_cost")														-- ACTOR
				add_dialog(2001,2002,"st_dm_orders_pickup_finish",nil,"dialogs_orders.buy_item")														-- NPC
					add_dialog(2002,2003,"st_dm_orders_goodbye",nil,"dialogs.break_dialog")																-- ACTOR
			add_dialog(2000,2010,"st_dm_orders_pickup_existing_no")																						-- ACTOR
				add_dialog(2010,2011,"st_dm_orders_pickup_refuse_warning")																				-- NPC
					add_dialog(2011,2012,"st_dm_orders_pickup_refuse_penalty")																			-- ACTOR
						add_dialog(2012,2013,"st_dm_orders_pickup_refuse_penalty_reply",nil,"dialogs_orders.purchase_cancel")							-- NPC
							add_dialog(2013,2014,"st_dm_orders_goodbye",nil,"dialogs.break_dialog")														-- ACTOR
					add_dialog(2011,2015,"st_dm_orders_pickup_refuse_wait")																				-- ACTOR
						add_dialog(2015,2016,"st_dm_orders_pickup_refuse_wait_rely")																	-- NPC
							add_dialog(2016,2017,"st_dm_orders_goodbye",nil,"dialogs.break_dialog")														-- ACTOR
			add_dialog(2000,2020,"st_dm_orders_no_money","dialogs_orders.hasnt_item_cost")																-- ACTOR
				add_dialog(2020,2021,"st_dm_orders_pickup_hold")																						-- NPC
					add_dialog(2021,2022,"st_dm_orders_goodbye",nil,"dialogs.break_dialog")																-- ACTOR
			add_dialog(2000,2030,"st_dm_orders_pickup_ponder","dialogs_orders.has_item_cost")															-- ACTOR
				add_dialog(2030,2031,"st_dm_orders_pickup_ponder_reply")																				-- NPC
					add_dialog(2031,2032,"st_dm_orders_time_query_goodbye",nil,"dialogs.break_dialog")													-- ACTOR
        -- check and cancel ongoing order--
		add_script_dialog(0,1000,"dialogs_orders.text_processing_item","dialogs_orders.has_order_processing")											-- NPC Order processing
			add_dialog(1000,1001,"st_dm_orders_time_query")																								-- ACTOR
				add_dialog(1001,1002,"st_dm_orders_time_query_reply")																					-- NPC
					add_dialog(1002,1003,"st_dm_orders_time_query_goodbye")																				-- ACTOR
			add_dialog(1000,1010,"st_dm_orders_cancel")																									-- ACTOR
				add_dialog(1010,1011,"st_dm_orders_cancel_reply")																						-- NPC
					add_dialog(1011,1012,"st_dm_orders_cancel_reply_yes")																				-- ACTOR
						add_dialog(1012,1013,"st_dm_orders_cancel_reply_yes_done",nil,"dialogs_orders.purchase_cancel")									-- NPC
							add_dialog(1013,1014,"st_dm_orders_goodbye",nil,"dialogs.break_dialog")														-- ACTOR
					add_dialog(1011,1015,"st_dm_orders_cancel_reply_no")																				-- ACTOR
						add_dialog(1015,1016,"st_dm_orders_cancel_reply_no_done")																		-- NPC
							add_dialog(1016,1017,"st_dm_orders_goodbye",nil,"dialogs.break_dialog")														-- ACTOR
end
-----------------------------------------------------
-- Dynamic Ashot and Yar Dialog
-----------------------------------------------------
function dm_ashot_and_yar(a,b)
	local npc = dialogs.who_is_npc(a,b)

end

-- Upgraded by Holodilnik
-- Dialog structure for requesting dynamic task from honcho:
function dm_init_dynamic_task_dialog(dialog)
	saved_dialog = dialog
	local base_id = 0
	-- Actor requests task:
	add_dialog( "", (base_id + 0), ("st_ordered_task_query_" .. math.random( 1,5 )), nil, {"dialogs.generate_available_tasks"})
	-- Loop is necessary to allow skipping of unwanted tasks:
	for i = 1, 10 do
		-- NPC offers task:
		add_script_dialog((base_id + 0), (base_id + 1), "dialogs.text_npc_has_ordered_task_to_give")
			-- Actor require more details
			add_dialog((base_id + 1), (base_id + 2), ("st_task_more_info_" .. math.random( 1,5 )), {"dialogs.not_task_is_fetch_task", "dialogs.npc_has_ordered_task_to_give"})
				-- NPC tells more details about task
				add_script_dialog((base_id + 2), (base_id + 3), "dialogs.text_common_task")
					-- Actor accepts task
					add_dialog((base_id + 3), (base_id + 4), ("dm_universal_actor_take_task_" .. math.random( 1,5 )), nil, {"dialogs.npc_clear_skipped_tasks", "dialogs.npc_give_last_task_id"})
					-- Actor refuses task
					add_dialog((base_id + 3), (base_id + 5), ("dm_universal_actor_refuse_" .. math.random( 1,5 )))
			-- Actor require more details
			add_dialog((base_id + 1), (base_id + 6), ("st_task_more_info_" .. math.random( 1,5 )), {"dialogs.task_is_fetch_task", "dialogs.npc_has_ordered_task_to_give"})
				-- NPC explains fetch task
				add_script_dialog((base_id + 6), (base_id + 7), "dialogs.drx_sl_text_fetch_task")
					-- Actor accepts task
					add_dialog((base_id + 7), (base_id + 8), ("dm_universal_actor_take_task_" .. math.random( 1,5 )), nil, {"dialogs.npc_give_last_task_id", "dialogs.npc_clear_skipped_tasks"})
					-- Actor refuses task
					add_dialog((base_id + 7), (base_id + 9), ("dm_universal_actor_refuse_" .. math.random( 1,5 )))
			-- Actor refuses offered task and requests another
			add_dialog((base_id + 1), (base_id + 13), ("st_ordered_task_next_" .. math.random( 1,5 )), "dialogs.npc_has_task", "dialogs.npc_skip_task")
			-- Actor leaves NPC
			add_dialog((base_id + 1), (base_id + 11), ("dm_universal_actor_exit_" .. math.random( 1,5 )))
	
		base_id = (base_id + 13)
	end
end

-- Upgraded by Holodilnik
-- Dialog structure for requesting dynamic task from NPC:
function dm_init_sim_dynamic_task_dialog(dialog)
	saved_dialog = dialog
	local base_id = 0
	-- Actor requests dynamic task:
	add_dialog( "", (base_id + 0), ("st_ordered_task_query_" .. math.random( 1,5 )), nil, {"dialogs.sim_generate_available_tasks"})
	-- Loop is necessary to allow skipping of unwanted tasks:
	for i = 1, 10 do
		-- NPC offers task:
		add_script_dialog((base_id + 0), (base_id + 1), "dialogs.text_sim_npc_has_ordered_task_to_give")
			-- Actor require more details
			add_dialog((base_id + 1), (base_id + 2), ("st_task_more_info_" .. math.random( 1,5 )), {"dialogs.not_task_is_fetch_task", "dialogs.npc_has_ordered_task_to_give"})
				-- NPC tells more details about task
				add_script_dialog((base_id + 2), (base_id + 3), "dialogs.text_common_task")
					-- Actor accepts task
					add_dialog((base_id + 3), (base_id + 4), ("dm_universal_actor_take_task_" .. math.random( 1,5 )), nil, {"dialogs.npc_clear_skipped_tasks", "dialogs.npc_sim_give_last_task_id"})
					-- Actor refuses task
					add_dialog((base_id + 3), (base_id + 5), ("dm_universal_actor_refuse_" .. math.random( 1,5 )))
			-- Actor require more details
			add_dialog((base_id + 1), (base_id + 6), ("st_task_more_info_" .. math.random( 1,5 )), {"dialogs.task_is_fetch_task", "dialogs.npc_has_ordered_task_to_give"})
				-- NPC explains fetch task
				add_script_dialog((base_id + 6), (base_id + 7), "dialogs.drx_sl_text_fetch_task")
					-- Actor accepts task
					add_dialog((base_id + 7), (base_id + 8), ("dm_universal_actor_take_task_" .. math.random( 1,5 )), nil, {"dialogs.npc_sim_give_last_task_id", "dialogs.npc_clear_skipped_tasks"})
					-- Actor refuses task
					add_dialog((base_id + 7), (base_id + 9), ("dm_universal_actor_refuse_" .. math.random( 1,5 )))
 			-- Actor refuses task and requests another
 			add_dialog((base_id + 1), (base_id + 13), ("st_ordered_task_next_" .. math.random( 1,5 )), "dialogs.npc_has_task", "dialogs.npc_skip_task")
			-- Actor leaves NPC
			add_dialog((base_id + 1), (base_id + 11), ("dm_universal_actor_exit_" .. math.random( 1,5 )))

 		base_id = (base_id + 13)
 	end
end

-- Dialog structure for ending a task:
function dm_init_dynamic_task_completed_dialog(dialog)
	saved_dialog = dialog
	dialogs.sim_dynamic_task_completed_chance()
	-- Actor
	add_dialog( "", 0, ("st_ordered_task_query_finished_" .. math.random( 1,5 )))
		-- NPC
		add_script_dialog( 0, 1, "dialogs.text_npc_giving_reward")  
			-- Actor
			add_dialog( 1, 2, ("st_waiting_for_reward_" .. math.random( 1,5 )))  
				-- NPC
				add_script_dialog( 2, 3, "dialogs.text_task_finish", nil, "dialogs.npc_set_finished_task_complete")  
					-- Actor
					add_dialog( 3, 4, ("dm_universal_actor_exit_thanks_" .. math.random( 1,5 )))  
			-- Actor
			add_dialog( 1, 5, ("st_dont_need_money_" .. math.random( 1,5 )), nil, "dialogs.another_on_complete")  
				-- NPC
				add_script_dialog( 5, 6, "dialogs.text_task_another_reward", nil, {"dialogs.npc_on_another_reward", "dialogs.on_complete_without_reward"})  
					-- Actor
					add_dialog( 6, 7, ("dm_universal_actor_exit_thanks_" .. math.random( 1,5 )))  
end

-- Dialog structure for ending a simulation task:
function dm_init_sim_dynamic_task_completed_dialog(dialog)
	saved_dialog = dialog
	dialogs.sim_dynamic_task_completed_chance()
	-- Actor
	add_dialog( "", 0, ("st_ordered_task_query_finished_" .. math.random( 1,5 )))
		-- NPC
		add_script_dialog( 0, 1, "dialogs.text_npc_giving_reward")
			-- Actor
			add_dialog( 1, 2, ("st_waiting_for_reward_" .. math.random( 1,5 )))
				-- NPC
				add_script_dialog( 2, 3, "dialogs.text_sim_task_finish", nil, "dialogs.npc_sim_set_finished_task_complete")
					 -- Actor
					add_dialog( 3, 4, ("dm_universal_actor_exit_thanks_" .. math.random( 1,5 ))) 
			-- Actor
			add_dialog( 1, 5, ("st_dont_need_money_" .. math.random( 1,5 )), nil, "dialogs.another_on_complete")  
				-- NPC
				add_script_dialog( 5, 6, "dialogs.text_task_another_reward", nil, {"dialogs.npc_on_another_reward_sim", "dialogs.on_complete_without_reward_sim"})
					-- Actor
					add_dialog( 6, 7, ("dm_universal_actor_exit_thanks_" .. math.random( 1,5 )))
end

function dm_init_dynamic_task_cancel_dialog(dialog)
	saved_dialog = dialog
	local base_id = 0
	
	-- CANCEL TASKS
	add_dialog("",base_id,"st_ordered_task_query_cancel","dialogs.actor_has_ongoing_task")															-- ACTOR 

	for i=1,10 do
		add_script_dialog(base_id,base_id+1,"dialogs.text_npc_has_cancel_task")																		-- NPC     <---|
			add_script_dialog(base_id+1,base_id+2,"dialogs.text_actor_cancel_task","dialogs.npc_has_cancel_task","dialogs.npc_cancel_task")			-- ACTOR       |
				add_script_dialog(base_id+2,base_id+3,"dialogs.text_task_cancel")																	-- NPC         |
					add_dialog(base_id+3,base_id+4,"dm_universal_actor_exit_sorry")																	-- ACTOR       |
					                                                                                                                                --             |
			add_dialog(base_id+1,base_id+10,"st_ordered_task_query_cancel_next_job","dialogs.npc_has_cancel_task","dialogs.npc_skip_cancel_task")	-- ACTOR   --->|
			add_dialog(base_id+1,base_id+8,"dm_universal_actor_exit") 																				-- ACTOR
		base_id = base_id + 10
	end	
end

function dm_init_sim_dynamic_task_cancel_dialog(dialog)
	saved_dialog = dialog
	local base_id = 0
	
	-- CANCEL TASKS
	add_dialog("",base_id,"st_ordered_task_query_cancel","dialogs.sim_actor_has_ongoing_task")														-- ACTOR 

	for i=1,10 do
		add_script_dialog(base_id,base_id+1,"dialogs.text_npc_has_cancel_task")																		-- NPC     <---|
			add_script_dialog(base_id+1,base_id+2,"dialogs.text_actor_cancel_task","dialogs.npc_has_cancel_task","dialogs.npc_cancel_task")			-- ACTOR       |
				add_script_dialog(base_id+2,base_id+3,"dialogs.text_task_cancel")																	-- NPC         |
					add_dialog(base_id+3,base_id+4,"dm_universal_actor_exit_sorry")																	-- ACTOR       |
					                                                                                                                                --             |
			add_dialog(base_id+1,base_id+10,"st_ordered_task_query_cancel_next_job","dialogs.npc_has_cancel_task","dialogs.npc_skip_cancel_task")	-- ACTOR   --->|
			add_dialog(base_id+1,base_id+8,"dm_universal_actor_exit") 																				-- ACTOR
		base_id = base_id + 10
	end
end

-- Dialog structure for PDA broker:
function dm_init_dynamic_broker_dialog(dialog)

	saved_dialog = dialog

	add_dialog("",0,"st_broker_query") 																		-- Actor
		add_dialog(0,1,"st_broker_npc_start_"..math.random(1,3)) 											-- NPC
			add_script_dialog(1,2,"dialogs.text_actor_has_valuable_item","dialogs.condition_actor_has_valuable_item") -- Actor
				add_dialog(2,3,"st_broker_npc_answer_pda_query") 											-- NPC
					add_dialog(3,4,"st_broker_give_pda") 													-- Actor
						add_script_dialog(4,5,"dialogs.text_trade_npc_pda") 								-- NPC
--							add_dialog(5,0,"st_broker_query_more")											-- Actor
--							add_dialog(5,1111,"dm_universal_actor_exit_thanks")								-- Actor
			add_dialog(1,1111,"dm_universal_actor_exit") 													-- Actor

end

-----------------------------------------------------
-- Dynamic Yar and Ashot Dialog
-----------------------------------------------------
function dm_init_dynamic_ashot_and_yar_dialog(dialog)
	saved_dialog = dialog

	add_dialog("",0,"jup_b19_freedom_yar_task_1_dm_query")

	local script = add_dialog(0,1,"should not see this")
	script:SetScriptText("dialogs_jupiter.dm_ashot_and_yar_generate_dialog")
end

-----------------------------------------------------
-- Dynamic Repair Dialog
-----------------------------------------------------
function dm_init_dynamic_repair_dialog(dialog)
	saved_dialog = dialog

	add_dialog("",0,"st_mechanic_query_items")

	local script = add_dialog(0,1,"st_mechanic_repair_not_done","inventory_upgrades.dont_has_repaired_items")
	script:SetScriptText("inventory_upgrades.dm_repair_not_done")
	add_dialog(0,2,"st_mechanic_repair_done","inventory_upgrades.has_repaired_items","inventory_upgrades.give_repaired_items")
end

-----------------------------------------------------
-- Dynamic Surrender Dialog
-----------------------------------------------------
function dm_init_surrender_dialog(dialog)
	saved_dialog = dialog

	add_dialog("",0,"st_surrender_victim")

	add_dialog(0,1,"st_surrender_query_victim_4","dialogs.victim_is_bounty")
		add_script_dialog(1,9,"dialogs.surrender_victim_answers_bounty")
			add_dialog(9,20,"st_surrender_actor_2",nil,"dialogs.break_dialog")
			add_dialog(9,21,"st_surrender_actor_3",nil,"dialogs.break_dialog")
			
	add_dialog(0,2,"st_surrender_query_victim_1")
		add_script_dialog(2,10,"dialogs.surrender_victim_answers_1")
			add_dialog(10,20,"st_surrender_actor_2",nil,"dialogs.break_dialog")
			add_dialog(10,21,"st_surrender_actor_3",nil,"dialogs.break_dialog")

	add_dialog(0,3,"st_surrender_query_victim_2")
		add_script_dialog(3,11,"dialogs.surrender_victim_answers_1")
			add_dialog(11,20,"st_surrender_actor_2",nil,"dialogs.break_dialog")
			add_dialog(11,21,"st_surrender_actor_3",nil,"dialogs.break_dialog")

	add_dialog(0,4,"st_surrender_query_victim_3")
		add_script_dialog(4,12,"dialogs.surrender_victim_answers_2")
			add_dialog(12,20,"st_surrender_actor_1",nil,"dialogs.break_dialog")
end


-- End Alundaio
-----------------------------------------------------------------------------

-- Generate id for phrase
function get_id()
	id_counter = id_counter + 1
	return id_counter
end

-- Parse ini file and store all phrases and their parameters into phrase table
function fill_phrase_table()
	local cfg = ini_file_ex("misc\\dialog_manager.ltx")
	local function itr(section)
		local val = cfg:r_value(section,"category") or "default"
		local category = (val == "hello" or val == "anomalies" or val == "place" or val == "job" or val == "information" or val == "tips") and val or "default"
		if (category ~= "default") then 
			local temp_table = {}
			temp_table.info = {}
			temp_table.id = tostring(get_id())
			temp_table.name = section
			
			local temp = cfg:r_value(section,"npc_community")
			temp_table.npc_community = temp and parse_names(temp) or "not_set"
			
			temp = cfg:r_value(section,"npc_rank")
			temp_table.npc_rank = temp and parse_names(temp) or "not_set"
			temp = cfg:r_value(section,"actor_community")
			temp_table.actor_community = temp and parse_names(temp) or "not_set"
			
			temp = cfg:r_value(section,"actor_rank")
			temp_table.actor_rank = temp and parse_names(temp) or "not_set"
			temp = cfg:r_value(section,"level")
			temp_table.level = temp and parse_names(temp) or "not_set"
			
			temp_table.once = tostring(cfg:r_value(section,"once",1)) or "always"
			temp_table.wounded = tostring(cfg:r_value(section,"wounded",1)) or "false"

			temp = cfg:r_value(section,"info")
			if (temp and temp ~= "") then
				xr_logic.parse_infop1(temp_table.info, temp)
			end

			temp_table.smart = cfg:r_value(section,"smart") or ""

			phrase_table[category][temp_table.id] = temp_table
		end
		return false
	end 
	
	cfg.ini:section_for_each(itr)
end

-- Initialize npc start dialog
function init_start_dialogs(dialog, str)
	saved_dialog = dialog
	--cond_list = empty_table(cond_list)

	add_dialog("",0,"")
	add_dialog(0,1,"",nil,"dialog_manager.fill_priority_"..str.."_table")

	local ph
	local p,d
	local script
	for k,v in pairs(phrase_table[str]) do
		if (v.wounded == "true") then
			script = add_dialog(1,v.id,v.name,{"dialogs.is_wounded","dialogs.not_is_psy_wounded","dialog_manager.precondition_"..str.."_dialogs"},"dialog_manager.action_"..str.."_dialogs")
			if (script) then
				ph = true
				add_dialog(v.id,get_id(),"dm_wounded_medkit",{"dialogs.actor_have_medkit"},{"dialogs.transfer_medkit","dialogs.break_dialog"})
				add_dialog(v.id,get_id(),"dm_wounded_sorry",nil,"dialogs.break_dialog")
			end
		else
			add_dialog(1,v.id,v.name,{"dialogs.is_not_wounded","dialog_manager.precondition_"..str.."_dialogs"},"dialog_manager.action_"..str.."_dialogs")
			ph = true
		end
	end
	
	-- Psy wound dialog
	script = add_dialog(1,2,"dm_psy_wounded",{"dialogs.is_psy_wounded"})
	if (script) then
		ph = true
		add_dialog(2,get_id(),"dm_psy_wounded_medkit",nil,{"dialogs.give_medkit_no_transfer","dialogs.break_dialog"})
		add_dialog(2,get_id(),"dm_psy_wounded_sorry",nil,"dialogs.break_dialog")
	end

	if not(ph) then
		add_dialog(1,2,"dm_" .. str .. "_general" .. add)
	end
end

-- Initialize new actor dialog
function init_new_dialog(dialog)
	local actor_table = { "job", "anomalies", "information", "tips" }

	saved_dialog = dialog
	add_dialog("",0,"dm_universal_actor_start")
	add_dialog(0,1,"dm_universal_npc_start_"..math.random(1,4))

	local ph,id,str

	for i = 1,4 do
		local id = get_id()
		str = actor_table[i]

		add_dialog(1,id,"dm_"..str.."_general_"..math.random(1,3),nil,"dialog_manager.fill_priority_"..str.."_table")
			local id2 = get_id()
			add_dialog(id,id2,"dm_no_more_"..math.random(1,10),"dialog_manager.precondition_"..str.."_dialogs_no_more")
			add_dialog(id,id2,"dm_do_not_know_"..math.random(1,10),"dialog_manager.precondition_"..str.."_dialogs_do_not_know")

		for k,v in pairs(phrase_table[str]) do
			ph = true
			add_dialog(id,v.id,v.name,"dialog_manager.precondition_"..str.."_dialogs","dialog_manager.action_"..str.."_dialogs")
		end

		if not (ph) then
			add_dialog(id,id2,"dm_"..str.."_do_not_know_"..math.random(1,3))
		end
	end
	add_dialog(1,get_id(),"dm_universal_actor_exit")
end

-- Fill selected priority table
function fill_priority_table(npc, PT_subtable, PRT_subtable)
	local npc_id = npc:id()
	if(PRT_subtable[npc_id]==nil) then
		PRT_subtable[npc_id] = {}
	end

	for num, phrase in pairs(PT_subtable) do
		if (phrase) then
			calculate_priority(PRT_subtable, phrase, npc, phrase.id)
		end
	end
end

function is_told(npc, str)
	local id = npc:id()
	if (priority_table[str] == nil or priority_table[str][id] == nil) then
		return true
	end
	if priority_table[str][id].told == true then
		return true
	end
	return false
end
-- Calculate precondition for default phrase in information dialog
function precondition_no_more(npc, str, phrase_id)
	local id = npc:id()
	if (priority_table[str] == nil or priority_table[str][id] == nil) then
		return true
	end

	local pr, id = get_highest_priority_phrase(phrase_table[str], priority_table[str], npc, phrase_id)
	if(pr<0) or (id==0) then
		printf("there is no avaliable "..str.." dialogs")
		return true
	end

	if (PRT_subtable[id][phrase_id] == nil or PRT_subtable[id][phrase_id] == -1) then
		return true
	end

	return false
end

-- Calculate phrase's preconditions
function precondition(npc, PT_subtable, PRT_subtable, phrase_id,dialog_name)
	if not (phrase_id) then
		printf("dialog_manager: no pharse_id for dialog %s",dialog_name)
	end

	if not (PRT_subtable[npc:id()]) then
		--printf("dialog_manager:Error:No PRT_subtable for %s with phrase_id=%s and dialog_name=%s",npc:name(),phrase_id,dialog_name)
		reset_phrase_priority(PT_subtable, PRT_subtable, npc, phrase_id)
		return false
	end

	if PRT_subtable[npc:id()] and PRT_subtable[npc:id()].told and PRT_subtable[npc:id()].told == true then
		return false
	end
-- recalculate current phrase priority
	local priority = calculate_priority(PRT_subtable, PT_subtable[phrase_id], npc, phrase_id)
-- if current phrase is with highest priority - show it
	return is_highest_priority_phrase(PT_subtable, PRT_subtable, npc, phrase_id)
end

-- Calculate phrase priority
function calculate_priority(PRT_subtable, PTID_subtable, npc, phrase_id)
	if not (PTID_subtable) then
		return
	end

	local f_level = false
	local f_comm = false
	local priority = -1
	local npc_id = npc:id()

	if(PTID_subtable.npc_community=="not_set") then
		f_comm = true
	elseif(PTID_subtable.npc_community[1]=="all") then
		priority = priority + 1
		f_comm = true
	else
		for i=1,#PTID_subtable.npc_community do
			if(PTID_subtable.npc_community[i]==character_community(npc)) then
				priority = priority + 2
				f_comm = true
				break
			end
		end
		priority = priority - 1
	end

	if(PTID_subtable.level=="not_set") then
		f_level = true
	elseif(PTID_subtable.level[1]=="all") then
		priority = priority + 1
		f_level = true
	else
		for i=1,#PTID_subtable.level do
			if(PTID_subtable.level[i]==level.name()) then
				priority = priority + 2
				f_level = true
				break
			end
		end
	end

	if(PTID_subtable.actor_community=="not_set") then
		priority = priority + 0
	elseif(PTID_subtable.actor_community=="all") then
		priority = priority + 1
	else
		for i=1,#PTID_subtable.actor_community do
			if(PTID_subtable.actor_community[i]==character_community(db.actor)) then
					priority = priority + 2
				break
			end
		end
	end
	
	if(PTID_subtable.actor_rank=="not_set") then
		priority = priority + 0
	elseif(PTID_subtable.actor_rank=="all") then
		priority = priority + 1
	else
		ranks.read_all_ranks()
		for i=1,#PTID_subtable.actor_rank do
			if(PTID_subtable.actor_rank[i]==ranks.get_se_obj_rank_name(db.actor)) then
					priority = priority + 2
				break
			end
		end
	end
	
	if(PTID_subtable.npc_rank=="not_set") then
		priority = priority + 0
	elseif(PTID_subtable.npc_rank=="all") then
		priority = priority + 1
	else
		ranks.read_all_ranks()
		for i=1,#PTID_subtable.npc_rank do
			if(PTID_subtable.npc_rank[i]==ranks.get_se_obj_rank_name(npc)) then
					priority = priority + 2
				break
			end
		end
	end

	if(PTID_subtable.wounded=="true") then
		if not(xr_wounded.is_wounded(npc)) then
			priority = -1
		else
			priority = priority + 1
		end
	else
		if(xr_wounded.is_wounded(npc)) then
			priority = -1
		else
			priority = priority + 1
		end
	end

	if f_comm == false or f_level == false then
		priority = -1
	end

	if(PRT_subtable[npc_id].ignore_once) then
		if(PTID_subtable.once=="true") then
			priority = -1
		end
	end

	if(PRT_subtable[npc_id][phrase_id]~=nil) and (PRT_subtable[npc_id][phrase_id]==255) then
-- if there was set the highest priority for phrase
		priority = 255
	end

	for k,v in pairs(PTID_subtable.info) do
		if v.name then
			if v.required == true then
				if not has_alife_info(v.name) then
					priority = -1
					break
				end
			else
				if has_alife_info(v.name) then
					priority = -1
					break
				end
			end
		end
	end


	PRT_subtable[npc_id][phrase_id] = priority
	return priority
end

-- Set phrase end action
function told(PRT_subtable, npc)
	PRT_subtable[npc:id()].told = true
end

function action(PT_subtable, PRT_subtable, cur_phrase_id, npc)
	if not(PRT_subtable[npc:id()].ignore_once) then
		if(PT_subtable[cur_phrase_id].once=="true") then
			set_phrase_highest_priority(PT_subtable,PRT_subtable, npc, cur_phrase_id)
		end
		PRT_subtable[npc:id()].ignore_once = true
	end
end

-- Set the highest priority to selected phrase
function set_phrase_highest_priority(PT_subtable, PRT_subtable, npc, phrase_id)
	local npc_id = npc:id()
	if(PRT_subtable[npc_id]~=nil) then
		PRT_subtable[npc_id][phrase_id] = 255
	else
		PRT_subtable[npc_id] = {}
		PRT_subtable[npc_id][phrase_id] = 255
	end
end

-- Reset phrase priority
function reset_phrase_priority(PT_subtable, PRT_subtable, npc, phrase_id)
	if not (phrase_id) then
		return
	end

	local npc_id = npc:id()
	if(PRT_subtable[npc_id]) then
		PRT_subtable[npc_id][phrase_id] = -1
	else
		PRT_subtable[npc_id] = {}
		PRT_subtable[npc_id][phrase_id] = calculate_priority(PRT_subtable, PT_subtable[phrase_id], npc, phrase_id)
	end
end

-- Is the phrase priority the highest?
function is_highest_priority_phrase(PT_subtable, PRT_subtable, npc, phrase_id)
	local npc_id = npc:id()
	if(PRT_subtable[npc_id]~=nil) then
-- if there is a subtable for this npc
		local id = phrase_id
		local pr = PRT_subtable[npc_id][phrase_id]
		if pr == nil or pr < 0 then
			return false
		end
		for phr_id, priority in pairs(PRT_subtable[npc_id]) do
-- iterate through array to get if selected phrase is with the highest priority
			if(phr_id~="ignore_once" and phr_id~="told") then
				if(priority>pr) then
					return false
				end
			end
		end
		return true
	else
		-- if there is no subtable for this npc - create it
		reset_phrase_priority(PT_subtable, PRT_subtable, npc, phrase_id)
		return false
	end
end

-- Get the phrase with the highest priority
function get_highest_priority_phrase(PT_subtable, PRT_subtable, npc, phrase_id)
	local npc_id = npc:id()
	if(PRT_subtable[npc_id]) then
		-- if there is a subtable for this npc
		local id = 0
		local pr = -1
		for phr_id, priority in pairs(PRT_subtable[npc_id]) do
			-- iterate through array for the highest priority phrase
			if(phr_id~="ignore_once" and phr_id~="told") then
				if(priority>pr) then
					pr = priority
					id = phr_id
				end
			end
		end
		return pr, id
	else
		-- if there is no subtable for this npc - create it
		reset_phrase_priority(PT_subtable, PRT_subtable, npc, phrase_id)
		return -1, 0
	end
end
--------------------------------------------------------------------------------
-- Initializing, filling priority tables, setting preconditions and actions
--------------------------------------------------------------------------------
-- Initialize npc hello start dialog
function init_hello_dialogs(dialog)
	init_start_dialogs(dialog, "hello")
end

-- Fill phrase priority table for hello start dialog
function fill_priority_hello_table(actor, npc, dialog_name, phrase_id)
	fill_priority_table(npc, phrase_table.hello, priority_table.hello)
end

-- Fill phrase priority table for new dialog
function fill_priority_job_table(actor, npc, dialog_name, phrase_id)
	fill_priority_table(npc, phrase_table.job, priority_table.job)
end
function fill_priority_anomalies_table(actor, npc, dialog_name, phrase_id)
	fill_priority_table(npc, phrase_table.anomalies, priority_table.anomalies)
end
--function fill_priority_place_table(actor, npc, dialog_name, phrase_id)
--	fill_priority_table(npc, phrase_table.place, priority_table.place)
--end
function fill_priority_information_table(actor, npc, dialog_name, phrase_id)
	fill_priority_table(npc, phrase_table.information, priority_table.information)
end

function fill_priority_tips_table(actor, npc, dialog_name, phrase_id)
	fill_priority_table(npc, phrase_table.tips, priority_table.tips)
end

-- Calculate precondition for phrases in hello start dialog
function precondition_hello_dialogs(npc, actor, dialog_name, parent_id, id)
	--printf("hello")
	return precondition(npc, phrase_table.hello, priority_table.hello, id,dialog_name)
end
-- Set phrase end action for hello start dialog
function action_hello_dialogs(npc, actor, dialog_name, id)
	action(phrase_table.hello, priority_table.hello, id, npc)
end

-- Calculate precondition for default phrase in occupation dialog
function precondition_job_dialogs_no_more(npc, actor, dialog_name, parent_id, id)
	if is_told(npc, "job") == true then
		return true
	end
	return false
end

function precondition_job_dialogs_do_not_know(npc, actor, dialog_name, parent_id, id)
	return precondition_no_more(npc, "job", id)
end

-- Calculate preconditions for phrases in occupation dialog
function precondition_job_dialogs(npc, actor, dialog_name, parent_id, id)
	--printf("job")
	return precondition(npc, phrase_table.job, priority_table.job, id,dialog_name)
end
-- Set phrase end action for occupation dialog
function action_job_dialogs(npc, actor, dialog_name, id)
	action(phrase_table.job, priority_table.job, id, npc)
	told(priority_table.job, npc)
end

-- Calculate precondition for default phrase in anomalies dialog
function precondition_anomalies_dialogs_no_more(npc, actor, dialog_name, parent_id, id)
	if is_told(npc, "anomalies") == true then
		return true
	end
	return false
end

function precondition_anomalies_dialogs_do_not_know(npc, actor, dialog_name, parent_id, id)
	return precondition_no_more(npc, "anomalies", id)
end
-- Calculate preconditions for phrases in anomalies dialog
function precondition_anomalies_dialogs(npc, actor, dialog_name, parent_id, id)
	local smart = xr_gulag.get_npc_smart(npc)
	if priority_table.anomalies and priority_table.anomalies[npc:id()] and smart ~= nil and tostring(smart:name()) == phrase_table.anomalies[id].smart then
		priority_table.anomalies[npc:id()][id] = -1
		return false
	end
	--printf("anomalies")
	return precondition(npc, phrase_table.anomalies, priority_table.anomalies, id,dialog_name)
end
-- Set phrase end action for information dialog
function action_anomalies_dialogs(npc, actor, dialog_name, id)
	action(phrase_table.anomalies, priority_table.anomalies, id, npc)
	told(priority_table.anomalies, npc)
end

-- Calculate precondition for default phrase in information dialog
function precondition_information_dialogs_no_more(npc, actor, dialog_name, parent_id, id)
	if is_told(npc, "information") == true then
		return true
	end
	return false
end

function precondition_information_dialogs_do_not_know(npc, actor, dialog_name, parent_id, id)
	return precondition_no_more(npc, "information", id)
end
-- Calculate preconditions for phrases in information dialog
function precondition_information_dialogs(npc, actor, dialog_name, parent_id, id)
	--printf("info")
	return precondition(npc, phrase_table.information, priority_table.information, id,dialog_name)
end
-- Set phrase end action for information dialog
function action_information_dialogs(npc, actor, dialog_name, id)
	action(phrase_table.information, priority_table.information, id, npc)
	told(priority_table.information, npc)
end

-- Tips
-- Calculate precondition for default phrase in information dialog
function precondition_tips_dialogs_no_more(npc, actor, dialog_name, parent_id, id)
	if is_told(npc, "tips") == true then
		return true
	end
	return false
end

function precondition_tips_dialogs_do_not_know(npc, actor, dialog_name, parent_id, id)
	return precondition_no_more(npc, "tips", id)
end
-- Calculate preconditions for phrases in tips dialog
function precondition_tips_dialogs(npc, actor, dialog_name, parent_id, id)
	--printf("tips")
	return precondition(npc, phrase_table.tips, priority_table.tips, id,dialog_name)
end
-- Set phrase end action for tips dialog
function action_tips_dialogs(npc, actor, dialog_name, id)
	action(phrase_table.tips, priority_table.tips, id, npc)
	told(priority_table.tips, npc)
end

local rnd = 0

function precondition_is_phrase_disabled(fs,ss,dn,ppi,pi)
	local npc = dialogs.who_is_npc(fs, ss)
	if(pi=="") then
		pi = dn
	end
	if (disabled_phrases[npc:id()] and disabled_phrases[npc:id()][pi]) or
		 (quest_disabled_phrases[npc:id()] and quest_disabled_phrases[npc:id()][pi]) then
		return false
	else
		return true
	end
end

function action_disable_phrase(fs,ss,dn,pi)
	local npc = dialogs.who_is_npc(fs, ss)
	if(pi=="0") then
		pi = dn
	end
	if(disabled_phrases[npc:id()]==nil) then
		disabled_phrases[npc:id()] = {}
	end
	disabled_phrases[npc:id()][pi] = true
end

function action_disable_quest_phrase(fs,ss,dn,pi)
	local npc = dialogs.who_is_npc(fs, ss)
	if(pi=="0") then
		pi = dn
	end
	if(quest_disabled_phrases[npc:id()]==nil) then
		quest_disabled_phrases[npc:id()] = {}
	end
	quest_disabled_phrases[npc:id()][pi] = true
end

function create_bye_phrase()
	return game.translate_string("actor_break_dialog_"..RandomVal)
end

function uni_dialog_precond(first_speaker, second_speaker)
	local npc = dialogs.who_is_npc(first_speaker, second_speaker)
	return character_community(npc) ~= "zombied" and character_community(npc) ~= "monolith"
end
