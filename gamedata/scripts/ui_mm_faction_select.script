-- Faction Select for Call of Chernobyl by Alundaio
-- Remade by Tronex as Fresh Start Menu 2018/7/17
-- Reworked for A.R.E.A by Surs and Holodilnik

local ico_size = 0.7
local ico_width = (device().width / device().height > (1024/768+0.01)) and 0.8 or 1
local ini_ico = ini_file("plugins\\player_portraits.ltx")
local ini_itm = ini_file("plugins\\player_loadouts.ltx")
local ini_map = ini_file("plugins\\player_start_locations.ltx")
local ini_opt = ini_file("plugins\\player_options.ltx")
local ini_cond = ini_file("plugins\\player_conditions.ltx")
local gs = game.translate_string
local loc_ini = nil		   
local allow_level = 0

local spawn_path, start_pos
local game_data = {}

function on_game_load(binder)
	if (not USE_MARSHAL) then return end
	local config = axr_main.config
	local need_save
	local m_data = alife_storage_manager.get_state()
	if (config:r_value("character_creation","new_game_hardcore_mode",1) == true) then
		m_data.uuid = GAME_VERSION .. "_" .. tostring(math.random(100)) .. tostring(math.random()) .. tostring(math.random(1000))
		m_data.death_limit = config:r_value("character_creation","new_game_hardcore_mode_lives",2) or 1
		config:w_value("character_creation","new_game_hardcore_mode")
		config:w_value("character_creation","new_game_hardcore_mode_lives")
		need_save = true
	end
	if (config:r_value("character_creation","new_game_survival_mode",1) == true) then
		m_data.enable_survival_mode = true
		config:w_value("character_creation","new_game_survival_mode")
		need_save = true
	end
	if (config:r_value("character_creation","new_game_azazel_mode",1) == true) then
		m_data.enable_azazel_mode = true
		config:w_value("character_creation","new_game_azazel_mode")
		need_save = true
	end
	if (config:r_value("character_creation","new_game_timer_mode",2)) then
		m_data.enable_timer_mode = config:r_value("character_creation","new_game_timer_mode",2)
		config:w_value("character_creation","new_game_timer_mode")
		need_save = true
	end
	
	local rank = config:r_float_ex("character_creation", "new_game_rank") or -1
	if rank >= 0 then
		db.actor:set_character_rank(rank)
		config:w_value("character_creation","new_game_rank", -1)
		need_save = true
	end
	
	local se_actor = alife():actor()
	-- NEW CHARACTER NAME
	local character_name = config:r_value("character_creation","new_game_character_name",3) or ""
	if (character_name and character_name ~= "") then
		config:w_value("character_creation","new_game_character_name")
		need_save = true
		character_name = character_name:gsub("_"," ")
		se_actor:set_character_name(character_name)
	end
		
	-- Icon
	local character_icon = config:r_value("character_creation","new_game_icon",3)
	if (character_icon and character_icon ~= "") then
		db.actor_binder.character_icon = character_icon
		config:w_value("character_creation","new_game_icon")
		need_save = true
	end
	
	-- Faction
	local faction = config:r_value("character_creation","new_game_faction",3) or ""
	-- Check if DRX Questlines addon is available
	local drx_ini = ini_file("misc\\task_manager.ltx")
	local drx = drx_ini:section_exist("drx_sl_find_wish_granter_task") and true or false
	
	if (faction and faction ~= "") then
		config:w_value("character_creation","new_game_faction")
		need_save = true
		alun_utils.save_var( db.actor, "area_game_faction_position", start_location)
		-- Faction Spawn Position
		local start_location = config:r_value("character_creation", "new_game_map")
		config:w_value("character_creation","new_game_map")
		alun_utils.save_var( db.actor, "area_game_faction_position", start_location)
		if start_location and start_location ~= "" then
			local loc_ini = ini_file("plugins\\player_start_locations.ltx")
			local number = nil
			local positions_count = loc_ini:r_float_ex(start_location, "count") or 1

			if (positions_count ~= 1) then
				number = math.random(1,positions_count)
			end
			
			start_pos = {}
			
			if (number ~= nil) then
				table.insert(start_pos,loc_ini:r_float_ex(start_location, "lvid_" .. number))
				table.insert(start_pos,loc_ini:r_float_ex(start_location, "gvid_" .. number))
				table.insert(start_pos,vector():set(loc_ini:r_float_ex(start_location,"x_" .. number),loc_ini:r_float_ex(start_location,"y_" .. number),loc_ini:r_float_ex(start_location,"z_" .. number)))
			else
				table.insert(start_pos,loc_ini:r_float_ex(start_location, "lvid"))
				table.insert(start_pos,loc_ini:r_float_ex(start_location, "gvid"))
				table.insert(start_pos,vector():set(loc_ini:r_float_ex(start_location,"x"),loc_ini:r_float_ex(start_location,"y"),loc_ini:r_float_ex(start_location,"z")))
			end
		else
			spawn_path = nil  --patrol("spawn_player_"..faction)
		end
			
		-- Determine total number of storyline tasks to complete for this game:
		alun_utils.save_var( db.actor, "drx_sl_total_task_number", math.random(10,15))  -- Set to range of total meet honcho tasks to complete to finish game
		alun_utils.save_var( db.actor, "drx_sl_current_task_number", 1 )

		config:w_value("character_creation","new_game_story_mode") -- clear value
		-- Unlock the encyclopedia at the beginning of the game if toggled.
		if (config:r_value("character_creation", "new_game_unlocked_guide", 1) == true) then
			give_info("guide_cheated")
		end
		config:w_value("character_creation","new_game_unlocked_guide") -- clear value

		db.actor:set_character_community("actor_" .. faction, 0, 0)
		
		-- Reset player goodwill
 		game_relations.set_community_goodwill_for_faction("actor_"..faction)

		-- money and loadout
		local loadout = config:r_value("character_creation","new_game_loadout",3) or ""
		if (loadout and loadout ~= "") then
			config:w_value("character_creation","new_game_loadout")
			local sim = alife()
			local t = loadout:to_table()
			for i=1,#t do
				local kv_pair = t[i]:to_table("=")
				if (kv_pair[1]) then
					kv_pair[2] = tonumber(kv_pair[2]) or 1
					if (kv_pair[1] == "money") then
						money_max = kv_pair[2]
					elseif (INI:section_exist(kv_pair[1])) then
						for ii=1,kv_pair[2] do
							sim:create(kv_pair[1],db.actor:position(),db.actor:level_vertex_id(),db.actor:game_vertex_id(),0)
						end
					end
				end
			end
			
			if (axr_main.config:r_value("mm_options","enable_ambient_radiation",1,false) == true) then
				sim:create("helm_respirator",db.actor:position(),db.actor:level_vertex_id(),db.actor:game_vertex_id(),0)
			end
			if (axr_main.config:r_value("mm_options","enable_only_campfire",1,false) == true) then
				sim:create("matches",db.actor:position(),db.actor:level_vertex_id(),db.actor:game_vertex_id(),0)
			end
		end
		local traits = axr_main.config:r_value("character_creation","new_game_traits",3) or ""
		if traits and traits ~= "" then
			alife_storage_manager.get_state().traits = traits
			axr_main.config:w_value("character_creation","new_game_traits")
		end
		
		se_actor:set_profile_name("actor_"..faction)
		
		local money = config:r_value("character_creation","new_game_money")
		if money then
			db.actor:give_money(-db.actor:money()+money)
			config:w_value("character_creation","new_game_money")
		end

		-- mlr
		if not mlr_utils.load_var('transitions_faction') then
			mlr_utils.save_var('transitions_faction', faction)
		end
	end

	if (need_save) then
		config:save()
	end
end

local function actor_on_first_update(binder,delta)
	if (spawn_path) then
		start_pos = {}
		start_pos[1] = spawn_path:level_vertex_id(0)
		start_pos[2] = spawn_path:game_vertex_id(0)
		start_pos[3] = spawn_path:point(0)
	end

	local faction = character_community(db.actor):sub(7)

	-- Survival mode
	if (IsSurvivalMode()) then
		if (faction == "zombied") then
			game_relations.change_factions_community_num("zombied",0,-5000)
			game_relations.change_factions_community_num("monolith",0,-5000)
		elseif (faction == "monolith") then
			game_relations.change_factions_community_num("zombied",0,-5000)
		end
		if (INI:section_exist("survival_squad_"..faction) and start_pos) then
			local sim = alife()
			local squad = sim:create("survival_squad_"..faction,start_pos[3],start_pos[1],start_pos[2])
			if (squad) then
				axr_companions.companion_squads[squad.id] = squad
				squad:create_npc(nil,start_pos[3],start_pos[1],start_pos[2])
				local as
				for k in squad:squad_members() do
					local se_obj = k.object or k.id and sim:object(k.id)
					if (se_obj) then
						game_relations.change_factions_community_num("zombied",k.id,-5000)
						SIMBOARD:setup_squad_and_group(se_obj)

						utils.se_obj_save_var(se_obj.id,se_obj:name(),"companion",true)
						utils.se_obj_save_var(se_obj.id,se_obj:name(),"companion_cannot_dismiss",true)
					end
				end
			end
		end
	end

	if start_pos and #start_pos == 3 then
		ChangeLevel(start_pos[3],start_pos[1],start_pos[2],VEC_ZERO)
	end
end

local function actor_on_before_death() -- Ironman: second wind
	if not (USE_MARSHAL) then
		return
	end
	
	local uuid = alife_storage_manager.get_state().uuid
	if not (uuid) then
		return -- not in hardcore mode
	end
	
	local fs = getFS()
	local flist = fs:file_list_open_ex("$game_saves$",bit_or(FS.FS_ListFiles,FS.FS_RootOnly),"*.scoc")
	local f_cnt = flist:Size()

	for	it=0, f_cnt-1 	do
		local file = flist:GetAt(it)
		local file_name = string.sub(file:NameFull(), 0, (string.len(file:NameFull()) - string.len(".scoc")))

		--printf("file_name = %s",file_name)
		local path = fs:update_path('$game_saves$', '')..file_name..".scoc"
		local f = io.open(path,"rb")
		if (f) then
			local data = f:read("*all")
			f:close()
			if (data) then
				local decoded = alife_storage_manager.decode(data)
				if (decoded and decoded.uuid == uuid) then
					decoded.death_limit = decoded.death_limit or 3
					decoded.death_count = (decoded.death_count or 0) + 1
					if (decoded.death_count >= decoded.death_limit) then
						ui_load_dialog.delete_save_game(file_name)	
					else
						local f = io.open(path,"wb")
						if (f) then
							local encoded = marshal.encode(decoded)
							if (encoded) then 
								f:write(encoded)
							end
							f:close()
						end
					end
				end
			end
		end
	end
end

------------------
function on_game_start()
	RegisterScriptCallback("on_game_load",on_game_load)
	RegisterScriptCallback("actor_on_before_death", actor_on_before_death)
	RegisterScriptCallback("actor_on_first_update", actor_on_first_update)
end

--------------------------------------------------------------
-- faction_ui
--------------------------------------------------------------

class "faction_ui" (CUIScriptWnd)

function faction_ui:__init(owner) super()
	self.owner = owner

	-- Tables
	self.table_faction = {"stalker","bandit","csky","dolg","freedom","killer","army","ecolog","monolith"}
	self.table_icon = {}
	self.table_map = {}
	self.map_attr = {}
	self.table_loadout = {}
	self.table_inv = {}
	
	self.table_hardcore_lives = {}
	local n = ini_opt:line_count("new_game_hardcore_lives") or 0
	for i=0, n-1 do
		local result, id, value = ini_opt:r_line("new_game_hardcore_lives",i,"","" )
		local t = value:to_table()
		local size = #self.table_hardcore_lives + 1
		self.table_hardcore_lives[size] = {}
		self.table_hardcore_lives[size][1] = tonumber(t[1])
		self.table_hardcore_lives[size][2] = tostring(t[2])
	end
	
	self.table_timer = {{nil,"st_off"}}
	local n = ini_opt:line_count("new_game_timer") or 0
	for i=0, n-1 do
		local result, id, value = ini_opt:r_line("new_game_timer",i,"","" )
		local t = value:to_table()
		local size = #self.table_timer + 1
		self.table_timer[size] = {}
		self.table_timer[size][1] = tonumber(t[1])
		self.table_timer[size][2] = tostring(t[2])
	end
	-- initialize start location info
	self.selected_faction = self.table_faction[1]
	
	-- Selected choices
	self:ResetMoney()
	self.selected_icon = nil
	self.selected_map = nil
	self.selected_hardcore_lives = self.table_hardcore_lives[1]
	self.selected_timer = self.table_timer[1]
	self.cond_start = ini_cond:r_float_ex("points","total_points") or 12
	self.cond_left = self.cond_start
	self.cond_used = 0
	self.rank_start = math.random(10,50)
	self.rank = self.rank_start
	
	-- Utility
	self.access	= true
	
	-- Prepare
	self:SetWndRect(Frect():set(0,0,1024,768))
	self:Enable(true)

	local xml = CScriptXmlInit()
	self.xml = xml
	xml:ParseFile("ui_mm_faction_select.xml")

	xml:InitStatic("background", self)
	
	-- Main
	self:Main_Controls()
	self:Main_CallBacks()
	
	-- Faction Select
	self:PopupFaction_Controls()
	self:PopupFaction_Callbacks()
	self:PopupFaction_Show(false)
	
	-- Icon Select
	self:PopupIcon_Controls()
	self:PopupIcon_Callbacks()
	self:PopupIcon_Show(false)
end

function faction_ui:__finalize()

end

function faction_ui:Main_Controls()
	local xml = self.xml
	
	-- Background
	self.dialog = xml:InitStatic("main_dialog:frame_back", self)
	
	-- Boxes
	self.box_faction = xml:InitStatic("main_dialog:box_faction",self.dialog)
	self.box_icon = xml:InitStatic("main_dialog:box_icon",self.dialog)
	self.box_item = xml:InitStatic("main_dialog:box_item",self.dialog)
	self.box_item_temp = xml:InitStatic("main_dialog:box_item",self.dialog)
	
	-- Main frame
	self.main_frame = xml:InitStatic("main_dialog:frame_front",self.dialog)
	
	-- Interactive Text
	self.text_descr = xml:InitTextWnd("main_dialog:text_descr",nil)
	self.scroll_desc = xml:InitScrollView("main_dialog:scroll_desc", self.dialog)
	self.scroll_desc:AddWindow(self.text_descr, true)
	self.text_descr:SetAutoDelete(false)
	
	self.character_name = xml:InitEditBox("main_dialog:input_name",self.dialog)
	self:Register(self.character_name,"input_name")
	self.character_name:SetText(gs("area_default_char_name")) -- Set Default Name
	
	self.text_relations = xml:InitTextWnd("main_dialog:text_relations",self.dialog)
	self.text_money_left = xml:InitTextWnd("main_dialog:text_money_left",self.dialog)
	self.text_rank = xml:InitTextWnd("main_dialog:text_rank",self.dialog)
	self.text_money_used = xml:InitTextWnd("main_dialog:text_money_used",self.dialog)
	self.text_cond_left = xml:InitTextWnd("main_dialog:text_cond_left",self.dialog)
	self.text_cond_used = xml:InitTextWnd("main_dialog:text_cond_used",self.dialog)
	
	self.text_item_descr = xml:InitTextWnd("main_dialog:text_item_descr",nil)
	self.scroll_item_desc = xml:InitScrollView("main_dialog:scroll_item_desc", self.dialog)
	self.scroll_item_desc:AddWindow(self.text_item_descr, true)
	self.text_item_descr:SetAutoDelete(false)
	
	self.text_item_name = xml:InitTextWnd("main_dialog:text_item_name",self.dialog)
	self.text_item_price = xml:InitTextWnd("main_dialog:text_item_price",self.dialog)
	self.text_cond_name = xml:InitTextWnd("main_dialog:text_item_name",self.dialog)
	self.text_cond_points = xml:InitTextWnd("main_dialog:text_item_price",self.dialog)
	
	-- Static Text
	xml:InitStatic("main_dialog:cap_character",self.dialog)
	xml:InitStatic("main_dialog:cap_options",self.dialog)
	xml:InitStatic("main_dialog:cap_inventory",self.dialog)
	xml:InitStatic("main_dialog:cap_loadout",self.dialog)
	xml:InitStatic("main_dialog:cap_cond",self.dialog)
	xml:InitStatic("main_dialog:cap_cond_added",self.dialog)
	
	xml:InitStatic("main_dialog:cap_name",self.dialog)
	xml:InitStatic("main_dialog:cap_rank",self.dialog)
	xml:InitStatic("main_dialog:cap_money_left",self.dialog)
	xml:InitStatic("main_dialog:cap_money_used",self.dialog)
	xml:InitStatic("main_dialog:cap_cond_left",self.dialog)
	xml:InitStatic("main_dialog:cap_cond_used",self.dialog)
	-- Main Buttons
	local btn = xml:Init3tButton("main_dialog:btn_start", self.dialog)
	self:Register(btn,"btn_start")
	
	btn = xml:Init3tButton("main_dialog:btn_back", self.dialog)
	self:Register(btn,"btn_back")
	
	btn = xml:Init3tButton("main_dialog:btn_random", self.dialog)
	self:Register(btn,"btn_random")
	
	btn = xml:Init3tButton("main_dialog:btn_faction", self.dialog)
	self:Register(btn,"btn_faction")
	
	btn = xml:Init3tButton("main_dialog:btn_icon", self.dialog)
	self:Register(btn,"btn_icon")
	
	self.list_map = xml:InitComboBox("main_dialog:list_map", self.dialog)
	self.list_map:SetAutoDelete(true)
	self:Register(self.list_map, "list_map")
	
	-- Item Lists
	self.list_inv = xml:InitListBox("main_dialog:list_inv",self.dialog)
	self.list_inv:ShowSelectedItem(true)
	self.list_inv:Show(true)
	self:Register(self.list_inv, "list_inv")
	
	self.list_loadout = xml:InitListBox("main_dialog:list_loadout",self.dialog)
	self.list_loadout:ShowSelectedItem(true)
	self.list_loadout:Show(true)
	self:Register(self.list_loadout, "list_loadout")
	
	self.list_cond = xml:InitListBox("main_dialog:list_cond",self.dialog)
	self.list_cond:ShowSelectedItem(true)
	self.list_cond:Show(true)
	self:Register(self.list_cond, "list_cond")
	
	self.list_cond_added = xml:InitListBox("main_dialog:list_cond_added",self.dialog)
	self.list_cond_added:ShowSelectedItem(true)
	self.list_cond_added:Show(true)
	self:Register(self.list_cond_added, "list_cond_added")
	
	self.ck_reset_I = xml:Init3tButton("main_dialog:check_reset_items", self.dialog)
	self.ck_reset_S = xml:Init3tButton("main_dialog:check_reset_skills", self.dialog)
	self:Register(self.ck_reset_I,"check_reset_itms")
	self:Register(self.ck_reset_S,"check_reset_skls")
	
	-- Update info
	self:UpdateAll(false)

	-- Options
	self.scroll_options = xml:InitScrollView("main_dialog:scroll_options", self.dialog)
	self.templ_options = xml:InitStatic("main_dialog:templ_options",nil)
	if (USE_MARSHAL) then
		
		self.ck_hardcore_cap = xml:InitStatic("main_dialog:options:cap_check_hardcore",self.templ_options)
		self.ck_hardcore = xml:InitCheck("main_dialog:options:check_hardcore",	self.templ_options)
		self:Register(self.ck_hardcore,"check_hardcore")
		
		self.ck_azazel_mode_cap = xml:InitStatic("main_dialog:options:cap_check_azazel_mode",self.templ_options)
		self.ck_azazel_mode = xml:InitCheck("main_dialog:options:check_azazel_mode",	self.templ_options)
		self:Register(self.ck_azazel_mode,"check_azazel_mode")
		
		self.ck_survival_cap = xml:InitStatic("main_dialog:options:cap_check_survival",self.templ_options)
		self.ck_survival = xml:InitCheck("main_dialog:options:check_survival",	self.templ_options)
		self:Register(self.ck_survival,"check_survival")
		
		self.list_hardcore_lives_cap = xml:InitStatic("main_dialog:options:cap_list_hardcore_lives",self.templ_options)
		self.list_hardcore_lives = xml:InitComboBox("main_dialog:options:list_hardcore_lives", self.templ_options)
		self.list_hardcore_lives:SetAutoDelete(true)
		self:Register(self.list_hardcore_lives, "list_hardcore_lives")
		self:LoadHardcoreLives()
		
		self.list_timer_cap = xml:InitStatic("main_dialog:options:cap_list_timer",self.templ_options)
		self.list_timer = xml:InitComboBox("main_dialog:options:list_timer", self.templ_options)
		self.list_timer:SetAutoDelete(true)
		self:Register(self.list_timer, "list_timer")
		self:LoadTimer()
		
		self.ck_states = {
							["ck_survival"] = false,
							["ck_hardcore"] = false,
							["ck_azazel_mode"] = false,
							["list_hardcore_lives"] = false,
							["list_timer"] = false
		}
	end
	self.scroll_options:AddWindow(self.templ_options, true)
	self.templ_options:SetAutoDelete(false)
	
	-- Hint Window
	self.hint_wnd = xml:InitFrame("hint_wnd:background",self)
	self.hint_wnd:SetAutoDelete(false)
	self.hint_wnd_text = xml:InitTextWnd("hint_wnd:text",self.hint_wnd)
	self.hint_wnd:Show(false)
	
	-- Message Window 
	self.msg_wnd = xml:InitFrame("hint_wnd:background",self)
	self.msg_wnd:SetAutoDelete(false)
	self.msg_wnd_text = xml:InitTextWnd("hint_wnd:text",self.msg_wnd)
	self.msg_wnd_text:SetTextAlignment(2)
	
	self.msg_wnd:Show(false)
	self.msg_wnd:SetColor(GetARGB(255,0,0,0))
end

function faction_ui:Main_CallBacks()
	self:AddCallback("btn_start", ui_events.BUTTON_CLICKED, self.OnStartGame, self)
	self:AddCallback("btn_random", ui_events.BUTTON_CLICKED, self.OnRandomize, self)
	self:AddCallback("btn_back", ui_events.BUTTON_CLICKED, self.OnQuit, self)
	
	self:AddCallback("btn_faction", ui_events.BUTTON_CLICKED, self.OnFactionClicked, self)
	self:AddCallback("btn_icon", ui_events.BUTTON_CLICKED, self.OnIconClicked, self)
	
	self:AddCallback("list_map", ui_events.LIST_ITEM_SELECT, self.OnSelectMap, self)
	self:AddCallback("check_reset_itms", ui_events.BUTTON_CLICKED, self.OnCheckResetItemsList, self)
	self:AddCallback("check_reset_skls", ui_events.BUTTON_CLICKED, self.OnCheckResetSkillsList, self)
	
	self:AddCallback("list_inv", ui_events.LIST_ITEM_CLICKED, self.OnInventoryClicked, self)
	self:AddCallback("list_inv", ui_events.WINDOW_LBUTTON_DB_CLICK, self.OnInventoryDbClicked, self)
	self:AddCallback("list_loadout", ui_events.LIST_ITEM_CLICKED, self.OnLoadoutClicked, self)
	self:AddCallback("list_loadout", ui_events.WINDOW_LBUTTON_DB_CLICK, self.OnLoadoutDbClicked, self)
	self:AddCallback("list_cond", ui_events.LIST_ITEM_CLICKED, self.OnCondClicked, self)
	self:AddCallback("list_cond", ui_events.WINDOW_LBUTTON_DB_CLICK, self.OnCondDbClicked, self)
	self:AddCallback("list_cond_added", ui_events.LIST_ITEM_CLICKED, self.OnCondAddClicked, self)
	self:AddCallback("list_cond_added", ui_events.WINDOW_LBUTTON_DB_CLICK, self.OnCondAddDbClicked, self)
	
	self:AddCallback("check_azazel_mode", ui_events.BUTTON_CLICKED, self.OnCheckSetAzazel, self)
	self:AddCallback("list_hardcore_lives", ui_events.LIST_ITEM_SELECT, self.OnSelectHardcoreLives, self)
	self:AddCallback("list_timer", ui_events.LIST_ITEM_SELECT, self.OnSelectTimer, self)
end

function faction_ui:Update()
	CUIScriptWnd.Update(self)
	
	if (not self.access) then
		self.hint_wnd:Show(false)
		return
	end
	
	-- Warning messages timer 
	if (self.msg_wnd_timer and time_global() > self.msg_wnd_timer) then 
		self.msg_wnd_timer = nil
		self.msg_wnd:Show(false)
	end
	
	for ck_name,v in pairs(self.ck_states) do 
		if (self[ck_name] and self[ck_name]:IsCursorOverWindow()) then
			local str = ""
			if (ck_name == "box_faction") then
				str = strformat( gs("st_mm_box_faction_desc") , gs("st_faction_" .. self.selected_faction))
				if (self.selected_faction == "bandit") then
					str = "cheeki breeki"
				end
			else
				str = gs("st_mm_"..ck_name.."_desc")
			end
			self:SetHint(str)
			return
		end
	end
	self.hint_wnd:Show(false)
end 

function faction_ui:SetMsg(text,tmr)
	if (text == "") then 
		return 
	end
	self.msg_wnd:Show(true)
	self.msg_wnd_text:SetText(text)
	self.msg_wnd_text:AdjustHeightToText()
	self.msg_wnd_text:SetWndSize(vector2():set(820,self.msg_wnd_text:GetHeight()+10))
	self.msg_wnd_text:SetWndPos(vector2():set(0,20))
	
	self.msg_wnd:SetWndSize(vector2():set(820,self.msg_wnd_text:GetHeight()+44))
	self.msg_wnd:SetWndPos(vector2():set(0,80))

	self.msg_wnd_timer = time_global() + 1000*tmr
end

function faction_ui:SetHint(text,pos)
	if (text == "") then
		return
	end
	self.hint_wnd:Show(true)
	self.hint_wnd_text:SetText(text)
	self.hint_wnd_text:AdjustHeightToText()
	self.hint_wnd:SetWndSize(vector2():set(self.hint_wnd:GetWidth(),self.hint_wnd_text:GetHeight()+44))
	
	pos = pos or GetCursorPosition()
	pos.y = pos.y - self.hint_wnd:GetHeight()
	pos.x = pos.x - self.hint_wnd:GetWidth()
	self.hint_wnd:SetWndPos(pos)
	
	FitInRect(self.hint_wnd,Frect():set(0,0,1024,768),0,100)
end

--=======================================< Faction Select Pop-up >=======================================--
function faction_ui:PopupFaction_Controls()
	local xml = self.xml

	-- Main
	self.black_1 = xml:InitStatic("main_dialog:popup_faction:frame_black",self.dialog)
	self.dialog_1 = xml:InitStatic("main_dialog:popup_faction:frame", self.dialog)
	
	-- Static Text
	self.cap_faction = xml:InitStatic("main_dialog:popup_faction:cap_faction",self.dialog_1)
	
	-- Faction buttons
	self.scroll_faction = xml:InitScrollView("main_dialog:popup_faction:scroll_faction", self.dialog_1)
	self.templ_faction = xml:InitStatic("main_dialog:popup_faction:templ_faction",nil)
	self.btn_faction = {}
	
	self:initOnFaction()
end

function faction_ui:initOnFaction()
	self.func_OnFaction = {}
	for i=1, #self.table_faction do
		table.insert(self.func_OnFaction, 	function()	self:OnFactionSelect(self.table_faction[i])	end)
	end
end

function faction_ui:PopupFaction_Callbacks()
	for i = 1 , #self.table_faction do
		self:AddCallback("btn_" .. self.table_faction[i], ui_events.BUTTON_CLICKED, self.func_OnFaction[i], self)
	end
end

function faction_ui:PopupFaction_Show(state)
	local xml = self.xml

	self.black_1:Show(state)
	self.dialog_1:Show(state)
	self.cap_faction:Show(state)
	self.scroll_faction:Clear()
	if state then
		self.access = false
		
		for i = 1, #self.table_faction do
			self.btn_faction[i] = xml:Init3tButton("main_dialog:popup_faction:btn_" .. self.table_faction[i], self.templ_faction)
			local x,y = self:GetAxis_Icon(self.scroll_faction, self.btn_faction[i], 3, 3, math.ceil(i/3), (i%3>0) and i%3 or 3)
			self.btn_faction[i]:SetWndPos(vector2():set(x, y))
			self:Register(self.btn_faction[i], "btn_" .. self.table_faction[i] )
		end
		self.scroll_faction:AddWindow(self.templ_faction, true)
		self.templ_faction:SetAutoDelete(false)
	else
		self.access = true
	end
end

function faction_ui:OnFactionSelect(faction)
	self.selected_faction = faction
	self:UpdateAll(false, self.selected_faction)
	self:PopupFaction_Show(false)
end

--=======================================< Icon Select Pop-up >=======================================--
function faction_ui:PopupIcon_Controls()
	local xml = self.xml
	
	-- Main
	self.black_2 = xml:InitStatic("main_dialog:popup_icon:frame_black",self.dialog)
	self.dialog_2 = xml:InitStatic("main_dialog:popup_icon:frame", self.dialog)
	
	-- Static Text
	self.cap_icon = xml:InitStatic("main_dialog:popup_icon:cap_icon",self.dialog_2)
	
	-- Faction buttons
	self.scroll_icon = xml:InitScrollView("main_dialog:popup_icon:scroll_icon", self.dialog_2)
	self.templ_icon = xml:InitStatic("main_dialog:popup_icon:templ_icon",nil)
	
	-- Size Reference
	self.tempy_icon = xml:InitStatic("main_dialog:popup_icon:temp_icon" , self.dialog_2)
	
	self.btn_icon = {}
	self.temp_icon = {}
	
	self:initOnIcon()
end

function faction_ui:initOnIcon()
	self.func_OnIcon = {}
	for i=1, 50 do
		table.insert(self.func_OnIcon, 	function()	self:OnIconSelect(i)	end)
	end
end

function faction_ui:PopupIcon_Callbacks()
	for i = 1 , 50 do
		self:AddCallback("btn_icon_" .. tostring(i), ui_events.BUTTON_CLICKED, self.func_OnIcon[i], self)
	end
end

function faction_ui:PopupIcon_Show (state)
	local xml = self.xml
	
	self.black_2:Show(state)
	self.dialog_2:Show(state)
	self.cap_icon:Show(state)
	self.scroll_icon:Clear()
	if state then
		self.access = false
		
		local n = 10
		local x = 20
		local w = self.tempy_icon:GetWidth()
		local h = self.tempy_icon:GetHeight()
		for i = 1 , #self.table_icon do
			self.temp_icon[i] = xml:InitStatic("main_dialog:popup_icon:temp_icon" , self.templ_icon)
			self.temp_icon[i]:InitTexture(self.table_icon[i])
			self.temp_icon[i]:SetStretchTexture(true)
			self.temp_icon[i]:SetWndSize(vector2():set(w , h))
			self.btn_icon[i] = xml:Init3tButton("main_dialog:popup_icon:btn_icon" , self.templ_icon)
			
			self.temp_icon[i]:SetWndPos(vector2():set(x, n))
			self.btn_icon[i]:SetWndPos(vector2():set(x, n))
			
			self:Register(self.temp_icon[i], "btn_icon_" .. tostring(i) )
			self:Register(self.btn_icon[i], "btn_icon_" .. tostring(i) )
			n = n + h + 10
		end
		for i = #self.table_icon + 1 , 50 do -- everything else is thrown outside
			if self.temp_icon[i] and self.btn_icon[i] then
				self.temp_icon[i]:SetWndPos(vector2():set(x + 200, 0))
				self.btn_icon[i]:SetWndPos(vector2():set(x + 200, 0))
			end
		end
		self.templ_icon:SetWndSize(vector2():set(self.templ_icon:GetWidth(), n - 2 ))
		self.scroll_icon:AddWindow(self.templ_icon, true)
		self.templ_icon:SetAutoDelete(false)
	else
		self.access = true
	end
end

function faction_ui:OnIconSelect(num)
	self.selected_icon = self.table_icon[num]
	self:UpdateIcon()
	self:PopupIcon_Show(false)
end

--=======================================< Prepare the droplists / Update the info >=======================================--
function faction_ui:LoadFaction (rand, faction)
	local pick = faction
	if (not pick) then
		pick = rand and self.table_faction[math.random(#self.table_faction)] or self.table_faction[1]
	end
	
	self.selected_faction = pick
	self:UpdateFaction()
	self:UpdateDescr()
end

function faction_ui:LoadIcon (rand)
	local def_icon = "no_data_anim"
	self.table_icon = {}
	table.insert(self.table_icon, def_icon)

	local section = self.selected_faction .. "_portraits"
	local n = ini_ico:section_exist(section) and ini_ico:line_count(section) or 0
	for i=0 , n-1 do
		local result, id, value = ini_ico:r_line(section,i,"","")
		if (id ~= "") then
			table.insert(self.table_icon, id)
		end
	end
	
	local pick = rand and self.table_icon[math.random(#self.table_icon)] or def_icon
	
	self.selected_icon = pick
	self:UpdateIcon()
end

function faction_ui:LoadMap (rand)
	iempty_table(self.table_map)
	self.list_map:ClearList()
		
	local n = ini_map:line_count(self.selected_faction .. "_start_locations") or 0
	for i=0, n-1 do
		local result, id, value = ini_map:r_line(self.selected_faction.."_start_locations",i,"","" )
		self.map_attr[id] = value:to_table()
		table.insert(self.table_map, id)
	end
	
	for i=1,#self.table_map do
		self.list_map:AddItem(gs("ui_st_"..self.table_map[i]), i)
	end
	local pick = self.table_map[1]
	self.list_map:SetText(gs("ui_st_".. pick))

	self.selected_map = rand and self.table_map[math.random(#self.table_map)] or pick
end

function faction_ui:LoadRank ()
	local location = self.selected_map
	allow_level = tonumber(self.map_attr[location][2]) or 1
	local rank = self.map_attr[location][3] or st_rank_novice
	self.text_rank:SetText(gs(rank))
	local moneyMin = self.map_attr[location][4] or 0
	local moneyMax = self.map_attr[location][5] or 0
	local rankMin = self.map_attr[location][6] or self.rank_start
	local rankMax = self.map_attr[location][7] or 100
	self.rank = math.random(rankMin,rankMax)
	self.money_left = (self.money_left + math.random(moneyMin, moneyMax))
	self.money_start = self.money_left
end

function faction_ui:LoadLoadout (rand)
	-- Reset
	self:ClearItem()
	self.money_used = 0
	self.money_left = self.money_start
	self.text_money_used:SetText(tostring(self.money_used))
	self.text_money_left:SetText(tostring(self.money_left))

	self:ClearList(self.list_loadout)
	self:ClearList(self.list_inv)

	allow_level = tonumber(self.map_attr[self.selected_map][2]) or 1

	-- Read
	self.table_inv = {}
	self.table_loadout = {}
	local n = ini_itm:line_count(self.selected_faction .. "_loadout") or 0
	for i=0, n-1 do
		local result, id, value = ini_itm:r_line_ex(self.selected_faction .. "_loadout" , i , "", "")
		if INI:section_exist(id) then
			local t = value:to_table()
			if (t[1] == "false") then
				self.table_inv[#self.table_inv + 1] = { ["name"] = id , ["money"] = tonumber(t[2]) or 0, ["cnt"] = tonumber(t[3]) or 1, ["max"] = tonumber(t[3]) or 0  }
			elseif ((t[1] == "true") and (tonumber(t[4]) <= allow_level)) then
				if (#t > 4) then
					id = t[math.random(5,#t)]
				end
				self.table_loadout[#self.table_loadout + 1] = { ["name"] = id ,  ["money"] = tonumber(t[2]) or INI:r_float_ex(id,"cost"), ["cnt"] = tonumber(t[3]) or 1, ["max"] = tonumber(t[3]) or 0 }
			end
		end
	end
	
	-- Update
	for i = 1, #self.table_inv do
		local _itm = set_list_text( i-1, self.table_inv[i].name, self.table_inv[i].money, self.table_inv[i].cnt, self.table_inv[i].max, false )
		self.list_inv:AddExistingItem(_itm)
	end
	for i = 1, #self.table_loadout do
		local _itm = set_list_text( i-1 , self.table_loadout[i].name, self.table_loadout[i].money, self.table_loadout[i].cnt, self.table_loadout[i].max, true)
		self.list_loadout:AddExistingItem(_itm)
	end
	
	-- Pick randomly
	if (not rand) then
		return
	end
	
	local pick_tbl = {}
	for i = 1 , self.list_loadout:GetSize() do	
		pick_tbl[i] = i - 1
	end

	for i = 1, #pick_tbl do
		local _item = self.list_loadout:GetItemByIndex(pick_tbl[table.random(pick_tbl)])
		self:OnLoadoutDbClicked(_item)
	end
end

function faction_ui:LoadSkills (rand)
	-- Reset
	self:ClearItem()
	self.cond_left = self.cond_start
	self.cond_used = 0
	self.text_cond_used:SetText(tostring(self.cond_used))
	self.text_cond_left:SetText(tostring(self.cond_left))
	local delet = {}
	for index = 0, self.list_cond:GetSize()-1 do
		local item = self.list_cond:GetItemByIndex(index)
		delet[#delet+1] = item
	end
	for i = 1, #delet do
		self.list_cond:RemoveItem(delet[i])
	end
	
	delet = {}
	for index = 0, self.list_cond_added:GetSize()-1 do
		local item = self.list_cond_added:GetItemByIndex(index)
		delet[#delet+1] = item
	end
	for i = 1, #delet do
		self.list_cond_added:RemoveItem(delet[i])
	end
	
	--self.table_cond = {}
	n = ini_cond:line_count(self.selected_faction .. "_condition") or 0
	for i=0, n-1 do
		local result, id, value = ini_cond:r_line(self.selected_faction .. "_condition" , i , "", "")
		local t = value:to_table()
		local _itm = set_list_text( i, tostring(t[2]), tonumber(t[1]), nil, true, 1, tostring(t[3]), tostring(t[4]), tostring(t[5]) )
		--self.table_cond[#self.table_cond + 1] = { ["name"] = tostring(t[2]), ["money"] = tonumber(t[1]), ["conflict"] = tostring(t[3]), ["conflict1"] = tostring(t[4]), ["conflict2"] = tostring(t[5]) }
		self.list_cond:AddExistingItem(_itm)
	end

	-- Pick randomly
	if (not rand) then
		return
	end
	
	local pick_tbl = {}
	for i = 1 , self.list_cond:GetSize() do	
		pick_tbl[i] = i - 1
	end

	for i = 1, #pick_tbl do
		local _item = self.list_cond:GetItemByIndex(table.remove(pick_tbl, table.random(pick_tbl)))
		self:OnCondDbClicked(_item)
	end
end

function faction_ui:ClearList (list)
	local delet = {}
	for index = 0, list:GetSize()-1 do
		local item = list:GetItemByIndex(index)
		delet[#delet+1] = item
	end
	for i = 1, #delet do
		list:RemoveItem(delet[i])
	end
end

function faction_ui:LoadHardcoreLives (rand)
	local str
	self.list_hardcore_lives:ClearList()
	for i=1, #self.table_hardcore_lives do
		str = self.table_hardcore_lives[i][1] or ""
		self.list_hardcore_lives:AddItem(str .. " " .. gs(self.table_hardcore_lives[i][2]), i)
	end
	local pick = rand and self.table_hardcore_lives[math.random(#self.table_hardcore_lives)] or self.table_hardcore_lives[1]
	str = pick[1] or ""
	self.list_hardcore_lives:SetText(str .. " " .. gs(pick[2])) 
	self.selected_hardcore_lives = pick
end

function faction_ui:LoadTimer (rand)
	local str
	self.list_timer:ClearList()
	for i=1, #self.table_timer do
		str = self.table_timer[i][1] or ""
		self.list_timer:AddItem(str .. " " .. gs(self.table_timer[i][2]), i)
	end
	local pick = rand and self.table_timer[math.random(#self.table_timer)] or self.table_timer[1]
	str = pick[1] or ""
	self.list_timer:SetText(str .. " " .. gs(pick[2]))
	self.selected_timer = pick
end


--=======================================< GUI Callbacks >=======================================-
function faction_ui:OnFactionClicked()
	if (not self.access) then
		return
	end
	
	self:PopupFaction_Show(true)
end

function faction_ui:OnIconClicked()
	if (not self.access) then
		return
	end
	
	self:PopupIcon_Show(true)
end

function faction_ui:OnSelectMap()
	local map_id = self.list_map:CurrentID()

	self.selected_map = self.table_map[map_id]
	self:ResetMoney()
	self:LoadRank()
	self:LoadLoadout()
	--self:LoadSkills()
end

function faction_ui:OnInventoryClicked()
	if (not self.access) then
		return
	end
	
	local item = self.list_inv:GetSelectedItem()
	if not (item) then 
		return
	end
	self:UpdateItem(item)
end

function faction_ui:OnCondClicked()
	if (not self.access) then
		return
	end
	
	local item = self.list_cond:GetSelectedItem()
	if not (item) then 
		return
	end
	self:UpdateCond(item)
end

function faction_ui:OnInventoryDbClicked()
	if (not self.access) then
		return
	end
	
	local item = self.list_inv:GetSelectedItem()
	if not (item) then 
		return 
	end
	
	if not (item.allow) then
		return
	end
	
	local money = item.money
	self.money_used = self.money_used - money
	self.money_left = self.money_left + money
	
	self.text_money_used:SetText(tostring(self.money_used))
	self.text_money_left:SetText(tostring(self.money_left))
	local _itm,itm
	if item.cnt and item.cnt > 1 then
		_itm = set_list_text(item.idx, item.name, item.money, item.cnt-1, item.max, true)
		self.list_inv:AddExistingItem(_itm)
	end
	self.list_inv:RemoveItem(item)
	if item.max == 0 then return end
	
	self.table_loadout[item.idx+1].cnt = self.table_loadout[item.idx+1].cnt+1

	self:ClearList(self.list_loadout)
	for i = 1, #self.table_loadout do
		local _itm = set_list_text( i-1 , self.table_loadout[i].name, self.table_loadout[i].money, self.table_loadout[i].cnt, self.table_loadout[i].max, true)
		if self.table_loadout[i].cnt > 0 then
			self.list_loadout:AddExistingItem(_itm)
		end
	end
	
	self:ClearItem()
end

function faction_ui:OnCondDbClicked(pick)
	if (not self.access) then
		return
	end
	
	local item = pick
	if (not item) then
		item = self.list_cond:GetSelectedItem()
		if (not item) then
			return 
		end
	end
	
	local money = item.money
	
	if (money > self.cond_left) then
		return
	end
	
	--printf("1 %s %s %s asd %s", item.conflict, item.conflict2, item.conflict1, item.name)
	if (self.list_cond_added:GetSize() > 0) then
		for index = 0, self.list_cond_added:GetSize()-1 do
			local i = self.list_cond_added:GetItemByIndex(index)
			--printf("2 %s %s %s asd %s", i.conflict, i.conflict2, i.conflict1, i.name)
			if ((i.name == item.conflict) or (i.name == item.conflict1) or (i.name == item.conflict2)) then
				return
			end
		end
	end
	
	self.cond_used = self.cond_used + money
	self.cond_left = self.cond_left - money
	
	self.text_cond_used:SetText(tostring(self.cond_used))
	self.text_cond_left:SetText(tostring(self.cond_left))
	
	local _itm = set_list_text(item.idx, item.name, item.money, nil, 0, true, item.conflict, item.conflict1, item.conflict2)
	self.list_cond_added:AddExistingItem(_itm)
	self.list_cond:RemoveItem(item)
	
	self:ClearItem()
end

function faction_ui:OnLoadoutClicked()
	if (not self.access) then
		return
	end
	
	local item = self.list_loadout:GetSelectedItem()
	if not (item) then 
		return
	end
	self:UpdateItem(item)
end

function faction_ui:OnCondAddClicked()
	if (not self.access) then
		return
	end
	
	local item = self.list_cond_added:GetSelectedItem()
	if not (item) then 
		return
	end
	self:UpdateCond(item)
end

function faction_ui:OnLoadoutDbClicked (pick)
	if (not self.access) then
		return
	end
	
	local item = pick
	if (not item) then
		item = self.list_loadout:GetSelectedItem()
		if (not item) then
			return
		end
	end

	local money = item.money
	if (money > self.money_left) then
		return
	end
	
	local _itm, itm
	for i=0, self.list_inv:GetSize()-1 do
		local it = self.list_inv:GetItemByIndex(i)
		if it.name == item.name then
			if item.max == 0 or it.cnt < item.max then
				self.list_inv:RemoveItem(it)
				_itm = set_list_text(item.idx, item.name, item.money, it.cnt + 1, item.max, true)
				if item.max > 0 then
					self.table_loadout[item.idx+1].cnt = self.table_loadout[item.idx+1].cnt - 1
				end
				break
			else
				return
			end
		end
	end

	self.money_used = self.money_used + money
	self.money_left = self.money_left - money
	
	self.text_money_used:SetText(tostring(self.money_used))
	self.text_money_left:SetText(tostring(self.money_left))
	
	if not (_itm) then
		_itm = set_list_text(item.idx, item.name, item.money, 1, item.max, true)
		if item.max > 0 then
			self.table_loadout[item.idx+1].cnt = self.table_loadout[item.idx+1].max - 1
		end
	end

	--printf("item.idx:%s[%s] _itm.idx:%s", item.idx, item.cnt, _itm and _itm.idx)
	self.list_inv:AddExistingItem(_itm)

	if item.max == 0 then return end
	self:ClearList(self.list_loadout)
	for i = 1, #self.table_loadout do
		local itm = set_list_text( i-1 , self.table_loadout[i].name, self.table_loadout[i].money, self.table_loadout[i].cnt, self.table_loadout[i].max, true)
		if self.table_loadout[i].cnt > 0 then
			self.list_loadout:AddExistingItem(itm)
		end
	end
	
	self:ClearItem()
end

function faction_ui:OnCondAddDbClicked (pick)
	if (not self.access) then
		return
	end
	
	local item = self.list_cond_added:GetSelectedItem()
	if not (item) then 
		return 
	end
	
	if not (item.allow) then
		return
	end
	
	local money = item.money
	if (self.cond_left + money < 0) then return end
	
	self.cond_used = self.cond_used - money
	self.cond_left = self.cond_left + money
	
	self.text_cond_used:SetText(tostring(self.cond_used))
	self.text_cond_left:SetText(tostring(self.cond_left))

	self.list_cond_added:RemoveItem(item)
	
	local _itm = set_list_text(item.idx, item.name, item.money, nil, 0, true, item.conflict, item.conflict1, item.conflict2)
	self.list_cond:AddExistingItem(_itm)
	
	self:ClearItem()
end

function faction_ui:OnSelectHardcoreLives()
	self.selected_hardcore_lives = self.table_hardcore_lives[self.list_hardcore_lives:CurrentID()]
end

function faction_ui:OnSelectTimer()	
	self.selected_timer = self.table_timer[self.list_timer:CurrentID()]
end

function faction_ui:OnCheckSetAzazel()
	if (not self.access) then
		return
	end
end

function faction_ui:OnCheckResetItemsList()
	if (not self.access) then
		return
	end
	self:LoadLoadout()
end

function faction_ui:OnCheckResetSkillsList()
	if (not self.access) then
		return
	end
	self:LoadSkills()
end

--=======================================< Update visuals >=======================================--
function faction_ui:UpdateAll (rand, faction)
	self:LoadFaction(rand, faction)
	self:LoadIcon(rand)
	self:LoadMap(rand)
	self:ResetMoney()
	self:LoadRank()
	self:LoadLoadout(rand)
	self:LoadSkills(rand)
end

function faction_ui:UpdateFaction()
	self.box_faction:InitTexture("ui_new_game_flair_" .. self.selected_faction)
	self.box_faction:SetStretchTexture(true)
	self.box_faction:SetWndSize(vector2():set(self.box_faction:GetWidth(),self.box_faction:GetHeight()))
end

function faction_ui:ResetMoney()
	local money_min = alun_utils.read_from_ini(ini_itm, self.selected_faction .. "_money", "money_min", "float")
	local money_max = alun_utils.read_from_ini(ini_itm, self.selected_faction .. "_money", "money_max", "float")
	self.money_start = ((math.floor(math.random(money_min,money_max)/10))*10)
	self.money_left = self.money_start
	self.money_used = 0
end

function faction_ui:UpdateIcon()
	self.box_icon:InitTexture(self.selected_icon)
	self.box_icon:SetStretchTexture(true)
	self.box_icon:SetWndSize(vector2():set(self.box_icon:GetWidth(),self.box_icon:GetHeight()))
end

function faction_ui:UpdateDescr()
	local faction = self.selected_faction 
	
	-- Description and map
	local desc = "%c[0,250,250,250]" .. gs("st_mm_new_game_description")
	desc = desc .. "\\n%c[0,150,150,150]" .. gs("st_faction_" .. faction .. "_desc")
	
	self.text_descr:SetText(desc)
	self.text_descr:AdjustHeightToText()
	self.text_descr:SetWndSize(vector2():set(self.text_descr:GetWidth(),self.text_descr:GetHeight()+10))
	self.scroll_desc:Clear()
	self.scroll_desc:AddWindow(self.text_descr, true)
	self.text_descr:SetAutoDelete(false)
	
	-- Relations
	local str_stats = "%c[0,250,250,250]" .. gs("st_mm_new_game_relations") .. " \\n"
	local t = self.table_faction
	for i=1,#t do
		if not (t[i] == faction) then
			local v = relation_registry.community_relation("actor_" .. faction, t[i])
			if (v >= 1000) then
				str_stats = str_stats .. "%c[0,150,150,150]• %c[0,50,175,50]" .. gs("st_faction_" .. t[i]) .. "\\n"
			elseif (v <= -1000) then
				str_stats = str_stats .. "%c[0,150,150,150]• %c[0,175,50,50]" .. gs("st_faction_" .. t[i]) .. "\\n"
			else
				str_stats = str_stats .. "%c[0,150,150,150]• %c[0,175,175,50]" .. gs("st_faction_" .. t[i]) .. "\\n"
			end
		end
	end
	
	self.text_relations:SetText(str_stats)
	self.text_relations:AdjustHeightToText()
end

function faction_ui:UpdateItem (item)
	if not (item) then
		return
	end

	-- description
	local desc = gs(INI:r_string_ex(item.name,"description"))
	
	self.text_item_descr:SetText(desc)
	self.text_item_descr:AdjustHeightToText()
	self.text_item_descr:SetWndSize(vector2():set(self.text_item_descr:GetWidth(),self.text_item_descr:GetHeight()))
	self.scroll_item_desc:Clear()
	self.scroll_item_desc:AddWindow(self.text_item_descr, true)
	self.text_item_descr:SetAutoDelete(false)
	
	-- name
	self.text_cond_name:SetText("")
	self.text_cond_points:SetText("")
	self.text_item_name:SetText( "%c[0,150,150,50]• %c[0,170,170,170]" .. gs(INI:r_string_ex(item.name,"inv_name", "")))
	self.text_item_price:SetText( "%c[0,100,50,200]• %c[0,170,170,170]" .. gs("st_mm_new_game_money") .. tostring(item.money) )
	if (not item.allow) then
		self.text_item_price:SetText( "%c[0,100,50,200]• %c[0,170,170,170]" .. gs("st_mm_new_game_essential") )
	end
	
	-- Icon
	local ico = self:GetAxis_Item(item.name)
	self.box_item:InitTexture("ui\\ui_icon_equipment_with_mags")
	self.box_item:SetTextureRect(Frect():set(ico.x1, ico.y1, ico.x2, ico.y2))
	self.box_item:SetStretchTexture(true)
	
	local pos = self.box_item_temp:GetWndPos()
	local _w = self.box_item_temp:GetWidth()
	local _h = self.box_item_temp:GetHeight()
	
	local ratio = ico.w/ico.h
	local h, w
	ico.w = ico.w * ico_size * ico_width
	ico.h = ico.h * ico_size
	
	local w_t, h_t = 0, 0
	local resize = false
	if (ico.w > _w) then -- if icon width is bigger than frame width
		w_t = ico.w - _w
		resize = true	
	end 
	if (ico.h > _h) then -- if icon height is bigger than frame height
		h_t = ico.h - _h 
		resize = true	
	end 
	
	if resize then -- resize is required
		if (w_t >= h_t) then -- if icon width is the big number (or square), use it as a base for resizing
			w = _w
			h = w / ratio
		elseif (w_t < h_t) then -- if icon width is the big number, use it as a base for resizing
			h = _h
			w = h * ratio
		end
	else -- no resize
		w = ico.w
		h = ico.h
	end
	
	offset_x = (_w - w)/2
	offset_y = (_h - h)/2
	self.box_item:SetWndSize(vector2():set(w , h))
	self.box_item:SetWndPos(vector2():set(pos.x + offset_x , pos.y + offset_y))
end

function faction_ui:UpdateCond(item)
	if not (item) then
		return
	end
	
	self:ClearItem()

	-- description
	local desc = gs(item.name .. "_descr")
	
	self.text_item_descr:SetText(desc)
	self.text_item_descr:AdjustHeightToText()
	self.text_item_descr:SetWndSize(vector2():set(self.text_item_descr:GetWidth(),self.text_item_descr:GetHeight()))
	self.scroll_item_desc:Clear()
	self.scroll_item_desc:AddWindow(self.text_item_descr, true)
	self.text_item_descr:SetAutoDelete(false)
	
	-- name
	self.text_item_name:SetText("")
	self.text_item_price:SetText("")
	self.text_cond_name:SetText("%c[0,150,150,50]• %c[0,170,170,170]"..gs(item.name))
	self.text_cond_points:SetText("%c[0,100,50,200]• %c[0,170,170,170]"..gs("st_mm_new_game_points")..tostring(item.money))
	
end

function faction_ui:ClearItem()
	self.text_item_name:SetText("")
	self.text_item_price:SetText("")
	self.text_cond_name:SetText("")
	self.text_cond_points:SetText("")
	self.scroll_item_desc:Clear()
	self.box_item:InitTexture("ui\\ui_icon_equipment_with_mags")
	self.box_item:SetTextureRect(Frect():set(0, 0, 0, 0))
end

function faction_ui:GetAxis_Item (obj)
	local a = {}
		
	local inv_grid_x = INI:r_float_ex (obj,"inv_grid_x") or 0
	local inv_grid_y = INI:r_float_ex (obj,"inv_grid_y") or 0
	local inv_grid_width = INI:r_float_ex (obj,"inv_grid_width") or 0
	local inv_grid_height = INI:r_float_ex (obj,"inv_grid_height") or 0
	
	local x1 = inv_grid_x*50
	local y1 = inv_grid_y*50

	local w = inv_grid_width*50
	local h = inv_grid_height*50

	local x2 = x1 + w
	local y2 = y1 + h
	
	a.x1 = x1
	a.y1 = y1
	a.x2 = x2
	a.y2 = y2
	a.w = w
	a.h = h
	
	return a
end

function faction_ui:GetAxis_Icon (main , element , all_row , all_col , row , col)
	local _w = main:GetWidth()
	local _h = main:GetHeight()
	local _wi = element:GetWidth()
	local _hi = element:GetHeight()
	local off_x = (_w - _wi * all_col)/(all_col+1)
	local off_y = (_h - _hi * all_row)/(all_row+1)
	
	local x = (off_x * col) + (_wi * (col - 1))
	local y = (off_y * row) + (_hi * (row - 1))
	return x,y
end


--=======================================< Main Buttons >=======================================--
function faction_ui:OnQuit()
	if (not self.access) then
		return
	end
	
	self.owner:ShowDialog(true)
	self.owner:Show(true)
	if (self:IsShown()) then
		self:HideDialog()
	end
	self:Show(false)
end

function faction_ui:OnRandomize()
	if (not self.access) then
		return
	end
	
	-- Faction
	self.selected_faction  = self.table_faction[math.random(#self.table_faction)]
	
	-- Name
	local subset
	if (self.selected_faction == "army" or self.selected_faction == "dolg") then 
		subset = random_choice("private","sergeant","senior_sergeant","lieutenant","captain")
	else 
		subset = random_choice("stalker","bandit","science")
	end
	local name_cnt = INI:r_float_ex("stalker_names_"..subset,"name_cnt")
	local last_name_cnt = INI:r_float_ex("stalker_names_"..subset,"last_name_cnt")
	local first_name = gs(strformat("name_%s_%s",subset,math.random(0,name_cnt-1)))
	local last_name = gs(strformat("lname_%s_%s",subset,math.random(0,last_name_cnt-1)))
	self.character_name:SetText(first_name .. " " .. last_name)
	
	-- Everything else
	self:UpdateAll(true, self.selected_faction)
end

function faction_ui:OnKeyboard(dik, keyboard_action)
	if (not self.access) then
		return
	end
	
	local res = CUIScriptWnd.OnKeyboard(self,dik,keyboard_action)
	if (res == false) then
		local bind = dik_to_bind(dik)
		if keyboard_action == ui_events.WINDOW_KEY_PRESSED then
			if dik == DIK_keys.DIK_ESCAPE then
				self:OnQuit()
			elseif (dik == DIK_keys.DIK_Z) then
				self.selected_faction = "zombied"
				self:UpdateAll(false , self.selected_faction)
			elseif (dik == DIK_keys.DIK_S) then
			end
		end
	end
	return res
end

function faction_ui:OnStartGame()
	if (not self.access) then
		return
	end

	-- start game anyway if no config or axr_main script
	if not (axr_main and axr_main.config) then
		self.owner:StartGame()
		return
	end
	
	-- check name
	local character_name = self.character_name:GetText()
	if (character_name == "") then
		-- Require a name to be entered.
		return
	end
	
	-- check location
	if (self.selected_map == nil or self.selected_map == "" or self.list_map:CurrentID() <= 0) then
		local index = 1
		self.selected_map = self.table_map[index]
	end
	
	local timer
	if (self.selected_timer[1]) and (type(self.selected_timer[1]) == "number") then
		timer = self.selected_timer[1]
	end
	
	-- prepare loadout
	local loadout_str
	for index = 0, self.list_inv:GetSize()-1 do
        local item = self.list_inv:GetItemByIndex(index)
        local cnt = item.cnt or 1
        for c = 1, cnt do
            if (not loadout_str) then
                loadout_str = item.name
            else
                loadout_str = loadout_str .. "," .. item.name
            end
        end
	end
	
	local cond_str
	for index = 0, self.list_cond_added:GetSize()-1 do
		local item = self.list_cond_added:GetItemByIndex(index)
		if (not cond_str) then
			cond_str = item.name
		else
			cond_str = cond_str .. "," .. item.name
		end
	end

	axr_main.config:w_value("character_creation","new_game_hardcore_mode",self.ck_hardcore and self.ck_hardcore:GetCheck() and true or nil)
	axr_main.config:w_value("character_creation","new_game_hardcore_mode_lives",self.ck_hardcore and self.selected_hardcore_lives[1] or nil)
	axr_main.config:w_value("character_creation","new_game_azazel_mode",self.ck_azazel_mode and self.ck_azazel_mode:GetCheck() and true or nil)
	axr_main.config:w_value("character_creation","new_game_survival_mode",self.ck_survival and self.ck_survival:GetCheck() and true or nil)
	axr_main.config:w_value("character_creation","new_game_timer_mode",timer or nil)
	
	axr_main.config:w_value("character_creation","new_game_character_name",character_name:gsub(" ","_") )
	axr_main.config:w_value("character_creation","new_game_faction",self.selected_faction or nil)
	axr_main.config:w_value("character_creation","new_game_icon",self.selected_icon or nil)
	axr_main.config:w_value("character_creation","new_game_loadout",loadout_str or nil)
	axr_main.config:w_value("character_creation","new_game_map",self.selected_map or nil)
	axr_main.config:w_value("character_creation","new_game_money",self.money_left or nil)
	axr_main.config:w_value("character_creation","new_game_rank",self.rank or nil)
	axr_main.config:w_value("character_creation","new_game_traits",cond_str or nil)
	
	axr_main.config:save() -- Store info in temp file
	self.owner:StartGame() -- Start the game
end

--=======================================< List Item  >=======================================--
class "set_list_text" (CUIListBoxItem)
function set_list_text:__init(idx, name, money, cnt, max, allow, conflict, conflict1, conflict2) super(idx, name, money, max, cnt, allow, conflict, conflict1, conflict2)
	
	self.idx					= idx
	self.money					= money
	self.allow					= allow
	self.cnt					= cnt
	self.max					= max
	self.name					= name
	self.string 				= name
	self.conflict 				= conflict or ""
	self.conflict1 				= conflict1 or ""
	self.conflict2 				= conflict2 or ""
	self.text					= self:GetTextItem()
	self.text:SetWndRect		(Frect():set(0,0,300,22))
	self:SetTextColor			(GetARGB(255, 170, 170, 170))
	self.text:SetFont			(GetFontLetterica16Russian())
	self.text:SetWndSize		(vector2():set(400,22))
	self.text:SetEllipsis		(true)
	local amt = ""
	if self.cnt and (self.cnt > 1 or self.max > 0) then
		amt = " x ".. tostring(self.cnt)
	end
	self.text:SetText			(gs (INI:r_string_ex (self.string,"inv_name", name)) .. amt )
	
end