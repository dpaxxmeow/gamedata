--[[ 	General Scripting TIPS

	1. 	NEVER keep userdata (ie. engine classes) in global scope, instead keep track of game object id, and grab object in the scope you need it in by using level.object_by_id or db.storage table. 
		Otherwise object can't deconstruct and you will end up with instances were script binder exists but object doesn't or level object exists but server object doesn't. This is because variables in lua are all references.
			Ex. _G.npc = level.object_by_id(2342) 
				alife():release(alife_object(2342))
		Above, 'npc' will not be nil but se_obj will be! scripts will blow up. Pure Virtual Function calls may occur! Or quite possibly silent errors like for example when player goes to talk to npc game crashes because self.object is nil
		Such thing is 'okay' in db.storage, but that is because on net_destroy db.storage[id] is set nil. So if you are keeping track of objects directly in a table, instead of ID 
		then you absolutely must rid of every single reference to the userdata so that it can be destroy and garbage collected. Otherwise you end up with undetectable issues.
--]]

------------ global system_ini()--------------------------------------
INI = system_ini()
------------ A.R.E.A Adding methods to standard LUA objects-----------
area_methods.main()
----------------------------------------------------------------------

GAME_VERSION = "1.1694 (06.01.2023)"

if command_line():is_contain("-dev") then -- changed from -dbg so that seeing engine -dgb messages is optional
	DEV_DEBUG = true
	DEV_DEBUG_DEV = true
end

USE_INI_MEMOIZE = true
----------------------------------------------------------------------
-- Use marshal library for saving persistent data (like xr_logic pstor)
-- marshal library can encode tables, functions, strings and numbers to easily allow persistent data storage to file
-- This is used for db.storage[id].pstor, surge_manager, mines, and coc_treasure_manager.script if enabled
-- See alife_storage_manager.script for implementation
require("lua_extensions")
marshal = require "marshal"
USE_MARSHAL = marshal ~= nil

----------------------------------------------------------------------
mus_vol = 0
amb_vol = 0
----------------------------------------------------------------------
-- Constants
----------------------------------------------------------------------
VEC_ZERO 	= vector():set(0,0,0)
VEC_X 		= vector():set(1,0,0)
VEC_Y 		= vector():set(0,1,0)
VEC_Z 		= vector():set(0,0,1)

function vec_sub(a,b)
	return vector():set(a):sub(b)
end

function vec_add(a,b)
	return vector():set(a):add(b)
end
----------------------------------------------------------------------

function GodMode()
	return get_console():get_bool("g_god")
end

function start_game_callback()
	printf("A.R.E.A. %s", GAME_VERSION)

	if not INI then
		INI = system_ini()
	end

	-- Alundaio
	axr_main.on_game_start()
	-- End Alundaio
	
	sim_board.get_sim_board()
	dialog_manager.fill_phrase_table()
	pda.add_quick_slot_items_on_game_start()
end

--local alife_sim
function alife_object(id)
	if (id == nil or id >= 65535) then
		error("ALIFE OBJECT ID IS %s!",id)
		return
	end
	-- if not (alife_sim) then
		-- alife_sim = alife()
	-- end
	return alife():object(id)
end

-------------------------------------------------------------------------------------------------------
-- 											SCRIPTED CALLBACKS
-------------------------------------------------------------------------------------------------------
function RegisterScriptCallback(name,func_or_userdata,only_once)
	axr_main.callback_set(name,func_or_userdata,only_once)
end

function UnregisterScriptCallback(name,func_or_userdata)
	axr_main.callback_unset(name,func_or_userdata)
end

-- Call this from a script to create a new callback to functions that register for it with RegisterScriptCallback
-- Every time this function is executed it will callback to all registered members
-- If axr_main.script has a function by this name, it will automatically trigger it!
function SendScriptCallback(name,...)
	--alun_utils.debug_write(strformat("BEFORE SendScriptCallback %s",name))
	-- callback to all registered functions
	axr_main.make_callback(name,...)
		--alun_utils.debug_write(strformat("AFTER SendScriptCallback %s",name))
		-- check if axr_main has it's own function to execute
	if (axr_main[name]) then
		axr_main[name](...)
	end
end
--------------------------------------------
-- Displays message on middle-top of screen for n amount of milliseconds
-- Overwritten with each use!
-- param 1 - Message as string
-- param 2 - Milliseconds as number
--------------------------------------------
function SetHudMsg(msg,n)
	n = n or 5
	msg = tostring(msg) or " "
	local hud = get_hud()
	if (hud) then
		hud:AddCustomStatic("not_enough_money_mine", true)
		hud:GetCustomStatic("not_enough_money_mine"):wnd():TextControl():SetTextST(msg)
	end
	bind_stalker_ext.ShowMessageTime = time_global() + n*1000
end

-- Should only be used as a single instance
function SetHudTimer(alias,msg,typ,target)
	local hud = get_hud()
	local m_data = alife_storage_manager.get_state()
	m_data.global_hud_timer = { 
		[1] = typ == "inc" and 0 or 1, 
		[2] = typ == "inc" and 0 or target,
		[3] = typ == "inc" and target or 0, 
		[4] = time_global(),
		[5] = alias,
		[6] = msg
	}

	hud:AddCustomStatic("hud_timer", true)
	hud:AddCustomStatic("hud_timer_text", true)	
	
	local timer_text = hud:GetCustomStatic("hud_timer_text"):wnd()
	timer_text:TextControl():SetTextST(msg or "")
end

function SetHudTimerMsg(msg)
	local m_data = alife_storage_manager.get_state()
	m_data.global_hud_timer[6] = msg
end

function RemoveHudTimer()
	local hud = get_hud()
	hud:RemoveCustomStatic("hud_timer")
	hud:RemoveCustomStatic("hud_timer_text")
	local m_data = alife_storage_manager.get_state()
	m_data.global_hud_timer = nil
end
--------------------------------------------------------------------------------------------
-- 								Delayed Event Queue
--
-- Events must have a unique id. Such as object id or another identifier unique to the occasion.
-- Action id must be unique to the specific Event. This allows a single event to have many queued
-- actions waiting to happen.
--
-- Returning true will remove the queued action. Returning false will execute the action continuously.
-- This allows for events to wait for a specific occurrence, such as triggering after a certain amount of
-- time only when object is offline
--
-- param 1 - Event ID as type<any>
-- param 2 - Action ID as type<any>
-- param 3 - Timer in seconds as type<number>
-- param 4 - Function to execute as type<function>
-- extra params are passed to executing function as table as param 1

-- see on_game_load or state_mgr_animation.script for example uses
-- This does not persists through saves! So only use for non-important things.
-- For example, do not try to destroy npcs unless you do not care that it can fail before player saved then loaded.
----------------------------------------------------------------------------------------------
local ev_queue = {}
function CreateTimeEvent(ev_id,act_id,timer,f,...)
	if not (type(ev_id) == "number" or type(ev_id) == "string") then
		error("CreateTimeEvent argument 1 must contain a string or a number!")
	end
	if not (type(act_id) == "number" or type(act_id) == "string") then
		error("CreateTimeEvent argument 2 must contain a string or a number!")
	end
	if type(timer) ~= "number" then
		error("CreateTimeEvent argument 3 must contain a number!")
	end
	if type(f) ~= "function" then
		error("CreateTimeEvent argument 4 must contain a function!")
	end

	if not (ev_queue[ev_id]) then
		ev_queue[ev_id] = {}
	end

	if not (ev_queue[ev_id][act_id]) then
		ev_queue[ev_id][act_id] = {}
		ev_queue[ev_id][act_id].timer = time_global() + timer*1000
		ev_queue[ev_id][act_id].f = f
		ev_queue[ev_id][act_id].p = {...}

		AddUniqueCall(function()
			local act = ev_queue[ev_id][act_id]
			if act then
				if time_global() >= act.timer then
					if act.f(unpack(act.p)) == true then
						ev_queue[ev_id][act_id] = nil
						return true
					end
				end
			else
				return true
			end
		end)
	end
end

function RemoveTimeEvent(ev_id,act_id)
	if not (type(ev_id) == "number" or type(ev_id) == "string") then
		error("RemoveTimeEvent argument 1 must contain a string or a number!")
	end
	if not (type(act_id) == "number" or type(act_id) == "string") then
		error("RemoveTimeEvent argument 2 must contain a string or a number!")
	end
	if (ev_queue[ev_id] and ev_queue[ev_id][act_id]) then
		ev_queue[ev_id][act_id] = nil
	end
end

function ResetTimeEvent(ev_id,act_id,timer)
	if not (type(ev_id) == "number" or type(ev_id) == "string") then
		error("ResetTimeEvent argument 1 must contain a string or a number!")
	end
	if not (type(act_id) == "number" or type(act_id) == "string") then
		error("ResetTimeEvent argument 2 must contain a string or a number!")
	end
	if type(timer) ~= "number" then
		error("ResetTimeEvent argument 3 must contain a number!")
	end
	if (ev_queue[ev_id] and ev_queue[ev_id][act_id]) then
		ev_queue[ev_id][act_id].timer = time_global() + timer*1000
	end
end

function ReturnTimeEventTime(ev_id,act_id)
	if not (type(ev_id) == "number" or type(ev_id) == "string") then
		error("ReturnTimeEventTime argument 1 must contain a string or a number!")
	end
	if not (type(act_id) == "number" or type(act_id) == "string") then
		error("ReturnTimeEventTime argument 2 must contain a string or a number!")
	end
	if (ev_queue[ev_id] and ev_queue[ev_id][act_id]) and ev_queue[ev_id][act_id].timer then
		return (ev_queue[ev_id][act_id].timer - time_global())/1000
	end
end

function IsTimeEventTime(ev_id,act_id)
	if not (type(ev_id) == "number" or type(ev_id) == "string") then
		error("IsTimeEventTime argument 1 must contain a string or a number!")
	end
	if not (type(act_id) == "number" or type(act_id) == "string") then
		error("IsTimeEventTime argument 2 must contain a string or a number!")
	end
	if (ev_queue[ev_id] and ev_queue[ev_id][act_id]) then
		return true
	end

	return false
end
-------------------------------------------

function ProcessEventQueue()
	-- if (has_alife_info("sleep_active")) then
		-- return false
	-- end
	
	local m_data = alife_storage_manager.get_state()
	local timer_data = m_data.global_hud_timer
	if (timer_data) then
		local hud = get_hud()
		local hud_timer = hud:GetCustomStatic("hud_timer") and hud:GetCustomStatic("hud_timer"):wnd()
		if (hud_timer) then
			local nn = time_global() - timer_data[4]
			local value_time = 0
			if timer_data[1] == 0 then
				value_time = timer_data[2] + nn
			else
				value_time = timer_data[2] - nn
			end
			if value_time <= 0 then
				value_time = 0
			end

			local hours = math.floor(value_time/3600000)
			local minutes = math.floor(value_time/60000 - hours*60)
			local seconds = math.floor(value_time/1000 - hours*3600 - minutes*60)
			local str = tostring(hours):add_all(":", sr_timer.time2str(minutes), ":", sr_timer.time2str(seconds))
			hud_timer:TextControl():SetTextST(str)
			
			if (timer_data[1] == 0 and value_time >= timer_data[3]) then
				SendScriptCallback("HudTimerCallback",timer_data[5],timer_data)
				RemoveHudTimer()
			elseif (value_time <= timer_data[3]) then
				SendScriptCallback("HudTimerCallback",timer_data[5],timer_data)
				RemoveHudTimer()
			end
		else
			hud:AddCustomStatic("hud_timer", true)
			hud:AddCustomStatic("hud_timer_text", true)
			local timer_text = hud:GetCustomStatic("hud_timer_text"):wnd()
			timer_text:TextControl():SetTextST(timer_data[6] or "")
		end
	end

	return false
end

function SetSwitchDistance(dist)
	if (alife()) then
		local p = net_packet()
		p:w_begin(18)
		p:w_float(dist or 2.0)
		level.send(p,true,true)
	end
end

function ChangeLevel(pos,lvid,gvid,angle)
-- IMPORTANT: You must realize that when you send this event it will happen immediately
-- if done in lua code it will not execute the rest of the block, level changes immediately happen!
--[[
		NET_Packet	p;
		p.w_begin	(M_CHANGE_LEVEL); -- M_CHANGE_LEVEL == 13
		p.w			(&m_game_vertex_id,sizeof(m_game_vertex_id));
		p.w			(&m_level_vertex_id,sizeof(m_level_vertex_id));
		p.w_vec3	(m_position);
		p.w_vec3	(m_angles);
		Level().Send(p,net_flags(TRUE));
--]]
	-- requires OpenXRay
	local p = net_packet()
	p:w_begin(13)
	p:w_u16(gvid)
	p:w_u32(lvid)
	p:w_vec3(pos)
	p:w_vec3(angle)
	level.send(p,true)
end

local UniqueCall = {}
function AddUniqueCall(functor_a)
	for id, val in pairs(UniqueCall) do
		if val and val.status == false then
			-- clearing data from memory
			UniqueCall[id] = nil
		end
	end
	if not UniqueCall[functor_a] then
		UniqueCall[functor_a] = {}
		UniqueCall[functor_a].status = true
		UniqueCall[functor_a].functor = functor_a
		UniqueCall[functor_a].stop = function()
			error("--Due to the level.remove_call error, the %s was terminated abruptly! ",UniqueCall[functor_a].functor)
			UniqueCall[functor_a] = nil
		end
		
		UniqueCall[functor_a].wrapper = function ()
			if UniqueCall[functor_a] and UniqueCall[functor_a].status and UniqueCall[functor_a].functor() then
				UniqueCall[functor_a].status = false
			end

			if UniqueCall[functor_a] and not UniqueCall[functor_a].status then
				if level then
					level.remove_call(UniqueCall[functor_a].wrapper)
				end
				error("level.remove_call %s",functor_a)
				return true
			end
		end

		level.add_call(UniqueCall[functor_a].wrapper,UniqueCall[functor_a].stop)
	end
end 

function RemoveUniqueCall(functor_a)
	if UniqueCall[functor_a] then
		UniqueCall[functor_a].status = false
	end
end

function JumpToLevel(new_level)
	-- requires OpenXray
	local level_name = level.name()
	if (level_name == new_level) then
		return false
	end
	
	local cvertex
	local sim,gg = alife(),game_graph()
	-- first try to find a smart_terrain on specified level
	for id,smart in pairs(db.smart_terrain_by_id) do
		cvertex = smart and gg:vertex(smart.m_game_vertex_id)
		if (cvertex and sim:level_name(cvertex:level_id()) == new_level) then
			ChangeLevel(cvertex:level_point(),cvertex:level_vertex_id(),smart.m_game_vertex_id,VEC_ZERO)
			return true
		end
	end

	-- in case level has no smarts then just teleport to first found gvid for level
	for gvid=0, 5332 do
		if gg:valid_vertex_id(gvid) then
			cvertex = gg:vertex(gvid)
			lvl = sim:level_name(cvertex:level_id())
			if (lvl == new_level) then
				ChangeLevel(cvertex:level_point(),cvertex:level_vertex_id(),gvid,VEC_ZERO)
				return true
			end
		else
			break
		end
	end
	return false
end

function TeleportObject(id,pos,lvid,gvid)
	-- Requires OpenXray
	if (db.offline_objects[id]) then
		db.offline_objects[id].level_vertex_id = nil
	end
	db.spawned_vertex_by_id[id] = nil
	alife():teleport_object(id,gvid,lvid,pos)
end

function TeleportSquad(squad,pos,lvid,gvid)
	-- Requires OpenXray
	local sim = alife()
	sim:teleport_object(squad.id,gvid,lvid,pos)
	for k in squad:squad_members() do
		if (db.offline_objects[k.id]) then
			db.offline_objects[k.id].level_vertex_id = nil
		end
		db.spawned_vertex_by_id[k.id] = nil
		sim:teleport_object(k.id,gvid,lvid,pos)
	end
end

function IsAzazelMode()
	return axr_main.config and axr_main.config:r_value("character_creation","new_game_azazel_mode",1) == true or alife_storage_manager.get_state().enable_azazel_mode == true
end

function IsHardcoreMode()
	return axr_main.config and axr_main.config:r_value("character_creation","new_game_hardcore_mode",1) == true or alife_storage_manager.get_state().uuid ~= nil
end

function IsStoryMode()
	return axr_main.config and axr_main.config:r_value("character_creation","new_game_story_mode",1) == true or not has_alife_info("story_mode_disabled")
end

function IsSurvivalMode()
	return axr_main.config and axr_main.config:r_value("character_creation","new_game_survival_mode",1) == true or alife_storage_manager.get_state().enable_survival_mode == true
end

---------------------------------------------------------------------------------------------
-- Serialization of userdata for Marshal Library
---------------------------------------------------------------------------------------------
if (marshal) then
	function game_CTime___persist(self)
		local Y, M, D, h, m, s, ms = 0,0,0,0,0,0,0
		if (self and self.get) then
			Y, M, D, h, m, s, ms = self:get(Y, M, D, h, m, s, ms)
		end
		return function ()
			local t = game.CTime()
			t:set(Y, M, D, h, m, s, ms)
			return t
		end
	end
	getmetatable(game.CTime()).__persist = game_CTime___persist
end

-- debug to find objects that shouldn't be calling game_object:alive()
--[[
game_object.alive = function(self)
	callstack()
	printf("alive %s",self:name())
	local se_obj = alife_object(self:id())
	return se_obj:alive()
end
--]]

---------------------------------------------------------------------------------------------
--							FUNCTIONS FOR HANDS ANIMATIONS
---------------------------------------------------------------------------------------------
-- Run the animation and all related methods
-- parameter 1 = (true/false) - lock the control before starting the animation and unlock it only when it is finished
-- parameter 2 = (true/false) - Block the initialization of the active slot before starting the animation
-- parameter 3 = (true/false) - Interaction of the animation with the active item in the hands
-- parameter 4 = (table) - Table for filling in the animation data table
function StartAnimHands(...)
	return area_enhanced_animations.start_animation_hands(...)
end
----Force abort the animation or execute the function after the animation is finished.
function StopAnimHands()
	return area_enhanced_animations.stop_animation_hands()
end
--CallbackAnimHands - these are the callbacks of the script events
--CallbackAnimHands('start_anim') - this is the animation launch event
--CallbackAnimHands('stop_anim') - this is the animation stop event
--CallbackAnimHands('anim_update') - this is an animation update event
--CallbackAnimHands('animation_control') - this is a Unique controller for controlling the current animation
function CallbackAnimHands(...)
	return area_enhanced_animations.CallbackEvent(...)
end
--Bulk data replacement in the animation table, accepts the table
function AddDataAnimHands(...)
	return area_enhanced_animations.supplement_data_table(...)
end
--Direct link to the data table for animation
function TableAnimHands()
	return area_enhanced_animations.anim_hands
end
--------------------------------------------------------------------------------------------
-- 										DOF Manager
--------------------------------------------------------------------------------------------
local table_dof_default = {
	kernel = "2",
	far = "800",
	near = "-0.4",
	sky =  "0",
	focus = "1.4"
}

function AddDOF(tables)
	for id,value in pairs(tables) do
		get_console():execute(string.add_all("r2_dof_", id, " ", value))
	end
end

function DefaultDOF()
	for id,value in pairs(table_dof_default) do
		get_console():execute(string.add_all("r2_dof_", id, " ", value))
	end
end
--------------------------------------------------------------------------------------------
-- Save the audio object and its duplicates to reuse the audio without creating a new object for it.
-- "path" - the path to the sound to create a sound object.
-- "duplicates" - the number of duplicate sounds in the form of objects, if the first object is occupied, a duplicate will be used, otherwise, it will return the first object.
-- New method "default_play" default method for launching sound from an actor object via the play sound method.
-- New method "default_play_no_feedback" default method for launching sound from an actor object via the play_no_feedback sound method.
-- New method "default_play_at_pos" default method for starting the sound from the actor object and its position using the play_at_pos sound playback method.
-- New method "stop_all" Stops all used sounds via CreateSound returns the object of the current sound and a table of sounds that have interrupted their work.
-- New method "set_frequency" Forcibly assigns the tone of the sound.
-- New method "set_volume" Forcibly sets the sound volume.
-- New method "MaxDistance" forcibly sets the maximum sound distance.
-- New method "MinDistance" forcibly sets the minimum sound distance.
-- New method "position_on_bone" Positions the sound on the object's bone.
-- New method "position_add" Sets a new sound position or corrects the sound position, the first argument "function" should return the position.
-- New method "play_at_circle" starts the sound and restarts it cyclically, the function starts from the last argument, which, if it returns true, interrupts the method.
-- the second argument is the way to set the sound position, "update" completely sets the new sound position, " add "correction of the sound position," sub " alignment of the sound position.
-- The function unloads the sound cache of the engine, eliminating the possibility of missing sounds during playback.
-- Use CreateSound instead of the standard sound_object method, the sound cache will thank you for this :).
-- Concept and implementation by MAGILA
local sound_object_save = {}
function CreateSound(path, duplicates)
	if not duplicates then duplicates = 1 end
	if not sound_object_save[path] then
		sound_object_save[path] = {}
		sound_object_save[path].id_obj = 0
		for i=1, duplicates do
			sound_object_save[path][i] = sound_object(path)
		end
	end
	local function new_method(snd_obj)
		function snd_obj:update(function_)
			if not snd_obj.up_func then
				snd_obj.up_func = {}
				snd_obj.up_progress = false
			end

			table.insert(snd_obj.up_func, function_);
			if not snd_obj.up_progress then
				AddUniqueCall(function()
					if snd_obj:playing() then
						snd_obj.up_progress = true
						for _, func in pairs(snd_obj.up_func) do
							func()
						end
					else
						iempty_table(snd_obj.up_func)
						snd_obj.up_progress = false
						return true
					end
				end)
			end
		end

		function snd_obj:default_play()
			snd_obj:play(db.actor, 0, sound_object.s2d)
			return snd_obj
		end

		function snd_obj:default_play_no_feedback(type)
			local vectors = (not type or type == "center") and VEC_ZERO
			or type == "left" and vector():set(-1, 0, 1)
			or type == "right" and vector():set( 1, 0, 1)
			snd_obj:play_no_feedback(db.actor, sound_object.s2d, 0, vectors, 1.0)
			return snd_obj
		end

		function snd_obj:default_play_at_pos()
			snd_obj:play_at_pos(db.actor, db.actor:position())
			return snd_obj
		end

		function snd_obj:stop_all()
			local table_stop_sounds = {}
			for id, value in pairs(sound_object_save) do
				if value and value:playing() then
					table_stop_sounds[id] = value
					value:stop()
				end
			end
			return snd_obj, table_stop_sounds
		end

		function snd_obj:set_frequency(f)
			snd_obj.frequency = f
			snd_obj:update(function()
				snd_obj.frequency = f
			end)
			return snd_obj
		end

		function snd_obj:set_volume(v)
			snd_obj.volume = v
			snd_obj:update(function()
				snd_obj.volume = v
			end)
			return snd_obj
		end

		function snd_obj:MaxDistance(v)
			snd_obj.max_distance = v
			snd_obj:update(function()
				snd_obj.max_distance = v
			end)
			return snd_obj
		end
		
		function snd_obj:MinDistance(v)
			snd_obj.min_distance = v
			snd_obj:update(function()
				snd_obj.min_distance = v
			end)
			return snd_obj
		end

		function snd_obj:position_on_bone(obj, bone, vectors)
			if obj then
				snd_obj:update(function()
					local position = bone and obj:bone_position(obj:get_bone_id(bone) == 65535 and "" or bone) or obj:position()
					if vectors then
						position:add(vectors)
					end
					snd_obj:set_position(position)
				end)
			else
				error("entity object not passed to position_on_bone position_on_body(obj, bone, vector).")
			end
			return snd_obj
		end

		function snd_obj:position_add(function_, t)
			if not t then
				error("position_add the method of updating the sound position is not specified, the second argument of the string must be specified (update, add, sub).")
				return snd_obj
			end
			if function_ and type(function_) == "function" then
				snd_obj:update(function()
					local position = snd_obj:get_position()
					if t == "update" then
						snd_obj:set_position(function_(position))
					elseif t == "add" then
						snd_obj:set_position(position:add(function_(position)))
					elseif t == "sub" then
						snd_obj:set_position(position:sub(function_(position)))
					end
				end)
			else
				error("position_add was expecting a function but received nil or another data type.")
			end
			return snd_obj
		end

		function snd_obj:play_at_circle(obj, position, delay, type_snd, function_)
			AddUniqueCall(function()
				if snd_obj and not snd_obj:playing() then
					if obj then	
						snd_obj:play_at_pos(obj, position, (delay or 0), (type_snd or sound_object.s3d))
						if function_ and type(function_) == "function" and function_(snd_obj, position) then
							snd_obj:stop()
							return true
						end
					end
				end
			end)
			return snd_obj
		end

		function snd_obj:progress_changed(function_, function_changed)
			snd_obj:update(function_)
			if function_changed and type(function_changed) == "function" then
				AddUniqueCall(function()
					if snd_obj.up_progress and not snd_obj.state then
						function_changed(true)
						snd_obj.state = true
					elseif not snd_obj.up_progress then
						function_changed(false)
						snd_obj.state = nil
						return true
					end
				end)
			end
		end

		return snd_obj
	end

	local function id_add()
		sound_object_save[path].id_obj = sound_object_save[path].id_obj+1
		local ids = 0
		for i, value in pairs(sound_object_save[path]) do
			if type(i) == "number" then
				ids = ids+1
			end
		end
		if sound_object_save[path].id_obj > ids then
			sound_object_save[path].id_obj = 1
		end
	end
	id_add()
	if sound_object_save[path][sound_object_save[path].id_obj]:playing() then
		id_add()
	end
	return new_method(sound_object_save[path][sound_object_save[path].id_obj])
end
--------------------------------------------------------------------------------------------

-- Save the particle object and its duplicate to reuse the particles without creating a new object for them.
-- "path" - the path to the particles to create a particle object.
-- "duplicates" - the number of repeated sounds in the form of objects, if the first object is occupied, a duplicate will be used, otherwise it will return the first object.
-- New method "update" is performed during playback of particles.
-- New method "position_on_bone" Positions the particles on the object's bone.
-- New method "play_at_circle" starts the particle and restarts it cyclically, the function starts from the last argument, which, if it returns true, interrupts the method.
-- New method "progress_changed" takes 2 arguments in the form of functions, the first is executed while particles are running, the second is executed at the start and end of particles play.
-- Use Create Particles instead of the standard method particles_object, do not clog the engine memory with garbage. :)
-- Сoncept and implementation by MAGILA 
local particles_object_save = {}
function CreateParticles(path, duplicates)
	if not duplicates then duplicates = 1 end

	if not particles_object_save[path] then
		particles_object_save[path] = {}
		particles_object_save[path].id_obj = 0
		for i=1, duplicates do
			particles_object_save[path][i] = particles_object(path)
		end
	end

	local function new_method(particles_obj)
		function particles_obj:update(function_)
			if not particles_obj.up_func then
				particles_obj.up_func = {}
				particles_obj.up_progress = false
			end

			table.insert(particles_obj.up_func, function_);
			if not particles_obj.up_progress then
				AddUniqueCall(function()
					if particles_obj:playing() then
						particles_obj.up_progress = true
						for _, func in pairs(particles_obj.up_func) do
							func()
						end
					else
						iempty_table(particles_obj.up_func)
						particles_obj.up_progress = false
						return true
					end
				end)
			end
		end

		function particles_obj:stop_all()
			local table_stop_particles = {}
			for id, value in pairs(particles_object_save) do
				if value and value:playing() then
					table_stop_particles[id] = value
					value:stop()
				end
			end
			return particles_obj, table_stop_particles
		end

		function particles_obj:position_on_bone(obj, bone, vectors)
			if obj then
				particles_obj:update(function()
					local position = bone and obj:bone_position(obj:get_bone_id(bone) == 65535 and "" or bone) or obj:position()
					particles_obj:move_to(position, vectors or VEC_ZERO)
				end)
			else
				error("entity object not passed to position_on_bone position_on_body(obj, bone, vector).")
			end
			return particles_obj
		end

		function particles_obj:play_at_circle(position, function_)
			AddUniqueCall(function()
				if particles_obj and not particles_obj:playing() then
					if function_ and type(function_) == "function" and function_() then
						return true
					end
					particles_obj:play_at_pos(position)
				end
			end)
			return particles_obj
		end

		function particles_obj:progress_changed(function_, function_changed)
			particles_obj:update(function_)
			if function_changed and type(function_changed) == "function" then
				AddUniqueCall(function()
					if particles_obj.up_progress and not particles_obj.state then
						function_changed(true)
						particles_obj.state = true
					elseif not particles_obj.up_progress then
						function_changed(false)
						particles_obj.state = nil
						return true
					end
				end)
			end
		end

		return particles_obj
	end

	local function id_add()
		particles_object_save[path].id_obj = particles_object_save[path].id_obj+1
		local ids = 0
		for i, value in pairs(particles_object_save[path]) do
			if type(i) == "number" then
				ids = ids+1
			end
		end
		if particles_object_save[path].id_obj > ids then
			particles_object_save[path].id_obj = 1
		end
	end
	id_add()
	if particles_object_save[path][particles_object_save[path].id_obj]:playing() then
		id_add()
	end
	return new_method(particles_object_save[path][particles_object_save[path].id_obj])
end
--------------------------------------------------------------------------------------------
--If you need to find an object by the identifier in the level space via level.object_by_id, use level_get_object,
--it will protect you from an endless search in the background if the object has been deleted.
--argument "id" the is actually an object identifier
--argument "_function" the function that should be executed after a successful search.
--argument "max_limit_timeout" Specify the maximum number of frames in which the search will be performed, by default it is 1000 iterations.
-- Сoncept and implementation by MAGILA 
function level_get_object(id, _function, max_limit_timeout, debug, _function_error)
	if not id or type(id) ~= "number" then return false end
	if _function and type(_function) ~= "function" then
		error("Function level_get_object the second argument is not a function")
		return false
	end
	local limit_timeout = 0

	if not max_limit_timeout then
		max_limit_timeout = 1000
	end

	AddUniqueCall(function()
		local obj = level.object_by_id(id)
		if obj then
			if debug then
				log("----------------------------------------------------")
				printf("- The function level_get_object successfully completed the object search and executed the method, iterations spent for the search (%s) ", limit_timeout)
				printf("- Object id (%s),  object section (%s), object name (%s)", id, obj:section(), obj:name())
				log("----------------------------------------------------")
			end
			if _function then
				_function(obj)
			end
			return true
		elseif limit_timeout <= max_limit_timeout then
			limit_timeout = limit_timeout+1
		else
			printf("~ Function level_get_object The waiting limit of box level object has been exceeded (id = %s) the waiting timeout exceeded %s", id, max_limit_timeout)
			if _function_error and type(_function_error)  == "function" then
				_function_error()
			end
			return true
		end
	end)

	return true
end

--If you need to find an object by the identifier in the level space via alife():object, use alife_get_object,
--it will protect you from an endless search in the background if the object has been deleted.
--argument "id" the is actually an object identifier
--argument "_function" the function that should be executed after a successful search.
--argument "max_limit_timeout" Specify the maximum number of frames in which the search will be performed, by default it is 1000 iterations.
-- Сoncept and implementation by MAGILA 
function alife_get_object(id, _function, max_limit_timeout, debug, _function_error)
	if not id or type(id) ~= "number" then return false end
	if _function and type(_function) ~= "function" then
		error("Function alife_get_object the second argument is not a function")
		return false
	end
	local limit_timeout = 0

	if not max_limit_timeout then
		max_limit_timeout = 1000
	end

	AddUniqueCall(function()
		local obj = alife():object(id)
		if obj then
			if debug then
				log("----------------------------------------------------")
				printf("- The function alife_get_object successfully completed the object search and executed the method, iterations spent for the search (%s) ", limit_timeout)
				printf("- Object id (%s),  object section (%s), object name (%s)", id, obj.section, obj:section_name())
				log("----------------------------------------------------")
			end
			if _function then
				_function(obj)
			end
			return true
		elseif limit_timeout <= max_limit_timeout then
			limit_timeout = limit_timeout+1
		else
			printf("~ Function alife_get_object The waiting limit of box alife object has been exceeded (id = %s) the waiting timeout exceeded %s", id, max_limit_timeout)
			if _function_error and type(_function_error)  == "function" then
				_function_error()
			end
			return true
		end
	end)

	return true
end
--------------------------------------------------------------------------------------------
-- forEach is a function of passing through the table, reproduces a limited number of iterations in one frame of the game.
-- "_function" is an iteration function that will be called every time at each iteration regardless of the current frame.
-- "_function_2" function of the shutdown event of the forEach function, if it is not necessary, pass nil or false
-- "iteration" specify the number of iterations for one frame of the game.
-- "..." pass the result of pairs, ipairs, alife():object() and the like.
-- Use it instead of the usual heavy "for do" over 10 thousand iterations to reduce the likelihood of a short-term hang of the game.
-- Remember, the function is executed in the next frame, and the result can only be transmitted inside the event.
-- Сoncept and implementation by MAGILA
function forEach(_function, _function_2, iteration, ...)
	if _function and type(_function) ~= "function" then
		error("Function forEach - second argument is not a function")
		return false
	end
	if not iteration then
		iteration = 1000 --Set the default to 1000 iterations per frame.
	end
	local send, _table, beginning = ...
	AddUniqueCall(function()
		local state = false
		local id, val
		for i = 1, iteration do
			id, val = send(_table, beginning)
			beginning = id
			if id ~= nil then
				--Calling the iteration function.
				if _function(id, val) then
					state = true
					break
				end
			else
				state = true
				break
			end
		end

		if state then
			if _function_2 and type(_function_2) == "function" then
				--the method shutdown event.
				_function_2(id, val)
			end
			return true
		end
	end)
end
--------------------------------------------------------------------------------------------

function is_empty(t)
	if not (t) then
		return true
	end
	for i,j in pairs(t) do
		return false
	end
	return true
end

function strformat(text,...)
	if not (text) then return end
	local i = 0
	local p = {...}
	local function sr(a)
		i = i + 1
		if (type(p[1]) == "userdata") then
			return "userdata"
		end
		return tostring(p[i])
	end
	-- so that it doesn't return gsub's multiple returns
	local s = string.gsub(text,"%%s",sr)
	return s
end

-- Used by modules.script for generic module management
schemes = {}
schemes_by_stype = {}
function LoadScheme(filename, scheme, ...)
	if not (_G[filename]) then
		error("Trying to load scheme that does not exist! %s",filename)
		return
	end
	schemes[scheme] = filename
		local p = {...}
	for i=1,#p do
		if not (schemes_by_stype[p[i]]) then
			schemes_by_stype[p[i]] = {}
		end
		schemes_by_stype[p[i]][scheme] = true
	end
end

function printf(fmt,...)
	if not (fmt) then return end
	local fmt = tostring(fmt)

	if (select('#',...) >= 1) then
		local i = 0
		local p = {...}
		local function sr(a)
			i = i + 1
			if (type(p[i]) == 'userdata') then
				if (p[i].x and p[i].y) then
					return vec_to_str(p[i])
				end
				return 'userdata'
			end
			return tostring(p[i])
		end
		fmt = string.gsub(fmt,"%%s",sr)
	end
	if (log) then
		log(fmt)
		--get_console():execute("flush")
	else
		get_console():execute(string.add("load ~#debug msg:", fmt))
	end	
end

function error(fmt, ...)
	if not fmt then
		return
	end
	log("---------------------------------------------------")
	printf(string.add("!ERROR: ", fmt), ...)
	log("! function call stack!")
	callstack()
	log("---------------------------------------------------")
end

function spairs(t, order)
    -- collect the keys
    local keys = {}
    for k in pairs(t) do keys[#keys+1] = k end

    -- if order function given, sort by it by passing the table and keys a, b,
    -- otherwise just sort the keys
    if order then
        table.sort(keys, function(a,b) return order(t, a, b) end)
    else
        table.sort(keys)
    end

    -- return the iterator function
    local i = 0
    return function()
        i = i + 1
        if keys[i] then
            return keys[i], t[keys[i]]
        end
    end
end
----------------------------------------------------------------------
function time_global()
	return device():time_global()
end
----------------------------------------------------------------------
--Возращает реальное время между вызовами функции.
local tbl_name = {}
function time_global_delta(name)
	if (not name) then
		error("time_global_delta the parameter was not passed as a string, the parameter == nil.")
	elseif type(name) ~= "string" then
		error("time_global_delta the name argument is not a string.")
	end

	local time = time_global()
	if not tbl_name[name] then
		tbl_name[name] = time
	end
	if tbl_name[name] < time then
		local t_ceh = tbl_name[name]
		tbl_name[name] = time
		return time - t_ceh
	end
	return 0
end

--Возращает игровое время между вызовами функции.
local tbl_name_game = {}
function time_game_delta(name)
	if game then
		if (not name) then
			error("time_game_delta the parameter was not passed as a string, the parameter == nil.")
		elseif type(name) ~= "string" then
			error("time_game_delta the name argument is not a string.")
		end
	
		local time = game.get_game_time()
		if not tbl_name[name] then
			tbl_name[name] = time
		end
		local result = time:diffSec(tbl_name[name])
		if result > 0 then
			tbl_name[name] = time
			return result
		end
	end
	return 0
end
----------------------------------------------------------------------
--1 argument takes in a function, and assigns a unique id in memory to the address of the function for the operation of limiting function calls by time.
--2 the argument takes number, this is the delay time in seconds.
-- The remaining arguments are optionally passed to the called function.
--LimitUpdate Сoncept and implementation by MAGILA
local limit_up = {}
function LimitUpdate(_func, sec, ...)
	if (not _func) then
		error("limit_update the parameter was not passed as a function, the parameter == nil.")
	elseif type(_func) ~= "function" then
		error("limit_update 1 the argument is not a function.")
	elseif not sec then
		error("limit_update 2 argument was not passed and is equal to nil.")
	elseif type(sec) ~= "number" then
		error("limit_update 2 the argument is not a number.")
	elseif not limit_up[_func] then
		limit_up[_func] = {}
		limit_up[_func].time = time_global()
		limit_up[_func].func = _func
		return _func(...)
	elseif limit_up[_func] and limit_up[_func].time < time_global() then
		limit_up[_func].time = time_global() + (1000*sec)
		return limit_up[_func].func(...)
	elseif limit_up[_func] and limit_up[_func].time > 429460000 then
		--Unlikely overflow of the digital unit of the data type. Fixed for correct operation.
		--time_global has a data type in the game engine u32 the maximum value is 4294967295
		limit_up[_func].time = 0
	end
	
	return false
end
--------------------------------------------------------------------------------------------

function action(obj,...)
	local arg = {...}
	local e_act = entity_action()
	for i=1,#arg do 
		e_act:set_action(arg[i])
	end 
	if (obj ~= nil) then
		obj:command(e_act,false)
	end
	return entity_action(e_act)
end

function action_first(obj,...)
	local arg = {...}
	local e_act = entity_action()
	for i=1,#arg do 
		e_act:set_action(arg[i])
	end 
	if (obj ~= nil) then
		obj:command(e_act,true)
	end
	return entity_action(e_act)
end

function distance_between(obj1, obj2)
	return obj1:position():distance_to(obj2:position())
end

-- Если один объект nil, например нет актера, то считаем, что он далеко
function distance_between_safe(obj1, obj2)
	if(obj1 == nil or obj2 == nil) then return 100000 end
	return obj1:position():distance_to(obj2:position())
end

-- Проверка на инфопоршнv, даже если игрока не существует
function has_alife_info(info_id)
	local sim = alife()
	return sim:has_info(0, info_id)
end

function reset_action (npc, script_name)
	if npc:get_script () then
		 npc:script (false, script_name)
	end
	npc:script (true, script_name)
end

--------------------------------------------------
-- Functions and variables added by Zmey
--------------------------------------------------

-- Константа, которую использовать в местах, где нужно задать неограниченное время действия
time_infinite = 100000000

-- Если в данный момент выполняется какое-то действие, прерывает его и отключает скриптовый режим
function interrupt_action(who, script_name)
	if who:get_script() then
		who:script(false, script_name)
	end
end

function random_choice(...)
	local arg = {...}
	if (#arg > 0) then
		local r = math.random(1, #arg)
		return arg[r]
	end
end

function random_number (min_value, max_value)
	if min_value == nil and max_value == nil then
		return math.random ()
	else
		return math.random (min_value, max_value)
	end
end

function parse_names( s )
	local t = {}
	--for name in string.gmatch( s, "([%w_\\]+)%p*" ) do
		--callstack()
	for name in string.gmatch( s, "([%w_%-.\\]+)%p*" ) do
		t[#t+1] = name
	end
	return t
end

function parse_key_value( s )
	local t = {}
	if s == nil then
		return nil
	end
	local key, nam = nil, nil
	for name in string.gmatch( s, "([%w_\\]+)%p*" ) do
		if key == nil then
			key = name
		else
			t[key] = name
			key = nil
		end
	end
	return t
end

function parse_nums( s )
	local t = {}
	for entry in string.gmatch( s, "([%-%d%.]+)%,*" ) do
		t[#t+1] = tonumber(entry)
	end
	return t
end

function get_clsid(obj)
	if not (obj) then
		error("get_clsid - obj is nil!")
		return
	end
	if not (obj.clsid) then
		error("no clsid method for %s",obj:name())
		return
	end
	return obj:clsid()
end

--Вычисляет yaw в радианах
function yaw( v1, v2 )
	return  math.acos( ( (v1.x*v2.x) + (v1.z*v2.z ) ) / ( math.sqrt(v1.x*v1.x + v1.z*v1.z ) * math.sqrt(v2.x*v2.x + v2.z*v2.z ) ) )
end
function yaw_degree( v1, v2 )
	return  (math.acos( ( (v1.x*v2.x) + (v1.z*v2.z ) ) / ( math.sqrt(v1.x*v1.x + v1.z*v1.z ) * math.sqrt(v2.x*v2.x + v2.z*v2.z ) ) ) * 57.2957)
end
function yaw_degree3d( v1, v2 )
	return  (math.acos((v1.x*v2.x + v1.y*v2.y + v1.z*v2.z)/(math.sqrt(v1.x*v1.x + v1.y*v1.y + v1.z*v1.z )*math.sqrt(v2.x*v2.x + v2.y*v2.y + v2.z*v2.z)))*57.2957)
end
function vector_cross(v1, v2)
	return vector():set(v1.y  * v2.z  - v1.z  * v2.y, v1.z  * v2.x  - v1.x  * v2.z, v1.x  * v2.y  - v1.y  * v2.x)
end

--Поворачивает вектор вокруг оси y против часовой стрелки.
function vector_rotate_y(v, angle)
	angle = angle * 0.017453292519943295769236907684886
	local c = math.cos (angle)
	local s = math.sin (angle)
	return vector ():set (v.x * c - v.z * s, v.y, v.x * s + v.z * c)
end

-- очистка таблицы.
function iempty_table (t)
	if not (t) then
		return {}
	end
	while #t > 0 do
		table.remove(t)
	end
	return t
end

function empty_table(t)
	if not (t) then
		return {}
	end
	for k,v in pairs(t) do
		t[k] = nil
	end
	return t
end

function stop_play_sound(obj)
	if (IsStalker(obj) and not obj:alive()) then
		return
	end
	obj:set_sound_mask(-1)
	obj:set_sound_mask(0)
end

-- Печатает таблицу как дерево.
function print_table(table, subs)
	--[[
	local sub
	if subs ~= nil then
		sub = subs
	else
		sub = ""
	end
	for k,v in pairs(table) do
		if type(v) == "table" then
			print_table(v, sub.."["..k.."]----->")
		elseif type(v) == "function" then
			printf(sub.."%s = function",k)
		elseif type(v) == "userdata" then
			if (v.x) then
				printf(sub.."%s = %s",k,alun_utils.vector_to_string(v))
			else
				printf(sub.."%s = userdata", k)
			end
		elseif type(v) == "boolean" then
					if v == true then
							if(type(k)~="userdata") then
									printf(sub.."%s = true",k)
							else
									printf(sub.."userdata = true")
							end
					else
							if(type(k)~="userdata") then
									printf(sub.."%s = false", k)
							else
									printf(sub.."userdata = false")
							end
					end
		else
			if v ~= nil then
				printf(sub.."%s = %s", k,v)
			else
				printf(sub.."%s = nil", k,v)
			end
		end
	end
	--]]
end
function store_table(table, subs)
	local sub
	if subs ~= nil then
		sub = subs
	else
		sub = ""
	end
	log(sub:add("{"))
	for k,v in pairs(table) do
		if type(v) == "table" then
			printf(sub:add("%s = "), tostring(k))
			store_table(v, sub:add("    "))
		elseif type(v) == "function" then
			printf(sub:add("%s = \"func\","), tostring(k))
			elseif type(v) == "userdata" then
					printf(sub:add("%s = \"userdata\","), tostring(k))
		elseif type(v) == "string" then
			printf(sub:add("%s = \"%s\","), tostring(k), tostring(v))
		else
			printf(sub:add("%s = %s,"), tostring(k), tostring(v))
		end
	end
	log(sub:add("},"))
end
----------------------------------------
function IsWounded(o)
	if not (o:clsid() == clsid.script_stalker and o:alive()) then 
		return false 
	end 
	
	if (o:critically_wounded() or o:in_smart_cover()) then 
		return false 
	end
	
	if o:best_enemy() and utils.load_var(o, "wounded_fight") == "true" then
		return false
	end
	
	local state = tostring(utils.load_var(o, "wounded_state"))
	if (state == "nil") then
		return false
	end
	
	return true
end
-------------------------------------------------------------------------------------------
-- 										CLASS TESTING
-------------------------------------------------------------------------------------------

function IsOutfit(o,c)
	if not c then
		c = o and o:clsid()
	end
	return c and (c == clsid.equ_stalker_s or c == clsid.equ_stalker)
end

function IsHeadgear(o,c)
	if not c then
		c = o and o:clsid()
	end
	return c and (c == clsid.equ_helmet_s or c == clsid.equ_helmet)
end

function IsBackpack(o,c)
	if not c then
		c = o and o:clsid()
	end
	return c and (c == clsid.equ_backpack_s or c == clsid.equ_backpack)
end

function IsBackpackBox(o,c)
	if not c then
		c = o and o:clsid()
	end
	return c and (c == clsid.box_backpack_s or c == clsid.box_backpack)
end

function IsExplosive(o,c)
	if not c then
		c = o and o:clsid()
	end
	return c and (c == clsid.obj_explosive_s or  c == clsid.obj_explosive)
end

function IsKnife(o,c)
	if not (c) then
		c = o and o:clsid()
	end
	
	local knife = {
		[clsid.wpn_knife] = true,
		[clsid.wpn_knife_s] = true,
	}
	return c and knife[c] or false
end

function IsPistol(o,c)
	if not (c) then
		c = o and o:clsid()
	end
	local pistol = {
		[clsid.wpn_pm_s] = true,
		[clsid.wpn_walther_s] = true,
		[clsid.wpn_usp45_s] = true,
		[clsid.wpn_hpsa_s] = true,
		[clsid.wpn_pm] = true,
		[clsid.wpn_walther] = true,
		[clsid.wpn_usp45] = true,
		[clsid.wpn_hpsa] = true
	}
	return c and pistol[c] or false
end

function IsSniper(o,c)
	if not (c) then
		c = o and o:clsid()
	end
	local sniper = {
		[clsid.wpn_svu_s] = true,
		[clsid.wpn_svd_s] = true,
		[clsid.wpn_vintorez_s] = true,
		[clsid.wpn_svu] = true,
		[clsid.wpn_svd] = true,
		[clsid.wpn_vintorez] = true
	}
	return c and sniper[c] or false
end

function IsLauncher(o,c)
	if not (c) then
		c = o and o:clsid()
	end
	local launcher = {
		[clsid.wpn_rg6_s] = true,
		[clsid.wpn_rpg7_s] = true,
		[clsid.wpn_rg6] = true,
		[clsid.wpn_rpg7] = true
	}
	return c and launcher[c] or false
end

function IsShotgun(o,c)
	if not (c) then
		c = o and o:clsid()
	end
	local shotgun = {
		[clsid.wpn_bm16_s] = true,
		[clsid.wpn_shotgun_s] = true,
		[clsid.wpn_auto_shotgun_s] = true,
		[clsid.wpn_bm16] = true,
		[clsid.wpn_shotgun] = true
		--[clsid.wpn_auto_shotgun] = true
	}
	return c and shotgun[c] or false
end

function IsMultiLoad(o,c)
	if not (c) then
		c = o and o:clsid()
	end
	local multiload = {
		[clsid.wpn_rg6_s] = true,
		[clsid.wpn_rg6] = true,
		[clsid.wpn_auto_shotgun_s] = true,
	}
	return c and multiload[c] or false
end

function IsRifle(o,c)
	if not (c) then
		c = o and o:clsid()
	end
	local rifle = {
		[clsid.wpn_ak74_s] = true,
		[clsid.wpn_groza_s] = true,
		[clsid.wpn_lr300_s] = true,
		[clsid.wpn_val_s] = true,
		[clsid.wpn_ak74] = true,
		[clsid.wpn_groza] = true,
		[clsid.wpn_lr300] = true,
		[clsid.wpn_val] = true
	}
	return c and rifle[c] or false
end

function IsMonster(o,c)
	if not (c) then
		c = o and o:clsid()
	end
	local monster_classes = {
		[clsid.bloodsucker_s] 			= true,
		[clsid.boar_s] 					= true,
		[clsid.burer_s] 				= true,
		[clsid.cat_s] 					= true,
		[clsid.chimera_s] 				= true,
		[clsid.controller_s] 			= true,
		[clsid.dog_s] 					= true,
		[clsid.flesh_s] 				= true,
		[clsid.fracture_s] 				= true,
		[clsid.gigant_s] 				= true,
		[clsid.karlik_s]				= true,
		[clsid.medwed_s] 				= true,
		[clsid.poltergeist_s] 			= true,
		[clsid.pseudodog_s] 			= true,
		[clsid.psy_dog_phantom_s] 		= true,
		[clsid.psy_dog_s] 				= true,
		[clsid.rat] 					= true,
		[clsid.rat_s]					= true,
		[clsid.snork_s] 				= true,
		[clsid.stronglav_s] 			= true,
		[clsid.tushkano_s] 				= true,
		[clsid.vodianoy_s] 				= true,
		[clsid.zombie_s] 				= true
	}
	return c and monster_classes[c] or false
end

function IsAnomaly(o,c)
	if not (c) then
		c = o and o:clsid()
	end
	local anomaly_classes = {
		[clsid.zone]				= true,
		[clsid.zone_acid_fog]		= true,
		[clsid.zone_bfuzz]			= true,
		[clsid.zone_campfire]		= true,
		[clsid.zone_dead]			= true,
		[clsid.zone_galantine]		= true,
		[clsid.zone_mincer]			= true,
		[clsid.zone_mosquito_bald]	= true,
		[clsid.zone_radioactive]	= true,
		[clsid.zone_rusty_hair]		= true,
		[clsid.zone_bfuzz_s]		= true,
		[clsid.zone_mbald_s]		= true,
		[clsid.zone_galant_s]		= true,
		[clsid.zone_mincer_s]		= true,
		[clsid.zone_radio_s]		= true,
		[clsid.zone_torrid_s]		= true,
		[clsid.zone_nograv_s]		= true,
	}
	return c and anomaly_classes[c] or false
end

function isLc(obj)
	if not obj then
		return false
	end
	
	return (obj:clsid() == clsid.level_changer)
end

function IsStalker(o,c)
	if not (c) then
		c = o and o:clsid()
	end
	return c and (c == clsid.script_stalker or c == clsid.script_actor) or false
end

function IsTrader(o,c)
	if not (c) then
		c = o and o:clsid()
	end
	return c and (c == clsid.script_trader) or false
end 

function IsHelicopter(o,c)
	if not (c) then
		c = o and o:clsid()
	end
	return c and (c == clsid.helicopter or c == clsid.car or c == clsid.script_heli) or false
end

function IsWeapon(o,c)
	if not (c) then
		c = o and o:clsid()
	end
	local weapon_classes = {
		[clsid.wpn_vintorez_s] 			= true,
		[clsid.wpn_ak74_s] 				= true,
		[clsid.wpn_lr300_s] 			= true,
		[clsid.wpn_hpsa_s] 				= true,
		[clsid.wpn_pm_s] 				= true,
		[clsid.wpn_shotgun_s] 			= true,
		[clsid.wpn_auto_shotgun_s]		= true,
		[clsid.wpn_bm16_s] 				= true,
		[clsid.wpn_svd_s] 				= true,
		[clsid.wpn_svu_s] 				= true,
		[clsid.wpn_rg6_s] 				= true,
		[clsid.wpn_rpg7_s] 				= true,
		[clsid.wpn_val_s] 				= true,
		[clsid.wpn_walther_s] 			= true,
		[clsid.wpn_usp45_s] 			= true,
		[clsid.wpn_groza_s] 			= true,
		[clsid.wpn_knife_s] 			= true,
		[clsid.wpn_vintorez] 			= true,
		[clsid.wpn_ak74] 				= true,
		[clsid.wpn_lr300] 				= true,
		[clsid.wpn_hpsa] 				= true,
		[clsid.wpn_pm] 					= true,
		[clsid.wpn_shotgun] 			= true,
		--[clsid.wpn_auto_shotgun]		= true,
		[clsid.wpn_bm16] 				= true,
		[clsid.wpn_svd] 				= true,
		[clsid.wpn_svu] 				= true,
		[clsid.wpn_rg6] 				= true,
		[clsid.wpn_rpg7] 				= true,
		[clsid.wpn_val] 				= true,
		[clsid.wpn_walther] 			= true,
		[clsid.wpn_usp45] 				= true,
		[clsid.wpn_groza] 				= true,
		[clsid.wpn_knife] 				= true
	}
	return c and weapon_classes[c] or false
end

function IsAmmo(o,c)
	if not (c) then
		c = o and o:clsid()
	end
	return c and (c == clsid.wpn_ammo or c == clsid.wpn_ammo_s)
end

function IsAmmoGrenade(o,c)
	if not (c) then
		c = o and o:clsid()
	end
	local grenade_ammo_classes = {
		[clsid.wpn_ammo_vog25]		= true,
		[clsid.wpn_ammo_og7b]		= true,
		[clsid.wpn_ammo_m209]		= true,
		[clsid.wpn_ammo_vog25_s]	= true,
		[clsid.wpn_ammo_og7b_s]		= true,
		[clsid.wpn_ammo_m209_s]		= true
	}
	return c and grenade_ammo_classes[c] or false
end

function IsEat(o,c)
	if not (c) then
		c = o and o:clsid()
	end
	local eat_classes = {
		[clsid.obj_food] = true,
		[clsid.obj_food_s] = true,
		[clsid.obj_bottle] = true,
		[clsid.obj_medkit] = true,
		[clsid.obj_bandage] = true,
		[clsid.obj_antirad] = true
	}
	return c and eat_classes[c] or false
end

function IsGrenade(o,c)
	if not (c) then
		c = o and o:clsid()
	end
	if not (grenade_classes) then
		grenade_classes = {
			[clsid.wpn_grenade_f1_s] 		= true,
			[clsid.wpn_grenade_rgd5_s] 		= true,
			[clsid.wpn_grenade_launcher_s] 	= true,
			[clsid.wpn_grenade_fake] 		= true,
			[clsid.wpn_grenade_f1]			= true,
			[clsid.wpn_grenade_launcher] 	= true,
			[clsid.wpn_grenade_rgd5] 		= true,
			[clsid.wpn_grenade_rpg7]		= true
		}
	end
	return c and grenade_classes[c] or false
end

function IsBolt(o)
	return o and clsid.obj_bolt == o:clsid()
end

function IsArtefact(o,c)
	if not (c) then
		c = o and o:clsid()
	end
	local artefact_classes = {
		[clsid.art_bast_artefact] 		= true,
		[clsid.art_black_drops] 		= true,
		[clsid.art_dummy] 				= true,
		[clsid.art_electric_ball] 		= true,
		[clsid.art_faded_ball] 			= true,
		[clsid.art_galantine] 			= true,
		[clsid.art_gravi] 				= true,
		[clsid.art_gravi_black] 		= true,
		[clsid.art_mercury_ball] 		= true,
		[clsid.art_needles] 			= true,
		[clsid.art_rusty_hair] 			= true,
		[clsid.art_thorn] 				= true,
		[clsid.art_zuda] 				= true,
		[clsid.artefact] 				= true,
		[clsid.artefact_s] 				= true
	}
	return c and artefact_classes[c] or false
end

function IsInvbox(o,c)
	if not (c) then
		c = o and o:clsid()
	end
	return c and (c == clsid.inventory_box_s or c == clsid.inventory_box)
end

function IsSlotted(obj)
	local id = obj:id()
	local state = false
	db.actor:iterate_slots(function(_, item, slot)
		if item and item:id() == id then
			state = true
			return true
		end
	end)
	
	if state then
		return true
	end

	db.actor:iterate_belt(function(_, item)
		if item and item:id() == id then
			state = true
			return true
		end
	end)
	return state
end

function IsBoxItem(obj, item)
	if not obj then
		error("the box object is not passed or is equal to nil")
		return false
	end

	if not item then
		error("the item object is not passed or is equal to nil")
		return false
	end

	local parent = item:parent()
	if (IsInvbox(parent) or IsStalker(parent) or IsTrader(parent)) and parent:id() == obj:id() then
		return true
	end
	return false
end
-------------------------------------------------------------
-- 					SQUAD BEHAVIOR TESTING
-------------------------------------------------------------
is_squad_monster = {
		["monster_predatory_day"] 	= true,
		["monster_predatory_night"] = true,
		["monster_vegetarian"] 		= true,
		["monster_zombied_day"] 	= true,
		["monster_zombied_night"] 	= true,
		["monster_special_day"] 	= true,
		["monster_special_night"] 	= true,
		["monster"]					= true,
		["zoo_monster"]				= true
}
squad_community_by_behaviour = {
		["stalker"]							= "stalker",
		["bandit"]							= "bandit",
        ["csky"]							= "csky",
		["dolg"]							= "dolg",
		["freedom"]							= "freedom",
		["army"]							= "army",
		["ecolog"]							= "ecolog",
		["killer"]							= "killer",
		["zombied"]							= "zombied",
		["monolith"]						= "monolith",
		["monster"]							= "monster",
		["monster_predatory_day"]			= "monster",
		["monster_predatory_night"]			= "monster",
		["monster_vegetarian"]				= "monster",
		["monster_zombied_day"]				= "monster",
		["monster_zombied_night"]			= "monster",
		["monster_special_day"]				= "monster",
		["monster_special_night"]			= "monster",
		["zoo_monster"]						= "monster"
}
-------------------------------------------------------------------------------------------
function get_object_community(obj)
	if type(obj.id) == "function" then
		return character_community(obj)
	else
		return alife_character_community(obj)
	end
end

function character_community(obj)
	if not (obj) then
		return
	end
	if IsStalker(obj) or IsTrader(obj) then
		return obj:character_community()
	end
	return "monster"
end

function alife_character_community(obj)
	if not (obj) then
		return
	end
	if IsStalker(obj, obj:clsid()) or IsTrader(obj, obj:clsid()) then
		return obj:community()
	end
	return "monster"
end

-- получить геймобжект по стори_айди.
function level_object_by_sid( sid )
	local sim = alife()
	if sim then
		local se_obj = sim:story_object( sid )
		if se_obj then
			return level.object_by_id( se_obj.id )
		end
	end
	return nil
end
-- Получить айдишник обьекта по стори айди.
function id_by_sid( sid )
	local sim = alife()
	if sim then
		local se_obj = sim:story_object( sid )
		if se_obj then
			return se_obj.id
		end
	end
	return nil
end

function abort(msg, ...)
	if not (msg) then return end
	local fmt = tostring(msg)

	if (select('#',...) >= 1) then
		local i = 0
		local p = {...}
		local function sr(a)
			i = i + 1
			if (type(p[i]) == 'userdata') then
				return 'userdata'
			end
			return tostring(p[i])
		end
		fmt = string.gsub(fmt,"%%s",sr)
	end
		callstack()
	log(fmt)
	--[[
	error(fmt, 2)
	--]]
end

function set_inactivate_input_time(delta)
	db.storage[db.actor:id()].disable_input_time = game.get_game_time()
	db.storage[db.actor:id()].disable_input_idle = delta
	level.disable_input()
end

-- проверяет целую часть числа на нечетность
function odd( x )
	return math.floor( x * 0.5 ) * 2 == math.floor( x )
end

-- Находится ли NPC во фруструме игрока
function npc_in_actor_frustrum(npc)
	local actor_dir = device().cam_dir
	--local actor_dir = db.actor:direction()
	local npc_dir = vec_sub(npc:position(),db.actor:position())
	local yaw = yaw_degree3d(actor_dir, npc_dir)
	--printf("YAW %s", tostring(yaw))
	return yaw < 35
end

-- For tutorials activation
--[[
-- Усталость
function on_actor_critical_power()
end

function on_actor_critical_max_power()
end

-- Кровотечение
function on_actor_bleeding()
end

function on_actor_satiety()
end

-- Радиация
function on_actor_radiation()
end

-- Заклинило оружие
function on_actor_weapon_jammed()
end

-- Не может ходить изза веса
function on_actor_cant_walk_weight()
end

-- Пси воздействие
function on_actor_psy()
end
]]--
function give_info (info)
	db.actor:give_info_portion(info)
	--printf("DEBUG: GIVE INFO %s",info)
	--if (xrs_debug_tools and xrs_debug_tools.actor_info) then
	--	xrs_debug_tools.actor_info[info] = true
	--end
end
function disable_info (info)
	if has_alife_info(info) then
		--printf("DEBUG: DISABLE INFO %s",info)
		--printf("*INFO*: disabled npc='single_player' id='%s'", info)
		db.actor:disable_info_portion(info)
		--if (xrs_debug_tools and xrs_debug_tools.actor_info) then
		--	xrs_debug_tools.actor_info[info] = nil
		--end
	end
end

function create_ammo(section, position, lvi, gvi, pid, num)
	local num_in_box = INI:r_u32_ex(section, "box_size")
	if not num_in_box then
		error("function create_ammo section = %s, the box_size parameter is missing or not found!", section)
		return nil
	end
	
	local t = {}
	while num > num_in_box do
		t[#t+1] = alife():create_ammo(section, position, lvi, gvi, pid, num_in_box)
		num = num - num_in_box
	end
	local obj = alife():create_ammo(section, position, lvi,	gvi, pid, num)
	table.insert(t, obj)
	return t
end

-- преобразует строку в соответствии со значением
function get_param_string(src_string , obj)
	--printf("src_string is [%s] obj name is [%s]", tostring(src_string), obj:name())
	local script_ids = db.script_ids[obj:id()]
	local out_string, num = string.gsub(src_string, "%$script_id%$", tostring(script_ids))
	if num > 0 then
		return out_string , true
	else
		return src_string , false
	end
end

local save_marker_result = {}
-- Функции для проверки корректности сейв лоад
function set_save_marker(p, mode, check, prefix)
	prefix = tostring(prefix)
		if (check ~= true) then
		if mode == "save" then
			save_marker_result[prefix] = p:w_tell() or 0
			if p:w_tell() > 16000 then
				abort("You are saving too much")
			end
		else
			save_marker_result[prefix] = p:r_tell() or 0
		end
		return
	end
		if not (save_marker_result[prefix]) then
		abort("set_save_marker:%s: Trying to check without marker mode=%s",prefix,mode)
		if (mode == "save") then
			p:w_u16(0)
		elseif (mode == "load") then
			p:r_u16()
		end
		return
	end
		if mode == "save" then
		local dif = p:w_tell() - save_marker_result[prefix]
		if dif >= 8000 then
			error("set_save_marker:%s: WARNING! may be this is problem save point dif=%s",prefix,dif)
		end
		p:w_u16(dif)
	else
		local c_dif = p:r_tell() - save_marker_result[prefix]
		local dif = p:r_u16()
		if dif ~= c_dif then
			error("set_save_marker:%s: INCORRECT LOAD dif=%s c_dif=%s", prefix, dif, c_dif)
		end
	end
		save_marker_result[prefix] = nil
end

-- переводит вектор в строку.
function vec_to_str (vector)
	if vector == nil then return "nil" end
	return string.format("[%s:%s:%s]", vector.x, vector.y, vector.z)
end

-- выводит в лог весь стэк вызова функций.
function callstack()
	if (log and debug and type(debug.traceback) == 'function') then
		log(debug.traceback('\n', 2))
	end
end

-- output of a stack of function calls that may be problematic for the operation of lua
function callstack_accuracy(name)
	if (log and debug and type(debug.traceback) == 'function') then
		local function to_find(string,from,before)
			local new_string = ''
			if string then
				local froms = ''
				local befores = ''
			
				for i = 1, #string do
					local symbol = string:sub(i, i)
					if not froms:find(from) then
						froms = froms:add(symbol)
						if #froms > 3 then
							froms = froms:sub(2,4)
						end
					elseif not befores:find(before) then
						befores = befores:add(symbol)
						if #befores > 3 then
							befores = befores:sub(2,4)
						end
						new_string = new_string:add(symbol)
					else
						break
					end
				end
			end
			return new_string:gsub("tack traceback","!ERROR: function")
		end
		if not name then
			log("---------------------------------------------------")
			log(to_find(debug.traceback('\n', 4),"...","'f'"):gsub("\n....","\n~ possible error in : "))
			log("---------------------------------------------------")
		elseif name == "return" then
			return string.add_all(
				"---------------------------------------------------\n",
				to_find(debug.traceback('\n', 4),"...","'f'"):gsub("\n....","\n~ possible error in : "),
				"\n",
				"---------------------------------------------------"
			)
		end
	end
end

-- меняет team:squad:group обьекта.
function change_team_squad_group(se_obj, team, squad, group)
	local cl_obj = db.storage[se_obj.id] and db.storage[se_obj.id].object
	if cl_obj ~= nil then
		cl_obj:change_team(team, squad, group)
	else
		se_obj.team = team
		se_obj.squad = squad
		se_obj.group = group
	end
	--printf("_G:TSG: [%s][%s][%s]", tostring(se_obj.team), tostring(se_obj.squad), tostring(se_obj.group))
end
----------------------------------------Story_ID -------------------------------------
function get_story_se_object(story_id)
	local obj_id = story_objects.object_id_by_story_id[story_id]
	return obj_id and alife_object(obj_id)
end

function get_story_object(story_id)
	local obj_id = story_objects.object_id_by_story_id[story_id]
	return obj_id and level.object_by_id(obj_id)
end

function get_object_story_id(obj_id)
	return obj_id and story_objects.story_id_by_object_id[obj_id]
end

function get_story_object_id(story_id)
	return story_id and story_objects.object_id_by_story_id[story_id]
end

-----------------------------------------------------------------------------------------------
-- Получить сквад обьекта!!!!!
function get_object_squad(object,caller)
	if not (object) then
		return
	end
		if (object.group_id ~= nil and object.group_id ~= 65535) then
		return alife_object(object.group_id)
	end
		local sim = alife()
	local se_obj = type(object.id) == "function" and sim:object(object:id())
	return se_obj and se_obj.group_id ~= 65535 and sim:object(se_obj.group_id) or nil
end

function get_story_squad(story_id)
	return get_story_se_object(story_id)
end

--Проверка по временному интервалу.
function in_time_interval(val1, val2)
	local game_hours = level.get_time_hours()
	if val1 >= val2 then
		return game_hours < val2 or game_hours >= val1
	else
		return game_hours < val2 and game_hours >= val1
	end
end

function show_all_ui(show)
	local hud = get_hud()
	if not (hud) then
		return
	end
	if(show) then
		level.show_indicators()
--	    db.actor:restore_weapon()
		db.actor:disable_hit_marks(false)
		hud:show_messages()
	else
		if db.actor:is_talking() then
			db.actor:stop_talk()
		end
		level.hide_indicators_safe()
		hud:HideActorMenu()
		hud:HidePdaMenu()
		hud:hide_messages()
--	    db.actor:hide_weapon()
		db.actor:disable_hit_marks(true)
	end
end

function actor_hide_wpn(hide)
	if not db.actor then return end
	if hide == true then
		if db.actor_binder.weapon_hide == false then
			if show_log then printf("actor_hide_wpn::hide weapon") end
			db.actor:hide_weapon()
			db.actor_binder.weapon_hide = true
			local detector = db.actor:active_detector() or db.actor:active_flashlight()
			if detector then
				detector:switch_state(2)
			end
			level.Actor():BlockItemsInput(1)
			return true
		end
	else
		if db.actor_binder.weapon_hide == true then
			if show_log then printf("actor_hide_wpn::show weapon") end
			db.actor:restore_weapon()
			db.actor_binder.weapon_hide = false
			level.Actor():BlockItemsInput(0)
			return false
		end
	end
end

------------------------------------------------------------------------------------------------------
-- ENGINE EXPORTS!!!
------------------------------------------------------------------------------------------------------
local flags = { ret_value = true }
function CInventoryBox_CanTake(obj,itm)
	flags.ret_value = true
	SendScriptCallback("inventory_box_can_take",obj,itm,flags)
	return flags.ret_value
end
-- called when an inventory item is eaten/used
-- returning false will prevent the item from being used

function CInventory__eat(npc,item,bodypart)
	flags.ret_value = true
	SendScriptCallback("on_before_item_use",npc,item,bodypart,flags)
	return flags.ret_value
end

-- Called before actor hit callback
-- returning false will ignore the hit completely
local Monster_hit = false
function CActor__BeforeHitCallback(actor,shit,bone_id)
	--[[
	local hit_to_section = {
		[hit.light_burn] = "light_burn",
		[hit.burn] = "burn",
		[hit.strike] = "strike",
		[hit.shock] = "shock",
		[hit.wound] = "wound",
		[hit.radiation] = "radiation",
		[hit.telepatic] = "telepatic",
		[hit.chemical_burn] = "chemical_burn",
		[hit.explosion] = "explosion",
		[hit.fire_wound] = "fire_wound",
	}
	printf("power=%s impuse=%s type=%s dir=%s who=%s",shit.power,shit.impulse,hit_to_section[shit.type],shit.direction and vec_to_str(shit.direction),shit.draftsman and shit.draftsman:name())
	--]]
	if (shit.type ~= hit.strike) then
		if (bind_stalker_ext.invulnerable_time and time_global() < bind_stalker_ext.invulnerable_time) then 
			if (db.actor) then
				if (db.actor.bleeding > 0) then 
					db.actor.bleeding = 0.2
				end
				if (db.actor.radiation > 0) then 
					db.actor.radiation = -1
				end
			end
			bind_stalker_ext.invulnerable_time = bind_stalker_ext.invulnerable_time - 500
			return false
		end
	end
	
	if (shit.power > 0) then 
		if (shit.draftsman and shit.draftsman:id() ~= 0 and shit.draftsman:cast_Stalker() and shit.draftsman:relation(db.actor) == game_object.friend) then 
			return false 
		end
	end
	
	flags.ret_value = true
	SendScriptCallback("actor_on_before_hit",shit,bone_id,flags)
	return flags.ret_value
end

-- called in ai_stalker_fire.cpp CAI_Stalker::Hit()
-- returning false will ignore the hit completely
function CAI_Stalker__BeforeHitCallback(npc,shit,bone_id)
	-- friendly fire
	if (shit.power > 0) then 
		if (shit.draftsman and shit.draftsman:id() ~= 0 and shit.draftsman:cast_Stalker() and shit.draftsman:relation(npc) == game_object.friend) then 
			return false
		end
	end
	flags.ret_value = true
	SendScriptCallback("npc_on_before_hit",npc,shit,bone_id,flags)
	return flags.ret_value
end

get_console():execute("r__clear_models_on_unload 0")
function CALifeUpdateManager__on_before_change_level(packet)
--[[
	C++:
	net_packet.r					(&graph().actor()->m_tGraphID,sizeof(graph().actor()->m_tGraphID));
	net_packet.r					(&graph().actor()->m_tNodeID,sizeof(graph().actor()->m_tNodeID));
	net_packet.r_vec3				(graph().actor()->o_Position);
	net_packet.r_vec3				(graph().actor()->o_Angle);
--]]
-- Here you can do stuff when level changes BEFORE save is called, even change destination!. Packet is constructed as stated above

	-- Release dead bodies on level change (TODO: Determine if it's a bad idea to do this here)
	--[[
	local rbm = release_body_manager.get_release_body_manager()
	if (rbm) then
		rbm:clear(true)
	end
	--]]
	
	-- READ PACKET
	local pos,angle = vector(),vector()
	local gvid = packet:r_u16()
	local lvid = packet:r_u32()
	packet:r_vec3(pos)
	packet:r_vec3(angle)
	-- crazy hack to help prevent crash on Trucks Cemetery
	local gg = game_graph()
	if (gg:valid_vertex_id(gvid) and alife():level_name(gg:vertex(gvid):level_id()) == "k02_trucks_cemetery") then
		log("k02_trucks_cemetery hack r__clear_models_on_unload 1")
		get_console():execute("r__clear_models_on_unload 1")
	end
	--printf("CALifeUpdateManager__on_before_change_level pos=%s gvid=%s lvid=%s angle=%s",pos,gvid,lvid,angle)
	-- fix for car in 1.6 (TODO*kinda For some reason after loading a game ALL physic objects will not be teleported by TeleportObject need to investigate as to why, possibly something to do with object flags)
	local car = db.actor and db.actor:get_attached_vehicle()
	if (car) then
		TeleportObject(car:id(),pos,lvid,gvid)
	end
		-- REPACK it for engine method to read as normal
	--[[
	packet:w_begin(13)
	packet:w_u16(gvid)
	packet:w_u32(lvid)
	packet:w_vec3(pos)
	packet:w_vec3(angle)
	--]]
	-- reset read pointer
	packet:r_seek(2)
end

-- 'Запуск динамического окна.
function run_dynamic_element(folder,close_inv)
	if close_inv==false then
		folder:ShowDialog(true)
	elseif close_inv==true then
		folder:ShowDialog(true)
		local hud = get_hud()
		if (hud) then
			hud:HideActorMenu()
			hud:HidePdaMenu()
		end
		level.show_weapon(false)
	else
		folder:ShowDialog(true)
	end
end

-- Создание предмета в рюкзаке ГГ.
function give_object_to_actor(obj,count)
	if count==nil then count=1 end
	for i=1, count do
		alife():create(obj,db.actor:position(),db.actor:level_vertex_id(),db.actor:game_vertex_id(),db.actor:id())
	end
end

function EditOnline(id, state)
	if not id then
		error("function EditOnline expected the first argument and got nil!")
		return
	end

	if type(id) ~= "number" then
		error("function EditOnline expected the number of the first argument and received %s!", type(id))
		return
	end

	alife():set_switch_online(id, state)
	alife():set_switch_offline(id, not state)
end

-----------------------------------------
-- New INI wrapper to replace alun_utils.cfg_file
class "ini_file_ex"
function ini_file_ex:__init(fname,advanced_mode)
	self.fname = getFS():update_path('$game_config$', ''):add(fname)
	self.ini = ini_file(fname)
	self.cache = {}
	if (advanced_mode) then
		self.ini:set_override_names(true)
		self.ini:set_readonly(false)
		--self.ini:save_at_end(true)
	end
end

function ini_file_ex:save()
	self.ini:save_as(self.fname)
end

-- r_value and w_value cache results
function ini_file_ex:r_value(s,k,typ,def)
	local name_cache = s:add_all("&", k)
	local cache_result = self.cache[name_cache]
	if (cache_result) then
		return cache_result
	end
	if not (self.ini:section_exist(s) and self.ini:line_exist(s,k)) then
		return def
	end
	local v = self.ini:r_string(s,k)
	if (typ == 1) then
		v = v == nil and def or v == "true" or false
	elseif (typ == 2) then
		v = tonumber(v) or def
	end
	self.cache[name_cache] = v
	return v == nil and def or v
end

function ini_file_ex:w_value(s,k,val,comment)
	self.cache[s:add_all("&", k)] = val
	self.ini:w_string(s,k,val ~= nil and tostring(val) or "",comment ~= nil and tostring(comment) or "")
end

function ini_file_ex:collect_section(section)
	local _t = {}

	local n = self.ini:section_exist(section) and self.ini:line_count(section) or 0
	if (n > 0) then
		for i = 0,n-1 do
			local res,id,val = self.ini:r_line(section,i,"","")
			_t[id] = val
		end
	end

	return _t
end

function ini_file_ex:get_sections(keytable)
	local t = {}
	local function itr(section)
		if (keytable) then
			t[section] = true
		else
			t[#t+1] = section
		end
		return false
	end
	self.ini:section_for_each(itr)
	return t
end

function ini_file_ex:remove_line(section,key)
	self.ini:remove_line(section,key)
end

function ini_file_ex:section_exist(section)
	return self.ini:section_exist(section)
end

function ini_file_ex:line_exist(section,key)
	return self.ini:section_exist(section) and self.ini:line_exist(section,key)
end

function ini_file_ex:r_string_ex(s,k)
	return self.ini:section_exist(s) and self.ini:line_exist(s,k) and self.ini:r_string_ex(s,k)
end

function ini_file_ex:r_bool_ex(s,k,def)
	return self.ini:r_bool_ex(s,k,def)
end

function ini_file_ex:r_float_ex(s,k)
	return self.ini:section_exist(s) and self.ini:line_exist(s,k) and self.ini:r_float_ex(s,k)
end

function ini_file_ex:r_string_to_condlist(s,k,def)
	local src = self:r_string_ex(s,k,def)
	if (src) then
		return xr_logic.parse_condlist(nil, s, k, src)
	end
end

function ini_file_ex:r_list(s,k,def)
	local src = self:r_string_ex(s,k) or def
	if (src) then
		return parse_names(src)
	end
end

function ini_file_ex:r_mult(s,k,...)
	local src = self:r_string_ex(s,k) or def
	if (src) then
		return unpack(parse_names(src))
	end
	return ...
end
